<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在 Linux 下使用 Clash 进行全局上网代理及自动订阅代理和规则</title>
    <link href="/2025/03/21/linux/clash/"/>
    <url>/2025/03/21/linux/clash/</url>
    
    <content type="html"><![CDATA[<h1 id="在-Linux-下使用-Clash-进行全局上网代理及自动订阅代理和规则"><a href="#在-Linux-下使用-Clash-进行全局上网代理及自动订阅代理和规则" class="headerlink" title="在 Linux 下使用 Clash 进行全局上网代理及自动订阅代理和规则"></a>在 Linux 下使用 Clash 进行全局上网代理及自动订阅代理和规则</h1><p>本文将详细介绍如何在 Linux 环境下配置 Clash，以实现全局网络代理。<br>同时使用 proxy-group 与 rule-providers，来实现机场链接和规则的自动订阅。</p><h2 id="下载-Clash"><a href="#下载-Clash" class="headerlink" title="下载 Clash"></a>下载 Clash</h2><p>从以下备份库下载 Clash Premium:<br>由于 Clash Premium 的主库已被删除，我们将使用备份库来获取: <a href="https://github.com/zhongfly/Clash-premium-backup/releases/download/2023-09-05-gdcc8d87/clash-linux-amd64-n2023-09-05-gdcc8d87.gz">Clash-premium-backup</a></p><p>如果备份库失效则可以百度搜索clash for linux 进行下载</p><h2 id="解压-Clash"><a href="#解压-Clash" class="headerlink" title="解压 Clash"></a>解压 Clash</h2><p>解压下载的文件：</p><blockquote><p>gzip -d clash-linux-amd64-n2023-09-05-gdcc8d87.gz<br>chmod +x clash-linux-amd64<br>mv clash-linux-amd64 clash</p></blockquote><p>创建配置文件 config.yaml，并编辑配置：</p><p>确保替换掉 &lt;这里替换为你机场的订阅链接&gt; 为你的实际订阅链接。</p><p>这里我们用了 proxy-groups 和 rule-providers，一来可以直接自动订阅节点，第二可以自动订阅规则。不需要再去配置 crontab 之类的东西了，应该是目前最简单的方式，且最好用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">mixed-port:</span> <span class="number">7893</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">ipv6:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9091</span> <span class="comment"># 最好不要在公网打开面板进行使用</span></span><br><span class="line"><span class="attr">clash-for-android:</span></span><br><span class="line">  <span class="attr">append-system-dns:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">profile:</span></span><br><span class="line">  <span class="attr">tracing:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">experimental:</span></span><br><span class="line">  <span class="attr">sniff-tls-sni:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">tun:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">stack:</span> <span class="string">system</span></span><br><span class="line">  <span class="attr">dns-hijack:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">any:53</span></span><br><span class="line">  <span class="attr">auto-route:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto-detect-interface:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enhanced-mode:</span> <span class="string">fake-ip</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="string">:53</span></span><br><span class="line">  <span class="attr">default-nameserver:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">210.5</span><span class="number">.56</span><span class="number">.145</span></span><br><span class="line">  <span class="attr">nameserver:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">  <span class="attr">fallback:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://8888.google/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://1.0.0.1/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://dns.twnic.tw/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://doh.opendns.com/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://dns-nyc.aaflalo.me/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://dns.aa.net.uk/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://sg.adhole.org/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://kaitain.restena.lu/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://hydra.plan9-ns1.com/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://jp.tiar.app/dns-query</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://doh.asia.dnswarden.com/adblock</span></span><br><span class="line">  <span class="attr">fallback-filter:</span></span><br><span class="line">    <span class="attr">geoip:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">geoip-code:</span> <span class="string">CN</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-providers:</span></span><br><span class="line">  <span class="attr">Exemple:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./example.yaml</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&lt;这里替换为你机场的订阅链接&gt;</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="number">3600</span></span><br><span class="line">    <span class="attr">health-check:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">        <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROXY</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">3600</span></span><br><span class="line">    <span class="attr">use:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Exemple</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rule-providers:</span></span><br><span class="line">  <span class="attr">reject:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/reject.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">icloud:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/icloud.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">apple:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/apple.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">google:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/google.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">proxy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/proxy.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">direct:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/direct.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">private:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/private.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">gfw:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/gfw.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tld-not-cn:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/tld-not-cn.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">telegramcidr:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">ipcidr</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/telegramcidr.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cncidr:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">ipcidr</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/cncidr.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">lancidr:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">ipcidr</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/lancidr.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">applications:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://fastly.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/applications.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,applications,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,clash.razord.top,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,yacd.haishan.me,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,private,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,reject,REJECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,tld-not-cn,PROXY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,gfw,PROXY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,google,PROXY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,telegramcidr,PROXY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MATCH,DIRECT</span></span><br></pre></td></tr></table></figure><p>运行 Clash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clash -f /path/to/your/config.yaml</span><br><span class="line">注意：请替换 /path/to/your/config.yaml 为你的实际配置文件路径。</span><br></pre></td></tr></table></figure><p>测试代理是否工作正常。<br>curl -L google.com<br>设置开机自启<br>创建一个 systemd 服务文件，例如 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;clash.service，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Unit</span>]</span><br><span class="line"><span class="string">Description=Clash</span> <span class="string">Service</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Service</span>]</span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">User=&lt;你的用户名&gt;</span></span><br><span class="line"><span class="string">WorkingDirectory=&lt;Clash配置文件目录&gt;</span></span><br><span class="line"><span class="string">ExecStart=&lt;Clash执行文件路径&gt;</span> <span class="string">-f</span> <span class="string">&lt;Clash配置文件路径&gt;</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Install</span>]</span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br></pre></td></tr></table></figure><p>[注意] 需要替换 &lt;你的用户名&gt;、&lt;Clash 配置文件目录 &gt;、&lt;Clash 执行文件路径 &gt; 和 &lt; Clash 配置文件路径 &gt; 为你的实际信息。<br>重新加载 systemd 管理器配置，并启用 Clash 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now clash.service</span><br><span class="line">systemctl status clash.service</span><br></pre></td></tr></table></figure><p>启动需要设置，如果 http 不需要走代理，就只需要设置 https_proxy 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br></pre></td></tr></table></figure><h3 id="切换配置"><a href="#切换配置" class="headerlink" title="切换配置"></a>切换配置</h3><p>安装jq工具，用于解析JSON字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install jq</span><br></pre></td></tr></table></figure><p>利用curl命令，打印当前配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处的端口在 external-controller 已经配置</span></span><br><span class="line">curl --request GET --url http://127.0.0.1:9091/proxies</span><br></pre></td></tr></table></figure><p>配置文件信息太长，只看节点选择策略组选中的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request GET --url http://127.0.0.1:9091/proxies | jq <span class="string">&#x27;.proxies.&quot;🚀 节点选择&quot;.now&#x27;</span></span><br></pre></td></tr></table></figure><p>第一次输出结果应该为DIRECT直连，此状态下无法翻墙，拼接为以下curl命令，其中proxies后面是你要操作的策略组转义字符串，data内的name对应需要操作的完整节点名<br>由于🚀 节点选择这个策略组包含emoji和中文，所以需要进行转义，使用如下在线网站进行转义</p><p><a href="https://tool.oschina.net/encode?type=4">https://tool.oschina.net/encode?type=4</a></p><p>拼接为以下curl命令，其中proxies后面是你要操作的策略组转义字符串，data内的name对应需要操作的完整节点名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request PUT --url <span class="string">&quot;http://127.0.0.1:9091/proxies/%F0%9F%9A%80%20%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9&quot;</span> --header <span class="string">&quot;Content-Type: text/plain&quot;</span> --data <span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;上海联通转台湾HiNet[M][Trojan][倍率:1]\&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>正常操作完不会有返回值</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>如有不懂可自行查阅：<a href="https://telegra.ph/%E8%8B%A5%E5%B9%B2%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE-CordCloud-11-22">此链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三年之期</title>
    <link href="/2025/02/28/summary/25-3-1/"/>
    <url>/2025/02/28/summary/25-3-1/</url>
    
    <content type="html"><![CDATA[<h2 id="历年总结"><a href="#历年总结" class="headerlink" title="历年总结"></a>历年总结</h2><p>2022 年，自己完成了身份上的转变，正式开始后端的职业生涯，在公司的安排下，进入教育行业，做教育行业的需求，由于体系的问题，一方面是做 TOC 的业务应用，满足客户经理、学校客户的需求；另一方面也是做 TOB 与 TOG 的需求，满足领导、教育局对平台的期望，公司的步子迈的挺大，研发的基础设施并未能跟上公司的节奏，但是好在也坚持下来了。</p><p>2023 年于自己来说，属于思维方式上的转变，由工作的后端主业，变成逐步统筹研发、测试、产品、运维进行工作内容上的协调与沟通，从零到一搭建团队跟项目，并且出差不同的城市学习不同的业务经营方式、商业模式、研发方法等，思维上开拓了不少。</p><p>2024 年，在自己的意识形态上发生转变后，在后端研发的主职过程中，也兼任部分技术经理的工作，大大小小的研发流程问题、部门协同的工作问题也踩坑不少，总体来说对于技术的要求跟需求，都让步于业务的发展跟要求，属于不断试错的一个过程，对于自己的技术能力提升有限，但是团队的互相理解更一步加深。</p><p>2025 年，因为公司的组织架构调整离开了教育行业，前往技术中台研发一卡通平台，但由于 deepSeek AI 大模型的技术突破，以及国家政策的支持与导向，开始研发数据标注平台，完成跟算法组同事的配合与协调，从算法组同事身上也学习到不少的算法术语与调研大模型、使用大模型，简单模型的调参数能力，至于算法理论的基础，也逐步在恶补，压力比前几年都大，毕竟后端简化工作来说，只需要提供 API 的服务能力即可，对于数理逻辑的要求并没有算法组要求高。</p><h2 id="未来期望"><a href="#未来期望" class="headerlink" title="未来期望"></a>未来期望</h2><p>1、个人发展在公司的业务选择上已经到达一个瓶颈，对于自己来说，更希望自己的技术能力有所突破，能够在公司的研发中发挥更大的价值，所以未来可能会再次审视自己职业上的发展。<br>2、自己的技术栈大致规划如下：</p><ul><li>1、3 年的 java 开发经验：熟悉 jvm、gc，对于锁、并发有一定自己的理解，熟悉 spring、springboot、springcloud 等常用框架的使用、配置、搭建，熟悉Spring AOC 与 IOP。</li><li>2、熟悉 git、github、gitlab 等代码工具的使用，熟悉代码规范、代码评审、代码合并等流程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2025</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器化环境搭建</title>
    <link href="/2022/08/19/container/docker/"/>
    <url>/2022/08/19/container/docker/</url>
    
    <content type="html"><![CDATA[<blockquote><p>docker 内环境的搭建</p></blockquote><p>注意：单机环境下的容器管理使用 docker- compose 进行管理，多机环境下使用 K8S (kubernetes) 进行管理！</p><h2 id="1、nacos"><a href="#1、nacos" class="headerlink" title="1、nacos"></a>1、nacos</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8848:8848 -e MODE=standalone -v /opt/docker/nacos/logs:/home/nacos/logs -v /opt/docker/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties --name nacos nacos/nacos-server </span><br></pre></td></tr></table></figure><h2 id="2、mysql"><a href="#2、mysql" class="headerlink" title="2、mysql"></a>2、mysql</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -p 3306:3306 --name mysql -v /opt/docker/mysql/conf:/etc/mysql/conf.d -v /opt/docker/mysql/logs:/var/log/mysql -v /opt/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPE 监控系统分析与搭建</title>
    <link href="/2022/08/19/middleware/GPE/"/>
    <url>/2022/08/19/middleware/GPE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Grafana + Prometheus +Exporter 监控体系的搭建</p></blockquote><h2 id="Prometheus-的监控体系"><a href="#Prometheus-的监控体系" class="headerlink" title="Prometheus 的监控体系"></a>Prometheus 的监控体系</h2><h3 id="1、系统层监控（需要监控的数据）"><a href="#1、系统层监控（需要监控的数据）" class="headerlink" title="1、系统层监控（需要监控的数据）"></a>1、系统层监控（需要监控的数据）</h3><blockquote><p>1、CPU、Load、Memory、swap、disk i&#x2F;o、process 等<br>2、网络监控：网络设备、工作负载、网络延迟、丢包率等</p></blockquote><h3 id="2、中间件及基础设施类监控"><a href="#2、中间件及基础设施类监控" class="headerlink" title="2、中间件及基础设施类监控"></a>2、中间件及基础设施类监控</h3><blockquote><p>1、消息中间件：kafka、redis、RocketMQ 等消息代理&#x2F;中间件<br>2、WEB 服务器容器：tomcat、weblogic、apache、php、spring 系列<br>3、数据库&#x2F;缓存数据库：MySQL、PostgreSQL、MogoDB、es、redis</p></blockquote><h3 id="3、应用层监控"><a href="#3、应用层监控" class="headerlink" title="3、应用层监控"></a>3、应用层监控</h3><p><strong>用于衡量应用程序代码状态和性能</strong></p><blockquote><ol><li>白盒监控：自省指标，等待被下载</li><li>黑盒监控：基于探针的监控方式，不会主动干预、影响数据</li></ol></blockquote><h3 id="4、业务层监控"><a href="#4、业务层监控" class="headerlink" title="4、业务层监控"></a>4、业务层监控</h3><p><strong>用于衡量应用程序的价值</strong></p><blockquote><ol><li>如电商业务的销售量，QPS、dau 日活、转化率等。</li><li>业务接口：登入数量，注册数、订单量、搜索量和支付量。</li></ol></blockquote><h2 id="Prometheus-监控系统安装流程"><a href="#Prometheus-监控系统安装流程" class="headerlink" title="Prometheus 监控系统安装流程"></a>Prometheus 监控系统安装流程</h2><p>prometheus + alertmanage + node_exporter 下载来源可以有以下三种：</p><blockquote><p>1、官网下载：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a><br>2、github 下载：<a href="https://github.com/prometheus/prometheus">https://github.com/prometheus/prometheus</a><br>3、github 镜像下载：<a href="https://hub.fastgit.xyz/prometheus/prometheus">https://hub.fastgit.xyz/prometheus/prometheus</a></p></blockquote><p>下载完毕后按如下 shell 进行先进行解压操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本次采用 prometheus-2.37.0.linux 版本进行操作</span></span><br><span class="line">tar -zxvf prometheus-2.37.0.linux-amd64.tar.gz</span><br><span class="line">mv prometheus-2.37.0.linux-amd64 prometheus-2.37.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本次将 alertmanage 一起都装好，采用 0.24.0.linux-amd64 版本进行操作</span></span><br><span class="line">tar -zxvf alertmanager-0.24.0.linux-amd64.tar.gz</span><br><span class="line">mv alertmanager-0.24.0.linux-amd64 alertmanager-0.24.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本次 node_exporter 版本为 1.3.1.linux-amd64 版本</span></span><br><span class="line">tar -zxvf node_exporter-1.3.1.linux-amd64.tar.gz</span><br><span class="line">mv node_exporter-1.3.1.linux-amd64/ node_exporter-1.3.1</span><br></pre></td></tr></table></figure><p>然后编辑其中的 yml 配置文件(如下所示)，更改成自己需要的环境，重点在 job 那一块。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - &quot;first_rules.yml&quot;</span></span><br><span class="line">  <span class="comment"># - &quot;second_rules.yml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it&#x27;s Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;prometheus&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;localhost:9090&quot;</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;k12_zs_01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">targets:[&quot;localhost:9100&quot;]</span></span><br></pre></td></tr></table></figure><p>需要的内容直接在 job_name 新增字段即可，其中 node_exporter 默认监听端口为 9100 端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为要查看防火墙的状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开放端口(可批量)</span></span><br><span class="line">firewall-cmd --zone=public --add-port=9100/tcp --permanent &amp;&amp; firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭端口(可批量)</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=9100/tcp --permanent &amp;&amp; firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开放端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p>之后开始装 Grafana，其中 shell 操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2022年8月19日最新版本为 grafana-enterprise-9.1.0.linux-amd64，使用二进制包更合适</span></span><br><span class="line">wget https://dl.grafana.com/enterprise/release/grafana-enterprise-9.1.0.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压之后不用改名</span></span><br><span class="line">tar -zxvf grafana-enterprise-9.1.0.linux-amd64.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 从头开始</title>
    <link href="/2022/08/13/java/java-study/"/>
    <url>/2022/08/13/java/java-study/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java 需要从头开始，打扎实基础学习，这是需要花费大量时间的事情！</p></blockquote><p>不同于自己所喜欢的 go 语言，java 是工作需要所以学习的！而且 java 的生态也挺多，工作中快速上手很必要，但是脱离工作，自己的技术是否能真正的过硬，还是需要自己对自己的能力有一个把控！</p><h2 id="Java-SE-基础"><a href="#Java-SE-基础" class="headerlink" title="Java SE 基础"></a>Java SE 基础</h2><blockquote><p>自己学习，也是熬制的一个过程，需要时间！ </p></blockquote><p>到自己现在的阶段，已经能脱离视频学习了，所以大把的时间需要集中起来！文章内容来自 JavaGuide，但绝对不是复制而来，都是自己通过键盘敲字而来！</p><h3 id="1、JVM-vs-JDK-vs-JRE"><a href="#1、JVM-vs-JDK-vs-JRE" class="headerlink" title="1、JVM vs JDK vs JRE"></a>1、JVM vs JDK vs JRE</h3><p>尤其注意⚠️： <strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong><br>故技术最强的阿里系即是自己重写一遍 JVM！</p><p>JVM 即是 java 程序运行所在虚拟机环境，JRE 是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机、Java 类库，java 命令和其他的一些基础构件。JDK 是在 JRE 环境之上，增加了编译器以及编译工具。</p><h3 id="2、OpenJDK-与-Oracle-JDK-的区别"><a href="#2、OpenJDK-与-Oracle-JDK-的区别" class="headerlink" title="2、OpenJDK 与 Oracle JDK 的区别"></a>2、OpenJDK 与 Oracle JDK 的区别</h3><p>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。</p><p>Java 在 sun 公司存在的时候是完全开源的，但是 sun 公司被 oracle 公司收购后闭源了，但是为了维持现状，将核心的 JDK 组件以及一部分代码开源了，就成为了 OpenJDK 。</p><h3 id="3、Java-语言关键字"><a href="#3、Java-语言关键字" class="headerlink" title="3、Java 语言关键字"></a>3、Java 语言关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 关键字 &#123;</span><br><span class="line"><span class="comment">// 访问控制：</span></span><br><span class="line"><span class="keyword">private</span> </span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">protected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类、方法、变量：</span></span><br><span class="line"><span class="keyword">abstract</span>     <span class="keyword">new</span>         <span class="title class_">implements</span>       <span class="keyword">interface</span>    <span class="title class_">volatile</span></span><br><span class="line"><span class="keyword">class</span>        <span class="title class_">final</span>       <span class="keyword">native</span>           <span class="keyword">extends</span>      <span class="title class_">enum</span></span><br><span class="line"><span class="keyword">static</span>       <span class="keyword">strictfp</span>    <span class="keyword">synchronized</span>     <span class="keyword">transient</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序控制</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>项目中，设计要自顶而下，但是实现需要自底而上。</p><p>所以相应的顺序即是从：编写 mybatis &#x2F; mybatis-plus 的 XML 文件（虽然 mybatis-plus 已经是一个很好的 orm 组件了，但是有些复杂的功能还是需要自己进行手写 SQL 语句进行实现） -&gt; 编写 mapper 接口 -&gt; implement -&gt; service -&gt; controller 。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 24 - 31 周总结思考</title>
    <link href="/2022/07/30/summary/22-7-31/"/>
    <url>/2022/07/30/summary/22-7-31/</url>
    
    <content type="html"><![CDATA[<blockquote><p>周总结还是需要写！</p></blockquote><h2 id="24-周～-31-周"><a href="#24-周～-31-周" class="headerlink" title="24 周～ 31 周"></a>24 周～ 31 周</h2><p>原本在 6月底～7月初，也写了一篇博客，但是由于之前电脑丢失，博客数据丢失了，所以博客现在的更新停留在6月初的时间点。故以后的博客元数据，也需要及时同步到 github 的私有仓库上！</p><p>这段时间，工作有着落了，工资也拿到手了，提升自己也是第一要义，以后的人生需要学习的东西还有许多许多！</p><p>工作后所接手的第一个项目就是 Java 的 SpringCloud 项目，整合了许多中间件，包括熟悉的 MySQL、Redis、Nginx、RocketMQ，而后还加入了 Java 的微服务生态，比如 SkyWalking、Nacos、ElasticSearch、Logstash、Kibana、SpringCloud Gateway、Prometheus、Grafana 等，这些知识，之前都有所了解过，但是自己并未能用到实际的生产环境中去，工作也给了自己去开发+部署的机会，对于自己项目工程能力的提升是很大的！</p><h2 id="32～34周"><a href="#32～34周" class="headerlink" title="32～34周"></a>32～34周</h2><p>未来两周也是持续学习 Java 以及其生态，Java 的生态的确成熟很多，但是也笨重很多，所以好好的学习 Java，也对自己学习与使用 Go 在思想层面上有帮助，至少现在设计模式、重构手法，都能通过 Java 来训练，TDD 的思想，也能进行不断的学习与打磨！</p><p>当然，除了代码水平的提升，还需要有其他的提升，比如一个项目如何使用 gitflow 进行分布式开发的流程，项目的业务场景、标书如何撰写，都是自己可以学习的东西！</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 优化</title>
    <link href="/2022/06/14/middleware/mysql3/"/>
    <url>/2022/06/14/middleware/mysql3/</url>
    
    <content type="html"><![CDATA[<h2 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h2><p>索引只是一种数据结构而已，具体看 Mysql 的数据库引擎。</p><p>比如 MyISAM 使用 B 树，InnoDB 使用的 B+ 树。</p><p><strong>（聚簇索引与非聚簇索引是 b 与 b+ 树的两个别名）</strong></p><p>缺点：</p><ul><li><p>1、少量数据不需要</p></li><li><p>2、频繁更新的数据不适合作为索引</p></li><li><p>3、很少使用的字段</p></li><li><p>4、索引提升查询效率、降低增删改的效率</p></li><li><p>5、索引占用空间很大（但是机械硬盘也不值钱了）</p></li></ul><p>优点：</p><ul><li><p>1、查询效率高</p></li><li><p>2、CPU 占用少（order by XXX desc）b 树、b+树不用排序，所以 CPU 计算少</p></li></ul><p>b+ 树也是 b 树的一个种类，b 树查询一个值时间复杂度就是 O(n) </p><h3 id="1、索引细节"><a href="#1、索引细节" class="headerlink" title="1、索引细节"></a>1、索引细节</h3><p><strong>分类</strong>： </p><p>索引一般有三种： 单值索引、唯一索引、复合索引。</p><ul><li><p>单值索引：单列的索引，一个表可以有很多单值索引</p></li><li><p>唯一索引：所有值不能重复，即 distinct</p></li><li><p>复合索引：多个列组成的二级索引</p></li></ul><p><strong>创建索引</strong>：</p><p>方式一：create</p><blockquote><p>单值： <code>create index 索引名称 on 表(字段名称)</code> </p><p>唯一：<code>create unique index 索引名称 on 表(字段名称)</code> </p><p>复合：<code>create index 索引名称 索引名称 on 表(字段名称)</code> &#96;</p></blockquote><p>方式二：alter</p><blockquote><p>单值： <code>alter table 表名 add index 索引名称(字段名称)</code></p><p>唯一：<code>alter table 表名 add unique index 索引名称(字段名称)</code> </p><p>复合：<code>alter table 表名 add index 索引名称(字段名称, 字段名称)</code> </p></blockquote><p>注：primary key 设置自动是主键索引。主键与唯一索引均不能为 null。</p><p><strong>查询&#x2F;删除索引</strong></p><p><code>show index from 表名</code>  &#x2F;  <code>drop index 索引名 on 表名</code></p><h2 id="2、SQL-优化之执行计划"><a href="#2、SQL-优化之执行计划" class="headerlink" title="2、SQL 优化之执行计划"></a>2、SQL 优化之执行计划</h2><p>SQL 优化的主要的原因即是：性能低、SQL 语句执行时间长、等待时间长、索引失效、服务器参数不合理等</p><p><strong>注意</strong>： 有索引才能涉及到 SQL 优化，没有索引一般都是 ALL 级别</p><p>先说 SQL 语句的执行，在 Mysql 数据库引擎进行数据解析的过程中，识别SQL语句后，实际的执行过程与编写的语句不一致，一般执行过程如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from...on...join...where...group by...</span><br><span class="line"></span><br><span class="line">having...select (<span class="keyword">distinct</span>)...<span class="keyword">order</span> by... limit</span><br></pre></td></tr></table></figure><p>优化时候，必须解决的问题就是 SQL 语句的执行计划。SQL 执行计划的关键字：<strong>explain</strong>，可以模拟 SQL 优化器执行 SQL 语句，从而让开发人员具体知道自己写的 SQL 语句的执行。</p><p><strong>使用方法</strong> ：<code>explain + SQL 语句</code> </p><blockquote><p>如 explain  select * from tables</p></blockquote><p>字段值如下图所示，图片点击可以放大查看，更清晰：<br><img src="/images/SQL/index1.png"></p><h3 id="1、id-值相同的执行计划"><a href="#1、id-值相同的执行计划" class="headerlink" title="1、id 值相同的执行计划"></a>1、id 值相同的执行计划</h3><p>id 值相同，即看表后的 table 从上到下的顺序进行执行</p><blockquote><p>而此种情况下的表查询的顺序，会因为表内数量的个数改变而改变。</p><p>原因是计算权重的算法就是<a href="https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E4%B9%98%E7%A7%AF/6323173?fromtitle=%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF&fromid=1434391&fr=aladdin"><strong>笛卡尔积</strong></a>笛卡尔积是连乘，产生的中间过程的数据量，理应越小越好。</p></blockquote><p>  所以在执行计划中，在表最终的结果积一致的情况下，表遵循表内数据从小到大的顺序进行执行。</p><h3 id="2、id-值不同的情况下的执行计划"><a href="#2、id-值不同的情况下的执行计划" class="headerlink" title="2、id 值不同的情况下的执行计划"></a>2、id 值不同的情况下的执行计划</h3><p>id 值不同时，id 值越大越优先进行执行。本质即是多表联结查询转变为子查询，子查询是先执行最内层查询，在执行外层查询，所以即是 id 值越大，越优先进行执行。</p><h3 id="3、select-type-查询类型"><a href="#3、select-type-查询类型" class="headerlink" title="3、select_type 查询类型"></a>3、select_type 查询类型</h3><p>此字段有以下几种显示：</p><blockquote><p>1、primary：此为主查询方法，为最外层的查询</p><p>2、subquery：此为主查询的对立方法，即子查询方法，为内层查询</p><p>3、simple： 此为简单查询，即不涉及子查询与 union 查询</p><p>4、derived：此为衍生查询，会创建一个临时表。</p><p>(1)：如果在 from 子查询中只涉及一个表，则该表为临时表。</p><p>(2)：如果在 from 子查询中涉及两个表，则左表是临时表。</p></blockquote><h3 id="4、type-索引类型"><a href="#4、type-索引类型" class="headerlink" title="4、type 索引类型"></a>4、type 索引类型</h3><p>一般企业中常用的索引类型如下：</p><ul><li>system &gt;&gt; const &gt;&gt; eq_ref &gt;&gt; ref &gt;&gt; range &gt;&gt; index &gt;&gt; all</li></ul><p>以上类型的索引效率越往左越高。</p><p>其中，system 与  const 只是理想情况下的效果，一般 SQL 优化，在 ref ~ range 之间</p><ul><li><p>system (忽略)：只有一条数据的系统表，或衍生表只有一条数据的主查询</p></li><li><p>const (忽略)：仅仅能查到一条数据，只能用于 primary key 或  unique index</p></li><li><p>eq_ref (尽量满足，但是可遇不可求)：唯一性索引：对于每个索引键的查询，返回匹配唯一行数据 ( 只能为 1，不能多、也不能是 0 )，常见于主键索引与唯一索引。即查询的主数据表与临时的表内的数据数量必须一致，才能达到 eq_ref 的效果。</p></li><li><p>ref ：非唯一性索引，对于每一个索引键的拆线，返回匹配的所有行 ( 0，多 )</p></li><li><p>range： 检索指定范围的行，where 后面为范围查询的情况（between、in，&gt;，&lt; 等），但是 in 有时候会索引失效，转变为 ALL 级别</p></li><li><p>index：查询全部索引的数据，索引查询肯定要小于等于全表查询</p></li><li><p>all：查询全部表中数据</p></li></ul><p>总结：system、const 结果只能有一条数据，eq_ref 结果是多条，但是每条数据具有唯一性，ref 结果多条，但是每条数据是 0 或 多条。</p><h3 id="5、possible-keys-、key-、key-len-、ref-、rows-、Extra"><a href="#5、possible-keys-、key-、key-len-、ref-、rows-、Extra" class="headerlink" title="5、possible keys 、key 、key_len 、ref 、rows 、Extra"></a>5、possible keys 、key 、key_len 、ref 、rows 、Extra</h3><p>possible keys 为预测的索引值，不准确</p><p>key 为实际使用的索引。<strong>注意</strong>：如果possible keys &#x2F; key 均为 null， 则没使用索引</p><p>判断复合索引是否完全被使用。如果复合索引有一个索引允许为空，那么key_len 长度会默认+1B，作为空标识符。2 B 标识 varchar 的可变长度。</p><p>ref 为：指明当前表所参照的字段。<strong>注意</strong>：与 type 中的 ref 进行区分</p><p>row 为：被索引优化查询的个数，即量级</p><p>Extra 常见有以下字段：</p><ul><li><p>1、using filesort :  性能消耗大，需要进行额外一次排序(查询) </p><ul><li>对于单索引，如果排序查找的是同一字段，则不会出现 filesort ，如果排序与查找的不是同一字段，则需要使用 using filesort</li><li>在复合索引下，避免使用 using filesort，就使用 where 与 order by 按照复合索引的顺序使用，不要跨列就不用使用（最佳左前缀）</li></ul></li><li><p>2、using temporary：出现性能损耗，用到了临时表，一般出现 group by 语句中</p></li><li><p>3、using index：性能提升，覆盖索引。原因：不读取原文件，只从索引文件读取数据，不需要回表查询，但是使用 using index 时，会对 possible_keys 和 key 造成影响：</p><ul><li>1、没有 where  索引出现在 key 中；</li><li>2、有 where 则索引出现在 key 和 possible_keys 中。</li></ul></li><li><p>4、using where ：既查索引，又查原表。（即回表查询）。</p></li><li><p>5、impossible where：where 字句永远 false</p></li></ul><h2 id="3、单表优化"><a href="#3、单表优化" class="headerlink" title="3、单表优化"></a>3、单表优化</h2><p>在进行单表优化时，主要注意以下几点：</p><ul><li><p>1、where 与 order by 联合使用索引查询，尽量不要跨列进行搜索。</p></li><li><p>2、如果复合索引和使用索引顺序全部一致(且不跨列使用)，则复合索引全部使用，如果部分使用(且不跨列使用)，则使用部分索引。</p></li></ul><p>举个例子，假设我们有一张 book 表，建表语句如下所示，我们也先添加四个数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> book </span><br><span class="line">(</span><br><span class="line">bid <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">primary key</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">authorid <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">not null</span>,</span><br><span class="line">publicid <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">not null</span>,</span><br><span class="line">typeid <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> book <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;tjava&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert into</span> book <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;tc&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert into</span> book <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;wx&#x27;</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert into</span> book <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;math&#x27;</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>); </span><br></pre></td></tr></table></figure><p>然后我们想查询一 authorid &#x3D; 1 且 typeid 为 2 或 3 的  bid， 其查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> authorid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> authorid <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/explain1.png"></p><p>发现没有索引的情况，默认发生的是全表查询，即 explain 执行计划 type 字段值为all ，extra 字段为 using where，而后我们为了让优化的效果更加明显一点，再配合order by desc 来使用，其相应的 sql 语句如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/explain2.png"><br>此时我们会发现，extra 字段会出现 using filesort 字段值，即查询全表后还对返回的数据重新排序，这样很浪费性能，所以我们对其添加索引优化，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> book <span class="keyword">add</span> index idx_bta (bid, typeid, authorid);</span><br></pre></td></tr></table></figure><p>然后再执行上述的sql 语句，结果如下图：<br><img src="/images/SQL/explain3.png"></p><p>可见，增加索引后可以将全表查询变为索引查询，type 等字段发生改变，但是 using where 与 using filesort 还是未能优化掉，所以说此条 SQL 语句还能继续进行相应的优化。</p><p>而sql 语句的优化，即是我们之前说的，理解sql语句在mysql 中的执行顺序，那么按照执行顺序进行索引的优化即是最好。</p><p>比如我们这里是先查 bid ，再查 typeid 与 authorid。但是mysql 中，select 语句执行时在where 之后，所以优化时，索引应为 (typeid, authorid, bid)。</p><p><strong>而 索引 bid 是否能去除呢？</strong></p><p>这里我选择不去除，因为虽然删除 bid 索引后，根据索引也能回表进行查询，但是如果只查一次索引即可得到数据，还是只建议只查索引，虽然这样会导致索引很大，但是牺牲空间换时间也是一种常用的做法。</p><p>继续回到原 SQL 的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><strong>这里注意：</strong> 如果是范围查询的 <code>in</code>  语句，有时候会实现，有时候会失效，所以我们需要再开始使用索引时走一个必定实现的索引，所以更改语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> typeid <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p>同时，我们需要先删除之前添加的索引，防止之前的索引干扰，使用如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_bta <span class="keyword">on</span> book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter table</span> book <span class="keyword">add</span> index idx_atb (authorid, typeid, bid);</span><br></pre></td></tr></table></figure><p>通过 explain 查看相应的执行计划，如下图，可见 type 级别从 index 变为了 range ，提升了一个级别。</p><p>其中有字段 <code>Backward index scan</code> 这是 MySQL8 的新特性，叫做降序索引，在颜群老师的课程中，执行计划显示 type 优化为 ref 级别，而在 MySQL8 中则是 range 级别，可见在 MySQL8 中，这样优化达不到 Mysql5.x 的优化效果。<br><img src="/images/SQL/explain4.png" alt="修改后的执为 range 级别"></p><p>using where 与 using index 最大的区别即是需不需要回原表进行查询。而两者同时出现，即是 in 范围查询有时候失效，有时候不失效的情况。</p><p>所以为了消除这种情况，一般情况用其他有效条件替换 in 即可，如以下 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> typeid <span class="operator">=</span> <span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> bid <span class="keyword">from</span> book <span class="keyword">where</span> authorid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> typeid <span class="operator">=</span> <span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> typeid <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>其 explain 结果如下图，可见 type 字段变为 ref 值，优化上升两个级别，而一般达到ref 或者 eq_ref 级别，已经是比较好的一种情况了。<br><img src="/images/SQL/explain5.png" alt="修改后的执为 ref 级别"></p><h2 id="4、多表优化"><a href="#4、多表优化" class="headerlink" title="4、多表优化"></a>4、多表优化</h2><p>最好的学习方式，还是举例进行学习！所以跟单表优化一样，还是进行举例：</p><p>创建两个表 teacher 与 course，其建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> teacher2 </span><br><span class="line">(</span><br><span class="line">id <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">primary key</span>,</span><br><span class="line">cid <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> course2</span><br><span class="line">(</span><br><span class="line">cid <span class="type">int</span>(<span class="number">4</span>),</span><br><span class="line">cname <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> teacher2 <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert into</span> teacher2 <span class="keyword">values</span> (<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert into</span> teacher2 <span class="keyword">values</span> (<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> course2 <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;java&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> course2 <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;python&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> course2 <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;kotlin&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后我们将两表通过左连接进行两表连接，查询 cname &#x3D; ‘java’ 的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher2 <span class="keyword">as</span> t <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> course2 <span class="keyword">as</span> c <span class="keyword">on</span> t.cid <span class="operator">=</span> c.cid <span class="keyword">where</span> c.cname <span class="operator">=</span> <span class="string">&#x27;java&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其相应的执行计划如下：<br><img src="/images/SQL/explain6.png"></p><p>可见 type 为 all，即全表查询，而且 extra 出现一个新的字段值： using join buffer，出现此字段就是说明 sql 写的很差，MySQL 底层使用优化器对 sql 进行了优化，即使用连结缓存。但是由于不涉及索引查询，所以必然还是很慢。</p><p>所以两表的索引应该如何去加呢？直接上结论：<strong>小表驱动大表</strong>，写法如  <strong>小表.X &#x3D; 大表.X</strong>  ，原理就是根据 CPU 与内存的空间局部性原理，不用频繁进入磁盘访存拿出数据。</p><p>所以，关于两表索引的增加，一般是先看连接，比如左外连结在左表上加索引、右外连结在右表上加索引。小表中使用频繁的字段加索引。</p><p>故加索引如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> teacher2 <span class="keyword">add</span> index index_teacher2_cid(cid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter table</span> course2 <span class="keyword">add</span> index index_course2_cname(cname);</span><br></pre></td></tr></table></figure><p>此后执行效果直接提升为 ref 级别，而且不再出现 using join buffer，证明 SQL 语句优化的还行。</p><p><img src="/images/SQL/explain7.png" alt="直接提升到 ref "></p><p>而关于三表优化只需要记住两个个原则即可</p><ul><li>1、小表驱动大表</li><li>2、索引建立在经常查询的字段上</li></ul><p>注意 ：<strong>SQL 优化是一种概率事件！是否实际使用了我们的优化，需要通过 explain 进行查看</strong></p><h2 id="5、避免索引失效的一些原则"><a href="#5、避免索引失效的一些原则" class="headerlink" title="5、避免索引失效的一些原则"></a>5、避免索引失效的一些原则</h2><ul><li>a、复合索引；<ul><li>复合索引不跨列或者无序使用（最佳左前缀匹配）</li><li>复合索引，尽量使用全索引匹配。</li></ul></li><li>b、不要再索引上进行任何操作（函数计算、类型转换等），否则都会使索引失效；<ul><li>而且复合索引中，如果对左侧的索引进行操作，那么包括此索引的右侧索引全部失效。、</li><li>复合索引不能使用不等于（!&#x3D;&gt;&lt;）或 is null （is not null），否则自身以及右侧的索引全部失效。</li><li>复合索使用等于（&#x3D;&gt;&lt;）有部分概率使自身以及右侧的索引全部失效。</li><li>SQL优化由于SQL 优化器等原因，并非100%成立。一般而言，范围查询的（&gt; &lt; in）之后的索引失效</li><li>补救方式：尽量使用覆盖索引。</li></ul></li><li>c、like 后尽量以“常量”开头，不要以%开头，否则索引失效；</li><li>d、尽量不要使用类型转换（显示、隐式）否则索引失效；</li><li>e、尽量不要使用 or ，否则索引失效，左右的索引都会失效</li></ul><h2 id="6、索引优化方法"><a href="#6、索引优化方法" class="headerlink" title="6、索引优化方法"></a>6、索引优化方法</h2><ul><li>1、exist 与 in 使用情况<ul><li>主查询数据集大：in</li><li>子查询数据集大：exist</li></ul></li><li>2、order by 优化<ul><li>using filesort ，有两种算法：双路排序与单路排序（根据 I&#x2F;O 的次数）</li><li>选择使用 单路、双路，调整 buffer 的容量大小。</li><li>避免使用 select *  </li><li>复合索引不跨列</li><li>保证全部的排序字段，排序的一致性（都是升序与降序）</li></ul></li></ul><h2 id="7、SQL排查-慢查询"><a href="#7、SQL排查-慢查询" class="headerlink" title="7、SQL排查-慢查询"></a>7、SQL排查-慢查询</h2><p>慢查询日志是 MySQL 提供的一种日志记录，用于记录 MySQL 中响应时间超过阈值的 SQL 语句。</p><p>配置文件中显示为 : long_query_time，默认为 10s 。</p><p>慢查询日志默认是关闭的：开发时建议打开，部署时候关闭。<br><img src="/images/SQL/slow-query.png" alt="默认关闭"></p><p>一般是临时开启，如果需要永久开启，直接在配置文件中追加配置即可。</p><p>linux 上也能通过使用 mysqldumpslow 工具对慢 SQL 语句进行排查，可以通过设置，对sql语句进行快速筛选。<br>使用命令  mysqldumpslow  –help</p><blockquote><ul><li>s : 排序方式</li><li>r : 逆序</li><li>l : 锁定时间</li><li>g : 正则匹配</li></ul></blockquote><p>参考 bash 写法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取返回记录最多的 3 个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 3 /var/lib/mysql/localhost-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取访问次数最多的 c3 个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log</span><br></pre></td></tr></table></figure><p>具体细节，在实践中学习即可。</p><p>一般来说，实际的生产过程中有挺多复杂的场景，但是在业务量没有提升的时候，具体问题可以不进行优化，待业务量与使用量上来后，在进行优化，毕竟做事都是有时间成本。</p>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 redis 底层</title>
    <link href="/2022/06/13/middleware/redis2/"/>
    <url>/2022/06/13/middleware/redis2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要用于 redis 的底层原理、源码实现的个人学习记录，配图主要来自极客时间。</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先，redis 主要是为了实现<strong>高性能、高可靠、高可扩展性</strong>三个高度。</p><p>而全面学习 redis，主要是当redis 出现相应的故障问题时，开发人员能进行快速对问题进行定位与解决。</p><p>而对于问题的定位排查需要的流程，我见过画的最好的图还是极客时间的蒋老师的问题排查图。</p><p><img src="/images/middleware/redis1.png"></p><h2 id="Redis-底层数据结构"><a href="#Redis-底层数据结构" class="headerlink" title="Redis 底层数据结构"></a>Redis 底层数据结构</h2><p> redis 底层数据结构主要采用整数数组和压缩列表，但是在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？</p><p>这有两个方面的原因：</p><blockquote><p>1、从内存利用率出发，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</p><p>2、从CPU高速缓存出发，在Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 22 - 23 周总结思考</title>
    <link href="/2022/06/05/summary/22-6-5/"/>
    <url>/2022/06/05/summary/22-6-5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这几周做了身体检查，主要以调整作息为主</p></blockquote><h2 id="22-23-周"><a href="#22-23-周" class="headerlink" title="22 ~ 23 周"></a>22 ~ 23 周</h2><p>这两周，给自己的任务安排非常轻，所以去医院做了一些检查，检查结果良好。但是医生建议为了避免以后的恶化，需要多多更改作息，比如早睡早起、每日半小时以上的跑步、游泳等体育锻炼。</p><p>想一想，考研以后，自己已经有接近两年的时间没有进行游泳的体育锻炼了，小县城的游泳馆已经倒闭了，毕竟有这样的需求的乡村人还是挺少的。</p><p>除开这些之外，主要还是就 Redis 的技术进行研究，毕竟之前也没有系统性学习过，只是通过相应的文档进行开发驱动的使用罢了。</p><h2 id="24-25-周"><a href="#24-25-周" class="headerlink" title="24 ~ 25 周"></a>24 ~ 25 周</h2><p>主要还是进行 Redis + Mysql 的理解，包括相应的设计与实现，其实并不能说明，学到的东西能发挥作用，学习的知识也是为了未来进行储备的，一直持续到今年年底的 6 个月对这两技术进行底层化的探索。</p><p>下个 6 个月的大周期，主要给 kafka、消息队列、devops 的一些组件(监控、K8S)等运维化的工具研究。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 20 - 21 周总结思考</title>
    <link href="/2022/05/21/summary/22-5-21/"/>
    <url>/2022/05/21/summary/22-5-21/</url>
    
    <content type="html"><![CDATA[<blockquote><p>两周总结一次，原因是因为周总结有一些不好写，自己又陷入了一个瓶颈期，所以需要将时间的跨度拉大一些，这样才好</p></blockquote><h2 id="20-21-周"><a href="#20-21-周" class="headerlink" title="20 ~ 21 周"></a>20 ~ 21 周</h2><p>20~21 周主要是在参与开源社区，帮 GoFrame 社区做 pgsql 驱动的单元测试，期间主要学习了以下内容：</p><blockquote><p>1、如何写单测（模仿 + 逻辑改写）</p><p>2、如何参与开源项目以及如何做 code review </p><p>3、pgsql 语法学习，以及做数据库的 sql 测试（就是执行一个创建表、退出 test 协程时候删除表的逻辑）</p><p>4、github workflow ci&#x2F;cd 流程的学习</p></blockquote><p>大致如以上三点所示，反思总结是学习与提升很大，尤其是在 code review 上，可以通过学习别人提交的 commit 对比，然后与别人交流设计的思想，这样人的能力能得到一个快速的提升。</p><p>但是缺点也很明显，知识没有得到一个系统性的提升，只是在工作中的碎片化的碎片化知识学习，应该是使用碎片化的时间进行系统性的学习，比如看书、看视频等。看博客、写博客也只是一种零散性的学习而已。</p><h2 id="22-23-计划"><a href="#22-23-计划" class="headerlink" title="22 ~ 23 计划"></a>22 ~ 23 计划</h2><p>接下来六个月，需要自己在 mysql、redis、kafka 这样的中间件，进行相应的学习与提示修养，所以需要进行一个系统化的提升。</p><p>主要准备看 mysql 与 redis 的书、专栏进行系统化的学习，当然也会进行一个实战的提升。</p><p>还有即是整洁之道三部曲：代码整洁之道、架构整洁之道、匠艺整洁之道三者。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 18 - 19 周总结思考</title>
    <link href="/2022/05/07/summary/22-5-7/"/>
    <url>/2022/05/07/summary/22-5-7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总结与思考，可能并非是单纯从技术的层面上进行思考。</p></blockquote><p>18 周到 19 周，中间度过了五一，稍微休息了三四天，所以上一周的总结就没有及时的跟上计划。当然，我自己也不是一个完全按照计划执行的人，总会有一些人本质上的劣根性存在的。</p><h2 id="18-周"><a href="#18-周" class="headerlink" title="18 周"></a>18 周</h2><p>在 18 周的时候，由于自己实现不了一个完整的的项目，而感受到个人能力的不足，从大学以来，这样的痛苦就是恒常的，总是在追寻自己想做的事情，而有时候缺忽略了自己的能力。</p><blockquote><p>有些当时想要去完成的东西，却以自己暂时的能力达不到，又没办法进行良好的行为坚持，而以失败告终。</p></blockquote><p>所以自己暂时性的放弃了，自己建立一个完整的项目的念想，毕竟没有工作经验、实习经验，所谓的项目，不过是自己照着培训机构去模仿而已，好好打扎实基础、去开源项目上进行小功能的追加、bug 维护，可能更合适一些。</p><blockquote><p>现在自己写博客坚持了大半年了，技术水平的提升也有所长进，这大半年也算小有成就。唯一不足的就是没能在企业中创造价值，属于自己的闭门造车罢了。</p></blockquote><p>所以自己在后端算是学有余力的情况下，开启了前端的基础学习，自己虽然在大学时候，也算了解过前端的一些知识，所以直接上手 vue 框架，这样确实不符合一般性的规律，在此还是<strong>不建议大家上手直接从框架开始，一步一个脚印走慢一些，对于自己的个人成长更好</strong>。</p><p>像我的数据结构与算法以及两年的 408 学习，虽然考出的考研成绩不理想，但是也算这方面比较扎实的层面，当然也有一些漏洞，不过大纲还是没问题。这样两年的学习，带给自己专业基础上的提升也是显而易见的。</p><p>总之，基础一定是王道，自己最快速的提升阶段，理应是算法的学习了，所以初学者将算法学习扎实，是最重要的一个环节。</p><h2 id="19-周"><a href="#19-周" class="headerlink" title="19 周"></a>19 周</h2><p>19 周主要是五月一日，劳动节、青年节放假，所以自己休息了三天，期间主要是看 <strong>王德峰教授的 “中西方文化差异的源头”，以及他对佛法的讲述。</strong></p><p>闲暇之余才能思考，人越忙的时间，想法就越纯粹：脑中只有把活干好。中国社会如王教授所说：从一个普遍物质不满足的时代，走入一个普遍精神不安宁的时代。中国人如何去理解自己价值，如何找到自己安身立命的地方。</p><h2 id="20-周计划"><a href="#20-周计划" class="headerlink" title="20 周计划"></a>20 周计划</h2><p>未来还是以自己的计划为主，多方面进行学习与提升，不仅只是技术方向上，沟通能力、人文社科、申论 + 行测。全方面的素质提升，对自己带来的效果，更加适合人作为人而存在。</p><hr><p>最近几周，对自己写博客的内容有所质疑，毕竟自己写博客的目的也是为了加深自己对知识的理解，技能的熟练。</p><p>而看到自己以前的博客，质量与内容，可能初学的时候，还能勉勉强强的接受，到现在一看，排版不好、内容质量也不算高，维护更新就更不用说了。</p><p>除了基础之外，一切东西都是需要即时进行更新的。就像 web 框架一样，一段时间没有使用，就可能 bug 满天飞。如果不及时进行维护，那么一方面用户会快速流失，另一方面也会导致失去对待项目代码质量的感知，技能就不再是技能，而是知识罢了。</p><p>所以，最近几周，不会再继续撰写新的博客，讲 GMP、内存模型、垃圾回收、go 并发的内容，在扩充扩充，对自己理解了，但是未能实现的功能即时的进行实现。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言中的 channel 学习</title>
    <link href="/2022/05/05/go/concurrency/channel/"/>
    <url>/2022/05/05/go/concurrency/channel/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要学习 Go 语言中 channel 数据结构使用，以及工作过程中的避坑。文章中的代码主要参考极客时间 go 并发编程，如有需要查看其详细内容，请前去购买！</p></blockquote><h2 id="channel-使用方向上的避坑"><a href="#channel-使用方向上的避坑" class="headerlink" title="channel 使用方向上的避坑"></a>channel 使用方向上的避坑</h2><p>虽然 Go 的开发者极力推荐使用 channel。但是通过大家的工程化道路上的探索， channel 并不是处理并发问题的普适性的使用方法，有时候使用传统的并发原语更简单，而且不容易出错。</p><p>所以在使用并发原语时候，一般遵循以下几种设置方式:</p><blockquote><p>1、共享资源的并发访问使用传统并发原语</p><p>2、复杂的任务编排和消息传递使用 channel</p><p>3、消息通知机制使用 channel，除非只想 signal 一个 goroutine，才使用 Cond</p><p>4、简单等待所有任务的完成用 WaitGroup，也有 channel 的推崇者用 channel，都可以</p><p>5、需要和 select 语句结合，使用 channel</p><p>6、需要和超时配合时，使用 channel 和 context</p></blockquote><h2 id="channel-具体使用的方式"><a href="#channel-具体使用的方式" class="headerlink" title="channel 具体使用的方式"></a>channel 具体使用的方式</h2><p>1、动态处理不定数量的 channel ，使用 reflect.Select 函数，将 channel 当成参数传入，具体案例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建SelectCase</span></span><br><span class="line">    <span class="keyword">var</span> cases = createCases(ch1, ch2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行10次select</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        chosen, recv, ok := reflect.Select(cases)</span><br><span class="line">        <span class="keyword">if</span> recv.IsValid() &#123; <span class="comment">// recv case</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;recv:&quot;</span>, cases[chosen].Dir, recv, ok)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// send case</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;send:&quot;</span>, cases[chosen].Dir, ok)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCases</span><span class="params">(chs ...<span class="keyword">chan</span> <span class="type">int</span>)</span></span> []reflect.SelectCase &#123;</span><br><span class="line">    <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建recv case</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">        cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">            Dir:  reflect.SelectRecv,</span><br><span class="line">            Chan: reflect.ValueOf(ch),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建send case</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">        v := reflect.ValueOf(i)</span><br><span class="line">        cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">            Dir:  reflect.SelectSend,</span><br><span class="line">            Chan: reflect.ValueOf(ch),</span><br><span class="line">            Send: v,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cases</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码先使用 createCases 函数分别为每个 channel 生成了 recv case 和 send case，并返回一个 reflect.SelectCase 数组。</p><p>然后，通过一个循环 10 次的 for 循环执行 reflect.Select 从 cases 中伪随机的选择一个 case 执行。</p><p>第一次肯定是 send case，因为此时 channel 还没有元素，recv 还不可用。等 channel 中有了数据以后，recv case 就可以被选择了。这就可以处理不定数量的 channel 。</p><p>2、经典的消息传递案例</p><blockquote><p>有 4 个 goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine 打印出它自己的编号，要求你编写程序，让输出的编号总是按照 1、2、3、4、1、2、3、4……这个顺序打印出来。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Token <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWorker</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span> Token, nextCh <span class="keyword">chan</span> Token)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        token := &lt;-ch         <span class="comment">// 取得令牌</span></span><br><span class="line">        fmt.Println((id + <span class="number">1</span>)) <span class="comment">// id从1开始</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        nextCh &lt;- token</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chs := []<span class="keyword">chan</span> Token&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token), <span class="built_in">make</span>(<span class="keyword">chan</span> Token)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建4个worker</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> newWorker(i, chs[i], chs[(i+<span class="number">1</span>)%<span class="number">4</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先把令牌交给第一个worker</span></span><br><span class="line">    chs[<span class="number">0</span>] &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义一个令牌类型 Token，其结构为空的 struct，一般都是使用空结构体进行消息的通知！</p><p>接着定义一个创建 worker 的方法，这个方法会从它自己的 chan 中读取令牌。哪个 goroutine 取得了令牌，就可以打印出自己编号。</p><p>因为需要每秒打印一次数据，所以，我们让它休眠 1 秒后，再把令牌交给它的下家。接着，在第 16 行启动每个 worker 的 goroutine，并在第 20 行将令牌先交给第一个 worker</p><p>这样，就会保证程序的运行是 1、2、3、4 的顺序输出。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 17 周总结</title>
    <link href="/2022/04/24/summary/22-4-24/"/>
    <url>/2022/04/24/summary/22-4-24/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本周效率有所上升</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本周尝试使用全栈的方式去实践项目，前端使用 React 中 ant design pro，后端使用 java 三大组件，之后如果有需求，重构会选择 go。</p><p>1、使用 ssm 框架进行开发基本的做法与 go 语言一致，对比两种语言：</p><blockquote><p>使用 java 进行业务开发，比 go 开发效率快捷很多: 包括依赖管理、使用注解运行等，go mod 管理包的方式，还是欠缺一些火候。</p><p>就个人而言，还是喜欢使用 go 语言进行核心业务的开发，比如微服务的组件等。</p></blockquote><p>2、go 中的微服务模块大纲、异常处理两模块概念学习完毕，需要进行相应的实现，go-zero 与 kratos 在有了扎实的理论基础之后可以学习起来了！</p><h2 id="下一周计划"><a href="#下一周计划" class="headerlink" title="下一周计划"></a>下一周计划</h2><p>1、微服务的概念整理，现在只做了一个大纲的内容，相应细节部分需要进一步的填充。</p><p>2、Go 语言微服务模块:并行编程、go工程化实践两个模块学习。</p><p>3、设计模式学习理解。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言中的错误处理</title>
    <link href="/2022/04/19/go/microservice/error/"/>
    <url>/2022/04/19/go/microservice/error/</url>
    
    <content type="html"><![CDATA[<blockquote><p>通过模块化组件的方式，学习 Go 语言的微服务</p></blockquote><h2 id="Go-语言的错误处理"><a href="#Go-语言的错误处理" class="headerlink" title="Go 语言的错误处理"></a>Go 语言的错误处理</h2><p>Go 语言中的 error 定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 1.13 版本之前，我们通常使用的是 <code>errors.New()</code> 来进行返回一个 error 对象指针，相应的源码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 Go 中的指针与 C 中指针大致相同，都是指向某块内存地址值，可以通过 * 解引用的方式进行使用。至于此处为什么错误类型需要返回一个指针变量，如下解释：</p><blockquote><p>主要是防止因为相同的字符串进行匹配，导致错误类型区别不准而导致的问题</p></blockquote><p>可能第一次听会难以理解，我们通过代码来解释，来看以下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errorString(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrorName = New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ErrorStructType = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ErrorName == New(<span class="string">&quot;EOF&quot;</span>) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Named Type Error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ErrorStructType == errors.New(<span class="string">&quot;EOF&quot;</span>) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Struct Type Error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出的是 <code>Named Type Error</code>，因为 <code>var ErrorStructType = errors.New(&quot;EOF&quot;)</code> 与 <code>if ErrorStructType == errors.New(&quot;EOF&quot;)</code> 虽然字符串的值相同，但是因为返回的是一个指针地址，地址不同的指针进行比较，当然也不同。所以这就是为什么要返回指针的原因。</p><p>其中 <code>panic</code> 与 <code>error</code> 的区别，主要是 <code>error</code> 类型定义仅仅只作为值类型进行处理，其抛出错误，证明业务进行到此处，有错误，但是不影响全局，程序员在后续能进行处理。</p><p>而 <code>panic</code> 一般表示不可恢复类的错误，比如栈溢出、索引越界等程序员在后续无法进行处理的问题，必须修改代码才能解决问题。</p><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>一般错误类型有以下几种:</p><p>1、<code>Sentinel Error</code> 预定义的错误，如 <code>io.EOF</code>、<code>syscall.ENOENT</code>。使用预定义的错误相当的不方便，所以尽可能避免使用预定义的错误，如果实在要使用，需要联系资深的程序员，进行 <code>code review</code> 。</p><p>2、<code>Error types</code> 使用 <code>error interface</code> 接口的自定义类型，定义后可以包装底层的错误，提供更多的上下文与堆栈的信息，方便程序员进行调试、定位问题。但是使用这种 interface 接口进行实现的 API 需要将 error 变成 public 字段，会导致和调用者产生强耦合，从而导致 API 变得脆弱。</p><p>所以还是得尽量避免使用 <code>error types</code></p><p>3、<code>Opaque errors</code>  最为灵活的错误处理，主要是只返回错误，但是错误内部不透明，一般建议 API 的设计，对外只暴露一个 error 类型的返回值即可！</p><h2 id="go-1-13-版本前的错误处理"><a href="#go-1-13-版本前的错误处理" class="headerlink" title="go 1.13 版本前的错误处理"></a>go 1.13 版本前的错误处理</h2><p>一般的错误处理模式基本上是 <code>if err != nil &#123;&#125;</code> 这种常见的模式。</p><p>所以此处博主只写，博主建议的事情：</p><p>1、无第三方库协作的时候，简单使用 <code>errors.New()</code> 或者 <code>errors.Errorf()</code> 两个函数进行方法的处理。</p><p>2、如果需要配合 github 开源第三方包以及公司中台组件内部的包，使用 <code>errors.Wrap()</code> 与 <code>errors.Wrapf()</code> 保存堆栈信息，最终集中化输出所有日志，而不是遇到错误就打印日志。</p><h2 id="go-1-13-版本后的错误处理"><a href="#go-1-13-版本后的错误处理" class="headerlink" title="go 1.13 版本后的错误处理"></a>go 1.13 版本后的错误处理</h2><p>go 在 1.13 版本给 <code>errors</code> 包新增了两个函数方法：</p><blockquote><p>errors.Is() 与 errors.As()</p></blockquote><p>并在 <code>fmt</code> 包中也新增了 <code>fmt.Errorf()</code> 函数方法。</p><p>用于向错误中添加错误字段，占位符为 <code>%w</code>，用于支持以上两个 <code>errors</code> 方法。具体使用案例如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;access denied: %w&quot;</span>, ErrPermission)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrPermission)</span><br></pre></td></tr></table></figure><h2 id="go-日志错误处理注意事项"><a href="#go-日志错误处理注意事项" class="headerlink" title="go 日志错误处理注意事项"></a>go 日志错误处理注意事项</h2><p>1、关于 <code>log.Fatal()</code> 使用只推荐在 go 项目 init 函数中使用，或者main 函数内初始化配置失败时候使用！因为 <code>log.Fatal()</code> 函数会调用 <code>os.Exit(1)</code>，此种情况下会导致程序直接退出，defer 函数都不会执行，不利于程序排查问题！</p><h2 id="uber-go-guide-错误处理"><a href="#uber-go-guide-错误处理" class="headerlink" title="uber_go_guide 错误处理"></a>uber_go_guide 错误处理</h2><p>1、若调用者需要自己处理其中抛出的错误，采用 error.As() 或 error.Is() 函数合适。</p><p>2、错误如果不需要匹配，则如果是静态字符串，则使用 errors.New 进行抛出即可，若是动态字符串信息，则使用 fmt.Errorf 或者自定义的错误。</p><table><thead><tr><th align="center">错误匹配？</th><th align="center">错误消息</th><th align="center">指导</th></tr></thead><tbody><tr><td align="center">No</td><td align="center">static</td><td align="center">errors.New</td></tr><tr><td align="center">No</td><td align="center">dynamic</td><td align="center">fmt.Errorf</td></tr><tr><td align="center">Yes</td><td align="center">static</td><td align="center">top-level var with errors.New</td></tr><tr><td align="center">Yes</td><td align="center">dynamic</td><td align="center">custom error type</td></tr></tbody></table><h3 id="参考-Uber-Go-语言编码规范"><a href="#参考-Uber-Go-语言编码规范" class="headerlink" title="参考 Uber Go 语言编码规范"></a>参考 <a href="https://github.com/xxjwxc/uber_go_guide_cn#Errors">Uber Go 语言编码规范</a></h3>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>microservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 16 周总结</title>
    <link href="/2022/04/17/summary/22-4-17/"/>
    <url>/2022/04/17/summary/22-4-17/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这几周主要学习微服务，顺便继续学习 Go web 使用的组件</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上周主要是学习了 twitter 公司的分布式 ID 生成的雪花算法以及微服务的一些概念，跟架构相关的一些知识：比如单体架构 &#x3D;&gt; 模块化架构 &#x3D;&gt; 微服务架构的演进、rpc 框架的技术选型考量、API 网关的划分、面向前端应用的后端服务等。</p><p>举两个学习的小例子：</p><p>1、API 两种设计模式：分为<code>面向资源内网与面向业务场景</code>两种类型。</p><p>2、MicroService 的划分</p><ul><li><p>通过业务职能进行划分 &#x3D;&gt; 分部门：如售前、售中、售后</p></li><li><p>通过背景上下文进行拆分 &#x3D;&gt; DDD 的拆分方式。</p></li></ul><p>DDD 是 domin drive development 的概念，大家都知道概念，但是实现落地都不是特别理想</p><h2 id="下一周计划"><a href="#下一周计划" class="headerlink" title="下一周计划"></a>下一周计划</h2><p>1、总结微服务的概念，整理成博客文集，微服务化需要很长的时间以及队伍的努力与领导的支持。</p><p>2、继续学习 Go 语言微服务的具体模块，比如异常处理模块、日志模块等，建议可以参考极客时间的 Go 进阶训练营的计划！</p><p>3、Go 的第三方的组件，以及准备学习一些其他的知识，70% 的时间放在学习日后与 Go 语言相关的知识，剩下的时间需要学习其他领域、其他的行业的知识，永远需要有 plan B 计划，因为这个行业的确 35 岁被优化是事实，多手准备总是好的。</p><hr><h2 id="4-月-20-日摘抄"><a href="#4-月-20-日摘抄" class="headerlink" title="4 月 20 日摘抄"></a>4 月 20 日摘抄</h2><p>1、提升自己的 “免疫力”</p><p>机体免疫力、心里免疫力、财务免疫力、价值免疫力，战胜困难，需要提升所有免疫力。</p><p>2、明确的短期目标</p><p>学习圈层的划分一般为三种：舒适区、学习区、困难区。跳出自己的舒适区，走入学习区，这样行为不会太难，所以路得一步一步走。</p><p>3、番茄时钟周期</p><p>使用 25 分钟工作学习、5 分钟休息的时间，这样的时间使用起来会更加的高效。<br>而且需要转变自己的学习方式，学多少不重要，知识的管理与输出非常重要。</p><p>4、输出学习方法</p><blockquote><p>1、学习到什么</p><p>2、有什么思考</p><p>3、准备怎么做</p></blockquote><p>以思维导图化的形式。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪花算法</title>
    <link href="/2022/04/11/middleware/snowflake/"/>
    <url>/2022/04/11/middleware/snowflake/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要学习 Twitter 开源的雪花算法</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>雪花算法是 Twitter 公司开源的 64 bit 整数组成的分布式 ID, 并且在单机上递增！</p><p>snowflake-64 bit 如下图所示：<br><img src="/images/middleware/snowflake.png" alt="snowflake"></p><p>如图，<br>1、雪花算法默认左起第一位应该是 0, 第一位在实际中并无任何作用。</p><p>2、从第一位之后的 41 位都是时间戳，单位为 ms, 能容纳 69 年的时间。以某个时间点为基准, 基准可以自行设置, 偏移量为其中的 41 位的数值。</p><p>3、第 43 - 52 位, 十位是工作机器的 ID 号, 因为是分布式的算法, 所以应该支持多台机器。从左开始的五位表示数据中心的 ID, 后五位表示工作节点的 ID, 最多容纳 1024 个节点。</p><p>4、剩下 12 位为序列号, 记录同毫秒内产生不同的 ID。每个节点每毫秒从 0 开始不断累加, 最多累加 4095。</p><p>故 1 ms 内最多产生 1024 x 4096 &#x3D; $2^{22}$ 个不同的 ID 号</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1、bwmarrin-snowflake"><a href="#1、bwmarrin-snowflake" class="headerlink" title="1、bwmarrin&#x2F;snowflake"></a>1、<a href="https://github.com/bwmarrin/snowflake">bwmarrin&#x2F;snowflake</a></h3><p>Go 语言的原生雪花算法实现</p><h3 id="2、sony-sonyflake"><a href="#2、sony-sonyflake" class="headerlink" title="2、sony&#x2F;sonyflake"></a>2、<a href="https://github.com/sony/sonyflake">sony&#x2F;sonyflake</a></h3><p>sony 公司实现的 sonyflake, 在 sonyflake 的基础上进行修改，基本实现的原理跟 snowflake 差不多，如下图</p><p><img src="/images/middleware/sonyflake.png" alt="sonyflake"></p><p>sonyflake 主要是修改了时间戳，计量单位变为了 10 ms，所以可记录的时间延长为 174 年，sequence ID 跟之前的定义一致，Machine ID 即是节点的 ID 值。</p>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>snowflake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 15 周总结</title>
    <link href="/2022/04/10/summary/22-4-10/"/>
    <url>/2022/04/10/summary/22-4-10/</url>
    
    <content type="html"><![CDATA[<blockquote><p>慢慢积累，不能急</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、上周成果并不大，go-zero-look-look 部署成功，加上看起了<strong>重构</strong>的书，重构的理念与 TDD 的思想，的确都是软件设计的基本功。好好学好软件工程的思想，并应用到实践！</p><p>2、SQL 又复习了一遍，go-zero-look-look 的部署坑点，主要在 MySQL 一块，基于木目前的基本情况，不应该使用图形界面，先好好写 SQL 语句进行使用！</p><h2 id="下一周计划"><a href="#下一周计划" class="headerlink" title="下一周计划"></a>下一周计划</h2><p>又继续回归到 go-web 本身，go-web 的一些第三方的组件需要进行熟悉！</p><p>1、<a href="https://github.com/spf13/viper">viper 配置工具</a>、<a href="https://github.com/uber-go/zap">zap 日志</a></p><p>2、go 语言操作 MySQL、Redis 的第三方包：<a href="https://github.com/jmoiron/sqlx">sqlx</a>、<a href="https://github.com/go-redis">go-redis</a></p><p>3、徐昊老师使用 Java 进行 TDD 思想的传播，自己是 java 不熟悉了，但是想到自己身为程序员，需要快速学习知识，所以 java 当成工具用，不喜欢它，但是也不能抗拒！</p><p>4、每日一道算法题目，入大厂，还是需要写。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TDD 实践</title>
    <link href="/2022/04/04/go/TDD/TDD-2/"/>
    <url>/2022/04/04/go/TDD/TDD-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>TDD 的项目驱动</p></blockquote><h2 id="TDD-具体原则"><a href="#TDD-具体原则" class="headerlink" title="TDD 具体原则"></a>TDD 具体原则</h2><p>1、当且仅当存在失败的自动化测试，才开始编写生产代码</p><p>2、消除重复(徐昊老师：消除坏味道)</p><p>经典的红&#x2F;绿&#x2F;重构(Red&#x2F;Green&#x2F;Refactoring)</p><blockquote><p>红：编写一个失败的小测试，甚至可以是无法编译的测试；</p><p>绿：让这个测试快速通过，甚至不惜犯下任何罪恶；</p><p>重构：消除上一步中产生的所有重复（坏味道）。</p></blockquote><h2 id="TDD-工作流程"><a href="#TDD-工作流程" class="headerlink" title="TDD 工作流程"></a>TDD 工作流程</h2><p>学习过程中，老师建议使用任务分解法，作为 TDD 的核心要素：</p><blockquote><p>1、先构思软件的使用方式，然后把握对外的接口方向</p><p>2、大致的构思方向，划分组件以及组件之间的关系，如果没有头绪，也可以不划分</p><p>3、根据需求的功能描述拆分功能点，功能点要考虑正确路径与边界条件</p><p>4、根据组件与组件的关系，将功能划分到组件中</p><p>5、针对拆分写测试，然后进入红&#x2F;绿&#x2F;重构模式</p></blockquote><p><img src="/images/go/TDD-2.jpg" alt="TDD-2"></p><h2 id="2022-6-9日新增"><a href="#2022-6-9日新增" class="headerlink" title="2022-6-9日新增"></a>2022-6-9日新增</h2><ul><li><p>1、通过学习 TDD，发现多余的代码会给团队增加编译成本、跑用例的时间成本（这两项影响不大），最重要的是影响理解的成本。</p></li><li><p>2、好的测试，就应该通过测试用例就能清晰的理解业务逻辑。TDD 的说法是写不出测试代码，就是不能理解整个业务需求。理解业务需求不需要通过一行一行的看代码进行理解！</p></li><li><p>TDD 对程序员来说是一种内功修炼，通过 TDD 会对自己的掌握的知识进行重现，比如语言特性、设计模式、重构手法以及对业务的理解。</p></li><li><p>TDD是一种对做事方法的极致拆分，一次只做一件事，思考业务逻辑时就不考虑实现和代码坏味道；编写业务代码时，也仅考虑能通过用例的逻辑；而重构时，也是不能改变原来的代码逻辑的。通过一个个极小粒度的操作，实现最终整体的协调。</p></li><li><p>程序员需要对自己的编程的手艺进行匠艺的打磨，比如代码的鲁棒性，就是修改一个模块内部的代码后，需要修改其他的模块多不多。如果不多，证明code 的鲁棒性良好，反之如果需要修改大量的模块，则证明不好。</p></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>发现自己花在 TDD 的时间上少了，所以为了保证自己的代码质量以及学习的方式，决定需要花更多的时间在 TDD 上，进行思考。</p><p>项目选用 Java 先跟着老师的代码思路走，再针对 Go 语言进行自己的项目实现，如果只是自己从老师的项目出发去模仿老师的 Java 风格去写 Go，只会像一道菜一样“串味”而变得难吃。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 14 周总结</title>
    <link href="/2022/04/03/summary/22-4-3/"/>
    <url>/2022/04/03/summary/22-4-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>坚持做长期主义者，践行自己的观点，输入与输出都重要！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、上周写了一个 HTTP 的服务器接口，重新拾起大学学习的一些 HTTP 服务器的基础知识与一些 Golang 官方包！</p><p>2、学习了 MySQL 的两种日志的具体区别：redo-log 与 bin-log，MySQL 的聚簇索引与非聚簇索引，主键索引与普通索引等，具体也请看 MySQL 的博客。</p><p>3、学习 TDD，开始写第一个 TDD 的具体项目：命令行参数解析，具体请看 TDD 的那一篇博客！</p><h2 id="下一周计划"><a href="#下一周计划" class="headerlink" title="下一周计划"></a>下一周计划</h2><p>本周的内容学习并不多，而且大部分的时间，忘记自己再干什么事情了，好像干了一些事情，也好像没干，可能日更更能记录自己的日子，但是可以知道的是 Test-Driven-Development 自己的确很认可！</p><p>1、程序员不仅要阅读项目、阅读文档，读书也是非常重要的。类似于<strong>代码整洁之道、架构设计之道、软件架构设计原则</strong>等高维层次的书也需要阅读！电子书个人感觉，方便，但是阅读的质量并未能达到纸质书的效果，而且自己在大学期间阅读的相应技术纸质书籍太少了！所以每年要多花点钱在自己的技术书籍上，多读一些经典的软件设计书籍，软件开发本身也是一个设计的过程，创造力的具体体现还是在经验上。</p><p>2、开发过程中，自己很有可能遇到几个细小的知识点无法搞定，写代码不需要多久，调试 + 格式的整理是时间占比较大的部分！日后需要先进行伪代码与 test 的文件撰写，写完后在开始正式的代码开发，身为程序员，对代码本身也需要敬畏！</p><p>3、Golang 官方的 package 包需要深入研究一下！第三方的包与库文件可以等待工作业务需要的时间去使用与研究，TDD 做好的同时，也需要进行实践驱动开发，具体的案例是先使用，再通过查看源代码的方式理解其中的设计思想与原理！包括架构设计、微服务、设计模式。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 开发一个 HTTP Web 服务器/客户端</title>
    <link href="/2022/03/31/go/concurrency/HTTP/"/>
    <url>/2022/03/31/go/concurrency/HTTP/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前的 zinx 学习，是基于 TCP&#x2F;UDP 的 socket 协议进行编写</p><p>而本次要实现的是基于 HTTP 协议开发一个 Web 服务器端与客户端！</p></blockquote><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>服务器端要求：</p><ul><li>1、服务端维护一个内存数据结构，所有数据进程重启丢失，不做数据持久化，不考虑内存容量问题</li><li>2、服务端实现一个网络 API 接口，客户端向该 API 发送一个网络请求，请求数据是一个 string 的信息</li><li>3、服务端该 API 收到请求后响应一个 []string 的信息，返回之前发送过的所有 string，当次请求发送的 string 一定在最后，不关心是否重复</li></ul><p>示例：</p><blockquote><p>第一次请求发送：”a”，响应: []string{“a”}</p><p>第二次请求发送：”b”，响应: []string{“a”, “b”}</p><p>第三次请求发送：”a”，响应: []string{“a”, “b”, “a”}</p><p>注意服务端代码部分，任何情况下均不能退出进程。</p></blockquote><p>客户端要求：</p><ul><li><p>1、客户端必须是 Golang 函数（该函数后面简称 BcjClient ），调用该服务端的 API 接口</p></li><li><p>2、该客户端函数输入参数为：string，输出参数为： []string，和 error<br>客户端函数是个function&#x2F;函数，不是method&#x2F;方法</p></li><li><p>3、注意客户端函数业务代码执行过程中，任何情况下均不能退出进程。</p></li><li><p>4、客户端函数的类型必须严格匹配。</p></li></ul><p>源码要求：</p><ul><li><p>1、代码运行结果应当正确</p></li><li><p>2、不应该有 data race ( race condition&#x2F;竞争条件&#x2F;数据竞争 )。多线程客户端调用服务端时，不应当出现任何2个客户端得到的同样响应的可能性。</p></li><li><p>3、需要满足 Database transaction（数据库事务）的 Serializability（可串行性）要求，(注意：Golang 的 data race 工具只能找到部分 data race 情况。)</p></li><li><p>4、代码代码不允许忽略错误，而且只能调用官方标准库，不能包含其他第三方代码(比如 github.com&#x2F;xxx，比如 “golang.org&#x2F;x&#x2F;sync&#x2F;xx” )。只有 GOROOT&#x2F;src 下面的库算官方库，其他都不算官方库。</p></li><li><p>5、实现应当简洁，代码可读性不能过差</p></li></ul><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>1、http 服务，基于 http 协议，并非 socket 进行实现</p><p>2、web 请求，restful 标准下，采用 POST 进行客户端的 web 服务请求</p><p>3、开发第一个版本时服务器维护的内存数据结构采用 sync.Map，采用 client 不设置用户名称，统一设置 token 值为 Client，返回客户端数据为 string 类型，并通过简单的空格字符串 “ “ 进行分离每一个 []string 类型的元素。</p><p>4、(未完成)第二个版本客户端自设名称为 token 值，通过header 包头的 token 值来对客户端进行区分，这个token 值的维护放置于客户端，理论上为保证数据安全，应该放置于服务器。</p><h2 id="开发的细节"><a href="#开发的细节" class="headerlink" title="开发的细节"></a>开发的细节</h2><p>具体内容就不再此显示，说几个开发中的细节</p><blockquote><p>1、Go 语言很适合使用<strong>测试驱动开发</strong>，开发过程中，首先需要进行逻辑的梳理，逻辑梳理好之后再开始代码的撰写，上来就写代码都是想到哪里写到哪里，这种习惯不好，<strong>最合适的方法是先使用注释写好相应的需求逻辑，再写代码，很实用</strong>！</p><p>2、在做 string 字符串存储成 []string 类型的切片的时候，服务器端程序也需要使用一个 []string 类型进行保存，但是服务器回显给客户端是以 io.writer 实现的 writer 接口返回 []byte 流的数据，<strong>而 []string 直接转为 []byte 流数据形式，之后客户端对于格式的处理较为麻烦</strong>，所以最好还是 []string 类型，通过拼接一个 string 传输给客户端，我选择 []string 中间分割字符为空格字符 。客户端接受到这个string类型的字符串后，使用 strings.Split() 函数，以空格字符进行分割。</p><p>3、为了解决客户端先于服务器端启动时间不同，导致的客户端 Dail 服务器端发生端口拒绝错误，采用 for 循环提交POST请求，直到请求建立成功后，再 break for 循环。</p><p>4、bug fix: 防止程序panic 掉，mutex.unlock 并未释放，所以采用 defer m.Unlock 合适</p></blockquote><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在服务器端，<strong>使用 sync.Map 数据结构对传输的字符串进行存储，防止进行并发访问与并发存储</strong>，但是由于自己在并发的能力功底不足，导致虽然设计是 sync.Map 控制，但仍存在 data race 的情况，无奈之下还是对一整段进行了加锁处理，其实也能使用全局的 channel 进行处理。但是这都与最初自己想要一步实现拒绝数据的竞争性访问的设计理念冲突，暂时也没想到很好的解决办法！等日后再对其进行优化！</p><h3 id="代码附件"><a href="#代码附件" class="headerlink" title="代码附件"></a>代码附件</h3><p>客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BcjClient</span><span class="params">(writer <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> r *http.Response</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, err := http.NewRequest(</span><br><span class="line">http.MethodPost,</span><br><span class="line"><span class="string">&quot;http://127.0.0.1:8999/v1&quot;</span>,</span><br><span class="line">bytes.NewReader([]<span class="type">byte</span>(writer)),</span><br><span class="line">)</span><br><span class="line">req.Header.Add(<span class="string">&quot;Token&quot;</span>, <span class="string">&quot;Client&quot;</span>)</span><br><span class="line">req.Header.Add(<span class="string">&quot;content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"></span><br><span class="line">r, err = client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err: %s\n&quot;</span>, err)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(Body io.ReadCloser)</span></span> &#123;</span><br><span class="line">_ = Body.Close()</span><br><span class="line">&#125;(r.Body)</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将传入的字符串变成字符串切片，并除去最后的换行格式问题！</span></span><br><span class="line">ToVisual := strings.Split(<span class="type">string</span>(content), <span class="string">&quot; &quot;</span>)</span><br><span class="line">ToVisual = ToVisual[:<span class="built_in">len</span>(ToVisual)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">/*fmt.Printf(&quot;%s\n&quot;, ToVisual)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ToVisual, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*func main() &#123;</span></span><br><span class="line"><span class="comment">scanner := bufio.NewScanner(os.Stdin)</span></span><br><span class="line"><span class="comment">for scanner.Scan() &#123;</span></span><br><span class="line"><span class="comment">BcjClient(scanner.Text())</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cache sync.Map</span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClientHandler</span><span class="params">(writer http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> req.Method != <span class="string">&quot;POST&quot;</span> &#123;</span><br><span class="line">_, _ = fmt.Fprintf(writer, <span class="string">&quot;Request is not POST! please send POST request!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token := req.Header.Get(<span class="string">&quot;Token&quot;</span>)</span><br><span class="line">body, err := ioutil.ReadAll(req.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">_, _ = fmt.Fprintf(writer, <span class="string">&quot;read body err, %v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">GetFromCache, ok := cache.Load(token)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">GetFromCache = <span class="built_in">append</span>(GetFromCache.([]<span class="type">string</span>), []<span class="type">string</span>&#123;<span class="type">string</span>(body)&#125;...)</span><br><span class="line">cache.Store(token, GetFromCache)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">cache.Store(token, []<span class="type">string</span>&#123;<span class="type">string</span>(body)&#125;)</span><br><span class="line">GetFromCache, _ = cache.Load(token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change := GetFromCache.([]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">var</span> ToClient <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> change &#123;</span><br><span class="line">ToClient += v</span><br><span class="line">ToClient += <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">_, _ = fmt.Fprintf(writer, <span class="string">&quot;%s\n&quot;</span>, ToClient)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 原理</title>
    <link href="/2022/03/29/middleware/mysql2/"/>
    <url>/2022/03/29/middleware/mysql2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>理解思考项目，原理先行，实践在后</p></blockquote><h2 id="1、redo-log-与-bin-log-两种日志区别"><a href="#1、redo-log-与-bin-log-两种日志区别" class="headerlink" title="1、redo-log 与 bin-log 两种日志区别"></a>1、redo-log 与 bin-log 两种日志区别</h2><p>首先，redo-log 与 bin-log 两种日志是 InnoDB 数据库引擎为了满足事务的持久性与原子性引入了的，其中，redo-log 是 InnoDB 的特性，bin-log 是mysql 中 server 层的日志。</p><h3 id="redo-log-日志"><a href="#redo-log-日志" class="headerlink" title="redo-log 日志"></a>redo-log 日志</h3><blockquote><p>在更新一条记录时，先将其先写入 redo-log 中，然后更新内存，此时的记录就算更新完毕。等待数据库引擎空闲时，再将其更新至磁盘中。</p><p>而 redo-log 大小固定，由 innodb_log_file_size 设置大小和 innodb_log_files_in_group 设置个数，若要修改，则需重启服务。</p><p>一旦更新的数据条数达到 redo-log 日志记录数的上限，数据库引擎则先停止手中的活，将一部分的 redo-log 日志中的数据更新入磁盘，再继续运行。</p></blockquote><p>本质上来说，redo-log 就是一个循环队列，如下图所示(原图来自极客时间专栏)：<br><img src="/images/SQL/redo_log.png" alt="redo-log"><br>其中 witer_pos 为当前记录日志的地址，checkpoint 为当前要擦除的地址，擦除记录前需要将记录更新到数据库文件。</p><p>write_pos 和 checkpoint 之间的是 redo-log 空余的地址块，可以用来记录新的操作。如果 write pos 追上 checkpoint 即是 redo-log 记录操作已满，不能再执行新的更新，需要数据库引擎先擦除一些记录。</p><p>redo-log 可以防止因为数据库异常重启，而导致提交记录丢失的问题 – 这种特性称为 “crash-safe”</p><h3 id="bin-log-日志"><a href="#bin-log-日志" class="headerlink" title="bin-log 日志"></a>bin-log 日志</h3><blockquote><p>先介绍一下 bin-log 日志的背景：</p><p>最开始的时候，MySQL 中没有 InnoDB 数据库引擎，其自带的引擎为 MyISAM，而 MyISAM 没有 “crash-safe” 的能力，bin-log 日志只是归档记录的功能</p></blockquote><p>现在来区别一下这两种日志：</p><ul><li><p>1、redo-log 是 <strong>InnoDB 引擎特有</strong> 的；<br>   bin-log 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>2、redo-log 是 <strong>物理日志</strong>，记录 “在某个数据页上的修改” ；<br>   bin-log 是逻辑日志，记录的是这个语句的 <strong>原始逻辑</strong>；比如 “给 ID&#x3D;2 这一行的 c 字段加 1 “。</p></li><li><p>3、redo-log 是 <strong>循环写的，空间固定</strong>；<br>    bin-log 是以 <strong>追加</strong> 的方式写入的。“追加写” 是 bin-log 文件达到一定大小后，会切换到下一个 bin-log 日志文件，并不会覆盖以前的日志。</p></li></ul><p>所以可得到以下结论:</p><blockquote><p>1、redo-log 的写盘时间会直接影响系统的吞吐，所以 redo-log 的数据量要尽量少。</p><p>2、由于系统崩溃的不确定性，重启重放 redo-log 文件时，系统不会知道，redo-log 中的那个 page 页已经修改入磁盘，所以 redo-log 的重放必须可以重入磁盘。</p><p>3、一般来说，<strong>建议一个 redo-log 只涉及一个内存 page 页来进行修改</strong>，这样就可以兼顾逻辑日志与物理日志的优势！</p></blockquote><p>而 redo-log 提交是有两个阶段的：<strong>prepare 和 commit 阶段</strong>。</p><p>而之所以进行两个阶段的提交，也是为了达到 “crash-safe” 的目的。</p><h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><p>假设 redo-log 都是一次性提交，不分两个阶段，此时我们对一个字段 c 值进行更新，让 c 值从当前的 0，更新为 1。</p><p>情景1：我们先写 redo-log 后写 bin-log。假设在 redo log 写完，binlog 并未写完时，MySQL 进程异常重启。</p><blockquote><p>redo log 写完之后，虽然系统崩溃也能将 MySQL 异常启动前的数据恢复回来。但是 bin-log 并未写完，此时记录的 bin-log 文件就没有记录之前操作的语句。</p><p>因此，在之后备份日志的 bin-log 也没有相应的操作语句。而若我们需要恢复临时库，由于 bin-log 记录的语句丢失，临时库恢复出来的这一行 c 的值就是 0，与原库的值不同。</p></blockquote><p>情景2：我们先写 bin-log，后写 redo-log 假设在 binlog 写完，redo-log 并未写完时，MySQL 进程异常重启。</p><blockquote><p>如果在 bin-log 写完之后，系统崩溃，由于 bin-log 不具备 “crash-safe” 的功能，而 redo-log 没写，所以崩溃恢复以后这个事务无效。</p><p>但是 bin-log 里面已经记录了”c 从 0 改为 1” 的日志。所以在之后用 bin-log 恢复临时库时，就会多出一个事务，恢复出来的 c 的值就是 1，与原库的值不同。</p></blockquote><p>所以两阶段提交就是让这 redo-log 与 bin-log 两个状态保持逻辑上的一致。</p><p>针对于异常重启，在 MySQL 设置中的 <code>innodb_flush_log_at_trx_commit</code>、<code>sync_binlog</code> 均设置为 1，能保证 MySQL 异常重启之后数据不丢失与 bin-log 文件不丢失</p><h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><p>1、MySQL 的 bin-log 完整性</p><blockquote><p>MYSQL 的 bin-log 拥有完整的形式：</p><p>1、statement 格式，最后会有 COMMIT;</p><p>2、row 格式，最后会有 XID event;</p><p>3、MySQL 5.6.5 版本后也引入了 bin-log checksum 用于验证 bin-log 内容的正确性，所以一旦 bin-log 所在的磁盘出现故障，可以通过验证 checksum 来确定准确性！</p></blockquote><p>2、关于 bin-log 备份建议</p><p>一般性建议是一周一备份与一日一备份进行选择。看业务的评估，比如 RTO (恢复目标时间) 指标，一周一备份存储成本小，但是 RTO 长，而一日一备份，RTO 时间小，但是存储的成本大。</p><h2 id="2、事务中的隔离性"><a href="#2、事务中的隔离性" class="headerlink" title="2、事务中的隔离性"></a>2、事务中的隔离性</h2><p>事务概念：数据库在操作数据时，为了保证其逻辑的一致性的最小的单位，即是事务。</p><blockquote><p>事务的特性：<strong>A (Atomicity)、C (Consistency)、I (Isolation)、D (Durablity)</strong> 即原子性、一致性、隔离性、持久性;</p></blockquote><p>因此，事务是保持逻辑一致性、可恢复性的重要方法，而锁是保证事务的完整性与并发性的重要概念！</p><p>本次主要讲内容为隔离性。</p><h3 id="隔离性的概念"><a href="#隔离性的概念" class="headerlink" title="隔离性的概念"></a>隔离性的概念</h3><p>隔离性的存在主要是为了<strong>区分多个事务并行执行的顺序问题</strong>，比如多个事务并行执行时，出现脏读、不可重复读，幻读等。</p><blockquote><p>脏读：读取到其他的事物未提交的数据；</p><p>不可重复读：前后读取记录内容不一致；</p><p>幻读：前后读取记录数量不一致。</p></blockquote><p>所以隔离性针对于以上的情况，分成如下几个级别的隔离：<strong>读未提交、读提交、可重复读与串行化</strong></p><ul><li><p>1、读未提交：一个事物还未提交，其所做的变更可以被其他事务读取</p></li><li><p>2、读提交：一个事务提交之后，其所做的变更才能被其他事务读取</p></li><li><p>3、可重复读：一个事务执行过程中看到的数据是一致的，未提交时其所做的变更对其余事务不可见！</p></li><li><p>4、串行化：对一个记录进行加读写锁，若其发生冲突，后访问的事务需要等前一个事务执行完毕时，才能继续执行。</p></li></ul><p>上面四种情况，并行性逐步降低，但是安全性逐步升高！</p><p>Oracle 数据库的默认隔离级别是读提交，所以从 Oracle 数据库迁移到 MySQL 数据库中，需要设置 MySQL 的启动参数 <code>transaction-isolation</code> 的值设置成 <strong>READ-COMMITTED</strong></p><p>MySQL 数据库默认的隔离级别是可重复读，但是可重复读会导致幻读的情况</p><h3 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h3><p>在 MySQL 数据库中，为了控制并发执行的语句的顺序，引入了多版本分布式控制 MVCC (Mutiversion Concurrency Control)。</p><p>其具体内容可以概况如下：每条记录在更新的时候都会同时记录一条回滚日志：undo-log，同一条记录在系统中可以存在多个版本。抽象不好理解，可以看下图：</p><p><img src="/images/SQL/MySQL-isolation1.png" alt="isolation"></p><p>若我们需要将当前 4 的值恢复到 1 时，需要执行 3 次 undo-log 回滚。</p><p>而当系统中不存在比回滚日志更早的 read-view 时，undo-log 则会被删除。</p><p>以上图为例子，当 read-viewA 视图被删除后，将 3 改为 2 之前的 undo-log 即会被删除。</p><p>所以说一般开发时，MySQL 数据层的事务尽量避免过长。</p><h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>MySQL 中的事务启动方式一般为两种</p><blockquote><p>1、显式启动：使用 begin 或 start transaction。 配套的语句为 commit。回滚语句为 rollback</p><p>2、set autocommit &#x3D; 0, 此命令会将线程自动关掉，只有手动执行上述两种配套的语句，才能进行一个事务的提交，或者断开连接时提交</p></blockquote><p>所以建议使用 <strong>set autocommit &#x3D; 1</strong>，通过显式语句来启动事务，而 commit 命令一般使用 <strong>commit work and chain</strong> 命令，即提交并且启动下一个事务。带来的效果是从程序开发的角度可以明确的知道每个语句是否存在于事务中！</p>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 12 - 13 周总结</title>
    <link href="/2022/03/27/summary/22-3-28/"/>
    <url>/2022/03/27/summary/22-3-28/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上两周没写周总结，写周总结还是挺有效的，至少输入与输出能够理顺，将逻辑顺十分清晰。</p></blockquote><h2 id="12-周"><a href="#12-周" class="headerlink" title="12 周"></a>12 周</h2><blockquote><p>1、APISIX 网关的相关知识学习</p><p>2、Redis 的面试概念学习</p><p>3、sync 包中的 Pool(协程池的学习)</p></blockquote><p>令牌桶、漏桶算法的学习，包括 TDD 的了解、思考到现在的实践，都挺有收获的。</p><h2 id="13-周"><a href="#13-周" class="headerlink" title="13 周"></a>13 周</h2><blockquote><p>1、Docker 的复习</p><p>2、GeekingTime TDD 实践 + Learn TDD In Go 的学习</p><p>3、算法题目练习以及 gin 框架的深入，学习 web 路由的路由匹配算法，以及学习极客兔兔的 7days 课程，小有收获，但是不成体系，所以暂时不放下这个课程</p></blockquote><h2 id="14-周"><a href="#14-周" class="headerlink" title="14 周"></a>14 周</h2><p>打算继续学习 TDD，进行 TDD 的实践，由于自己的毕业设计是做路面语义分割的图像算法模块的落地，也是复现国外的论文，并通过迁移学习模型的方式进行改进，但是无法解决过拟合的问题。</p><p>导致现在处于一个比较尴尬的状态：算法学的不怎么样，开发也没学得太好。所以暂时的想法是自己就是继续维护更新大三做课程设计的 Go web 项目，把个人博客系统改为社区系统，然后加入新学习的知识：包括 TDD，做一些单元测试，并且想一想如何进行高并发的模拟情节，边学习变改，希望能在go 服务器的道路上更强。</p><blockquote><p>同时，算法刷题也不能落下，要继续高频算法的刷题，刷题的目的是为了维持自己的解决问题的思维！</p></blockquote><hr><p>3-30 日<br>这几日在思考做项目的一些事情，比如自己还是在学习go web，但是思来想去，觉得 go-web 项目不应该是现在这个阶段的重点，现在自己的阶段：没有真正的企业级项目实战的经历，也没有使用微服务的框架进行微服务开发的经历，而 web 项目的含金量并不高，而且 web 项目在企业工作中，所应用的场景也不是重点，所以重点现在应该在云上，包括这里推荐一个博主，也是我很佩服的大佬：<a href="https://space.bilibili.com/179520437">人月聊IT</a>，虽然关注大佬，没多久，但是通过大佬的一些视频，<a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAwpxCtvXDIzP9iOFpmBYKxC2Vu6qIKtDCPW2iylT3bxc/?source=tuwen_detail&log_from=1d90843f6ac6d_1648563756220">今日头条的文章</a>，与他写作十几年的个人博客，发现他的个人思想与个人的技术业务水平都非常高。推荐大家前去学习、交流！</p><p>也是从大佬那，学习到了相应的微服务、云中间的一些理念，结合自己现状：项目的主要方向应该放入微服务那一块，所以在了解几个微服务框架后，开始对 go-zero 微服务进行相应的学习！</p><p>1、先从其中的例子开始学习，<a href="https://github.com/zeromicro/zero-examples">网址点击此处即可</a></p><p>2、之后研究源码的时候，采用如下的方法：<br><img src="/images/go/readSourceCode.png" alt="readSoucreCode"></p><p>3、每日有必要去读读大佬的观点、博客，这样才能站在前辈、巨人的肩膀上去思考问题！</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Test 的一个小坑</title>
    <link href="/2022/03/26/go/basic/go-test/"/>
    <url>/2022/03/26/go/basic/go-test/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用 TDD 的模式驱动自己编写测试驱动开后，使用goland 调试过程中出现的一些小问题，做一些记录</p></blockquote><h2 id="如何解决-undefined-function"><a href="#如何解决-undefined-function" class="headerlink" title="如何解决 undefined function"></a>如何解决 undefined function</h2><p>首先在确保自己的测试代码与主干代码在同一个软件包下。最合适办法采用命令行调试，但是如果是喜欢使用 goland 调试，那么在 go test 模板需要把目录改成软件包（如下图所示），或者是把目录下文件全部添加上（不建议）。</p><p><img src="/images/go/go-test.png" alt="markdown"></p><h2 id="Go-mod-init-packagename"><a href="#Go-mod-init-packagename" class="headerlink" title="Go mod init packagename"></a>Go mod init packagename</h2><p>接着上一个问题，goland 进行 go test 测试，很难用的原因，是因为自己在 go mod init 的时候，并未使用一个合理的名称，比如使用的 example，而在 function.go 中导入的包是 function name，导致 go mod 模式并未很好的利用，所以go mod name 建议与文件夹的包名一致，这样不容易出现错误。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go-test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TDD 概念介绍与学习课程</title>
    <link href="/2022/03/25/go/TDD/TDD-1/"/>
    <url>/2022/03/25/go/TDD/TDD-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在接触 TDD (测试驱动开发) 之后，发现自己的确很能认同测试驱动开发的理念。所以在加上极客时间中有徐昊老师新开的一门课程，所以就开始自己的 TDD 学习之陆</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先推荐两个课程：</p><p>1、徐昊老师的新课：<a href="https://time.geekbang.org/column/intro/100109401?tab=catalog">TDD 项目实战 70 讲</a>。</p><p>2、go 语言的教程：<a href="https://studygolang.gitbook.io/learn-go-with-tests/">Learn-go-with-test</a>，建议能尽量进行英文阅读，就阅读英文原版。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>1、郑烨老师的专栏《软件设计之美》</p><p>2、《测试驱动开发的艺术》</p><p>3、《代码整洁之道》与 《修改代码的艺术》</p><h2 id="上手训练"><a href="#上手训练" class="headerlink" title="上手训练"></a>上手训练</h2><p>可以查看博主推荐的 github 仓库，查看 TDD 具体的流程是怎么样进行的，以及 TDD 为什么能驱动程序员进行高效的开发！</p><blockquote><p>github: <a href="https://github.com/longyue0521/TDD-In-Go/commits/main">Alexdown 的 github 仓库</a></p></blockquote><p>下图是 alexdown 的评论，个人觉得能收获挺多</p><p><img src="/images/go/TDD1.png" alt="TDD1"></p><h2 id="5-月-21-日回看"><a href="#5-月-21-日回看" class="headerlink" title="5 月 21 日回看"></a>5 月 21 日回看</h2><p>TDD 的确重要，但是由于自己的工程能力并未到达老师所说的那种高度，所以说自己基础能力存在一定的问题，得需要一点的前置知识，比如看 uncle Bob 的 clean code 、软件工程上的知识，都是对自己的职业发展非常重要的！</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言中的 sync.Pool 学习</title>
    <link href="/2022/03/20/go/concurrency/Pool/"/>
    <url>/2022/03/20/go/concurrency/Pool/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本博客为在学习极客时间的 go 并发编程的学习笔记，具体详细内容请看极客时间官方的专栏–go 并发编程实战课</p></blockquote><p>Go 语言是自带垃圾回收机制的，具体演变过程可以看博主写的另一篇博客。所以我们不用像 C&#x2F;C++ 一样，创建对象的同时，使用完需要删除&#x2F;析构对象，防止因为空指针导致的内存泄漏。</p><p>但是 Garbage Collect 机制方便方便的同时，也带来的一定的性能隐患，比如 STW 机制仍然存在，我们大量在堆上创建的对象，会影响垃圾回收标记的时间。</p><p>所以在 Go 语言中，性能优化的方向一般是采用对象池的方式，把不用的对象回收起来，避免被垃圾回收掉。同样的，类似于数据库、TCP等长连接，也是保存在对象池中，可以大量减少业务的耗时！对应用程序整体性能也有一个提升。</p><h2 id="1、sync-Pool"><a href="#1、sync-Pool" class="headerlink" title="1、sync.Pool"></a>1、sync.Pool</h2><p>首先需要我们理解 sync.Pool 的两个概念</p><blockquote><p>sync.Pool 数据类型是：独立访问的临时对象，本身是<strong>线程安全</strong>的，能进行并发读取其中的对象！</p><p>sync.Pool 也是不能进行复制使用的！</p></blockquote><h2 id="2、sync-Pool-的使用方法"><a href="#2、sync-Pool-的使用方法" class="headerlink" title="2、sync.Pool 的使用方法"></a>2、sync.Pool 的使用方法</h2><p>sync.Pool 仅有三种方法：New()、Get()、Put()</p><h3 id="1、New"><a href="#1、New" class="headerlink" title="1、New()"></a>1、New()</h3><blockquote><p>sync.Pool 中的 New() 是 func() any 类型，其中 any 在源码中用 interface{} 表示。</p><p>New 方法的使用场景为：在调用 Pool 的 Get 方法并不能从池子中获取空闲元素后，就会创建新的元素</p></blockquote><h3 id="2、Get"><a href="#2、Get" class="headerlink" title="2、Get()"></a>2、Get()</h3><blockquote><p>调用此方法会将一个 Pool 中的一个元素取走，返回值可以为 nil 值，所以使用此方法需要对返回值进行判断。</p></blockquote><h3 id="3、Put"><a href="#3、Put" class="headerlink" title="3、Put()"></a>3、Put()</h3><blockquote><p>此方法用于将一个元素返回给 Pool, Pool 会将此元素保存在池中，而且可以复用，但是如果值是 nil，则 Pool 会忽略此值。</p></blockquote><h2 id="3、sync-Pool-的应用场景"><a href="#3、sync-Pool-的应用场景" class="headerlink" title="3、sync.Pool 的应用场景"></a>3、sync.Pool 的应用场景</h2><p>一般来说，很经典的场景即是 buffer 池，如 hugo 中的 bufpool，即可看到以下一段代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers := sync.Pool &#123;</span><br><span class="line">    New : <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> New(bytes.Buffer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBuffer</span><span class="params">()</span></span> *bytes.Buffer &#123;</span><br><span class="line">    <span class="keyword">return</span> buffers.Get.(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutBuffer</span><span class="params">()</span></span> (buf *bytes.Buffer) &#123;</span><br><span class="line">    buf.Reset()</span><br><span class="line">    buffers.Put(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然而在上述的代码，可能会导致内存泄漏的问题。</p><p>因为取出 bytes.Buffer 后，在使用时，我们通常会向此 buffer 中增加大量的 byte 数据，此时的 slice 容量可能会扩大到另一个量级的维度。</p><p>而此时我们在将其放入 Pool 中，slice 容量不改变的情况下，由于 Pool 回收的机制，这些大的 buffer 就不会被回收，而是一直留在 Pool 池中，占用着计算机的内存。</p><h2 id="4、sync-Pool-的实现"><a href="#4、sync-Pool-的实现" class="headerlink" title="4、sync.Pool 的实现"></a>4、sync.Pool 的实现</h2><p>Go 1.13 之前的版本实现的 sync.Pool 实现有两个问题：</p><blockquote><p>1、每次 GC 都会回收其中创建的对象；</p><p>2、底层实现采用了：mutex，而在之前的博客 mutex 学习中，可以知道，对 mutex 锁进行并发操作，在锁竞争相当激烈的情况下，会导致性能的急剧下降。</p></blockquote><p>所以 go 团队在 go 语言的1.13 版本的中，针对上述两个问题，做出了大量的优化(这也是 go 语言不建议我们在大量的并发中使用锁)。所以其中的一种优化方式就是 Pool 中不使用锁。</p><h2 id="好用的第三方-sync-Pool-库"><a href="#好用的第三方-sync-Pool-库" class="headerlink" title="好用的第三方 sync.Pool 库"></a>好用的第三方 sync.Pool 库</h2><p>1、<a href="https://github.com/valyala/bytebufferpool">bytebufferpool</a></p><blockquote><p>fasthttp 作者 valyala 提供的一个 buffer 池，基本功能和 sync.Pool 相同</p></blockquote><p>底层使用 sync.Pool 实现的，包括会检测最大的 buffer，超过最大尺寸的 buffer，就会被丢弃。</p><p>此官方的库提供了校准（calibrate，用来动态调整创建元素的权重）的机制，可以动态地调整 Pool 的 defaultSize 和 maxSize。</p><p>2、<a href="https://github.com/oxtoacart/bpool">oxtoacart&#x2F;bpool</a></p><p>3、<a href="https://github.com/fatih/pool">fatih&#x2F;pool</a></p><p><a href="https://time.geekbang.org/column/article/301716">更多详细的内容可以去大佬的课程中查看</a>，个人觉得是 Go 并发编程课程中，讲的最好，最值得深入研究的课程！</p><p>大部分的Work Pool 都是通过 channel 来缓存任务的，因为 channel 能很好的实现并发的保护，防止数据因为并发访问所造成的 data race！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如大佬所给的图：<br><img src="/images/go/pool2.png" alt="pool2"></p><blockquote><p>pool 是一个通用性的概念，用于解决对象重用与预先分配的一个尝用的优化手段，当然我自己还未曾使用过，但是类似数据库连接、HTTP 的 API 请求中已经封装使用了 Pool 了。</p></blockquote><p>如果在程序中 GC 耗时特别高，大量相同的类型的临时对象不断进行创建与销毁，可以考虑通过使用 sync.Pool 对其进行优化改良！</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sync</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 Redis 中间件</title>
    <link href="/2022/03/18/middleware/redis1/"/>
    <url>/2022/03/18/middleware/redis1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本博客主要是总结自己学习 Redis 中间件的经验，教程来源于<a href="https://www.bilibili.com/video/BV1S54y1R7SB">b站狂神说 java 的 redis 教程</a></p></blockquote><h2 id="1、Redis-概念"><a href="#1、Redis-概念" class="headerlink" title="1、Redis 概念"></a>1、Redis 概念</h2><p>1、Redis 是基于计算机内存的数据库，一般称为缓存数据库，由于没有固定的表结构与关系，也叫 NoSQL (Not Only SQL) 数据库。</p><p>2、为什么要使用 Redis：</p><ul><li>1、数据的爆发增长</li><li>2、没有固定关系的数据</li></ul><p>3、最新的版本中，官方不建议直接在 win 上使用操作 redis ，而是使用 WSL2 Linux 子系统进行 redis 的开发。</p><p>4、redis 常见使用场景</p><ul><li>1、内存缓存</li><li>2、不想使用 kafka，可以作为消息队列而存在</li><li>3、做电商的热点数据保存，因为可以设置 TTL。</li><li>4、朋友圈点赞</li><li>5、做秒杀的库存</li></ul><h2 id="2、Redis-bench-mark-test"><a href="#2、Redis-bench-mark-test" class="headerlink" title="2、Redis bench-mark test"></a>2、Redis bench-mark test</h2><p>使用官方自带的 redis-benchmark 工具进行压力测试，其中<br>-h ：host ，可以是本地，也能是远程进行压力测试<br>-p ：port，即端口号<br>-c ：connection，连接的熟练，基本上连接都是基于 tcp&#x2F;socket 的。<br>-n：跟时间复杂度与空间复杂度差不多，即指定每一个连接数的请求次数。</p><p><code>redis-benchmark  -h localhost -p 6379 -c 100 -n 10000</code></p><p>如果需要保存再一个日志文件中，也能使用 <code>redis-benchmark  -h localhost -p 6379 -c 100 -n 10000 &gt; redis.log</code> 命令</p><h2 id="3、Redis-基本知识说明"><a href="#3、Redis-基本知识说明" class="headerlink" title="3、Redis 基本知识说明"></a>3、Redis 基本知识说明</h2><p>redis 默认有 16 个数据库，默认是第 0 个数据库。</p><p>redis 的命令大小写不敏感，而其中的 key - value 大小写敏感。常见的命令有：</p><table><thead><tr><th align="left">命令</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">select</td><td align="left">切换数据库</td></tr><tr><td align="left">dbsize</td><td align="left">查看数据库大小</td></tr><tr><td align="left">flushdb</td><td align="left">清空当前数据库所有 K-V 值</td></tr><tr><td align="left">flushall</td><td align="left">清空 redis 数据库中所有 K-V 值</td></tr></tbody></table><p>redis 的限制跟 cpu 的性能无关，性能主要受制于硬件的内存与网络带宽。</p><h2 id="4、Redis-中五大基本类型"><a href="#4、Redis-中五大基本类型" class="headerlink" title="4、Redis 中五大基本类型"></a>4、Redis 中五大基本类型</h2><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>string 类型中常见的几种命令：</p><table><thead><tr><th align="left">命令</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">keys *</td><td align="left">查询所有的 key 值</td></tr><tr><td align="left">type key</td><td align="left">查看 key 的类型</td></tr><tr><td align="left">exist key</td><td align="left">是否存在 key</td></tr><tr><td align="left">append key value</td><td align="left">向 key 类型添加数据</td></tr><tr><td align="left">incr key</td><td align="left">key 的 value 原子性 + 1</td></tr><tr><td align="left">decr key</td><td align="left">key 的 value 原子性 - 1</td></tr><tr><td align="left">incrby key [numbers]</td><td align="left">key 的 value 原子性 + numbers</td></tr><tr><td align="left">decrby key [numbers]</td><td align="left">key 的 value 原子性 - numbers</td></tr><tr><td align="left">expire key [second]</td><td align="left">设置 key 的过期时间，默认是秒数</td></tr><tr><td align="left">getrange key start end</td><td align="left">取 key 的 value 从 start 到 end</td></tr><tr><td align="left">setrange key offset val</td><td align="left">设置 key 的 value 的 offset 位后替换为 val</td></tr><tr><td align="left">ttl key</td><td align="left">查看 key 剩余过期时间，默认是秒数</td></tr><tr><td align="left">setex key expire value</td><td align="left">设置 key value 以及过期时间 expire</td></tr><tr><td align="left">setnx key value</td><td align="left">如果 key 不存在，则设置 value，存在则设置失败（分布式锁使用，乐观锁）</td></tr><tr><td align="left">getset key value</td><td align="left">先得到 key 再设置 key value</td></tr></tbody></table><p>getset 命令有点类似于 CompareAndSwap 这种类型的值。</p><p>同理，还有 mset 、mget 为批量设置（非原子性），msetnx、msetex 等（原子性操作）</p><p>在 redis 中，如果要设计一种封装类型的对象，语法可以如下所示：</p><p>1、set user:1 {name:zhangsan, age : 18}</p><p>2、set user:1:name zhangsan user:1:age 18</p><p>string 常见的使用场景为：</p><ul><li>1、计数器</li><li>2、统计多单位的数量</li><li>3、粉丝数</li><li>4、对象缓存存储</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>List 类型中常见的几种命令：</p><table><thead><tr><th align="left">命令</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">keys *</td><td align="left">查询所有的 key 值</td></tr><tr><td align="left">lpush [listname] value</td><td align="left">将 value 插入 [listname] 队头</td></tr><tr><td align="left">lrange [listname] start end</td><td align="left">查看 [listname] 从队头的 start 到 end</td></tr><tr><td align="left">lpop [listname]</td><td align="left">将 [listname] 队头的元素移除</td></tr><tr><td align="left">lindex [listname] index</td><td align="left">从队头开始索引第 index 个值</td></tr><tr><td align="left">rpush [listname] value</td><td align="left">将 value 插入 [listname] 队尾</td></tr><tr><td align="left">rrange [listname] start end</td><td align="left">查看 [listname] 从队尾的 start 到 end</td></tr><tr><td align="left">rpop [listname]</td><td align="left">将 [listname] 队尾的元素移除</td></tr><tr><td align="left">rindex [listname] index</td><td align="left">从队尾开始索引第 index 个值</td></tr><tr><td align="left">llen [listname]</td><td align="left">查看 [listname] 长度</td></tr><tr><td align="left">lrem [listname] count value</td><td align="left">移除 [listname] 中 count 个值为 value 的值</td></tr><tr><td align="left">ltrim [listname] start end</td><td align="left">截断 [listname] 从 start 到 end</td></tr></tbody></table><p>List 底层实现就是一个双向链表，所以优点跟缺点都跟双向链表一样，具体可以学习相应数据结构的知识。程序员的内功还是 408 + 算法。</p><h3 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h3><p>set 集合类型，里面的值不重复。其中一般的命令就不写如上面的表格型的命令，这里直接举例了：</p><ul><li>1、sadd [setname] value ：向 [setname] 添加 value</li><li>2、spop [setname] value ：向 [setname] 删除 value</li><li>3、smembers  [setname] ：查看 [setname] 内所有值</li><li>4、sismember [setname]  value ：判断 value 是否存在 [setname] 中</li><li>5、srem [setname] value ：移除 [setname]  中的 value </li><li>6、srandmember [setname] count ：随机获取 [setname]  内一个值</li><li>7、smove source destination value ：将 value 从 source 移动到 destination 去</li><li>8、sdiff [setname1]  [setname2] ：[setname1] 与 [setname2] 的差集</li><li>9、sinter [setname1]  [setname2] ：[setname1] 与 [setname2] 的交集</li><li>10、sunion [setname1]  [setname2] ：[setname1] 与 [setname2] 的并集</li></ul><p>set 为一个无序、不重复集合。</p><h3 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h3><p>其实就是变为 key - map 结构，只是一个 map 集合。</p><blockquote><p>hash 类型的命令大同小异，只是在基本操作前加一个 h。</p><p>如 hget、hset、hgetall、hlen、hexists、hmset 等。</p><p>其中独有的特性即是： hkeys 与 hvals 是只获取 k 或 v ，以及 hincrby、hdecrby 、hsetnx、hsetex 等命令。</p></blockquote><p>虽然hash 与 string 很相似，但是从特点来看，hash 更适合存储结构体对象，string 更合适存储字符串类型。</p><h3 id="Zset-类型"><a href="#Zset-类型" class="headerlink" title="Zset 类型"></a>Zset 类型</h3><p>有序集合，set 基础之上增加了一个集合。常见命令也就是 zadd、zrange、zrangebyscore xxx -inf +inf (正负无穷的问题)、zcard(记个数)、zrem 删除、zcount 其中没有 ( 与 ) 即是闭区间，有 “( “ “)” 是开区间，比大小时候经常使用的方式如此。</p><p>zset 主要存储重要消息、带权重进行判断、排行榜的应用实现 Top N 测试。</p><p>当然更多的命令，可以前往 <a href="https://redis.io/commands/"> redis 的官网</a> 进行查询命令，以及我们使用 go 、java 、cpp 等语言做开发的时候。用 java 的jredis、go 的go-redis，使用看文档即可。</p><p>程序设计最重要的是设计，程序是基石，设计是上层建筑，所以我们需要尽量把握设计的思想、代码的实现，这是很有重要性的概念。</p><p>以上即是五大基本数据类型，还有三种特殊的数据类型</p><h2 id="5、Redis-中-三大特殊数据类型"><a href="#5、Redis-中-三大特殊数据类型" class="headerlink" title="5、Redis 中 三大特殊数据类型"></a>5、Redis 中 三大特殊数据类型</h2><h3 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h3><p> geospatial 在 redis 中 即是 geo，在 redis 3.x 版本就已经推出了，可以推算地理位置信息，两地之间的距离、方圆几里的人。</p><p>geo api 在现在的官网只有 9 个命令：geoadd、geopos、geodist、georadius。</p><p>其中 geo 的底层实现还是基于 zset，所以 zset 的命令都能操作 geo 数据结构。</p><p>如果不做地图地理信息的话，基本上项目内不会使用此数据类型</p><h3 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h3><p>hyperloglog 是基数统计的算法，用于网页的 UV 计数。</p><p>此数据结构占用内存非常小，只占用 $2^{64}$ B，即 12 KB 大小，所以从内存角度，Hyperloglog 是优先选择。</p><p>使用即是 pfadd、pfcount、pfmerge</p><h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p>位图，跟操作系统里面的一样，redis 里面可以统计用户信息：活跃、登陆、打开</p><p>操作为： setbit 、gerbit、bitcount</p><p>以上的数据结构了解使用即可，具体的原理，可以在工作中继续进行一个学习，现在我们主要学习其中的一个具体的场景即可。</p><h2 id="6、redis-中的事务"><a href="#6、redis-中的事务" class="headerlink" title="6、redis 中的事务"></a>6、redis 中的事务</h2><p><strong>在 Redis 中的单条命令保证原子性，而其事务是不保证原子性的！</strong> 事务的本质即是：一组命令的集合。事务具有一次性、顺序性、排他性。</p><p>redis 中的事务是没有隔离性的概念，没有隔离级别。</p><p>所有的命令在事务中没有被执行，必须发起执行命令时候，事务才能执行，即：exec 命令。</p><p>redis 事务执行方式：</p><ul><li>开启事务 (multi)</li><li>命令入队，返回值均为 queue </li><li>执行事务 (exec)</li></ul><p>事务也能放弃，命令即是：discard (即放弃事务队列里的所有命令)</p><p>以下两点异常需要注意</p><ul><li>1、编译型异常：代码错误、错误命令，redis 事务队列不会去执行。</li><li>2、运行时异常：如果事务队列中存在语法性，那么执行命令的时候，只放弃命令命令错误的那几条。</li><li>3、<strong>注意：错误命令与命令错误这两种说法的区别</strong></li></ul><h2 id="7、Redis-实现乐观锁"><a href="#7、Redis-实现乐观锁" class="headerlink" title="7、Redis 实现乐观锁"></a>7、Redis 实现乐观锁</h2><p>乐观锁：只会在更新数据的时候去判断一下，在此期间是否有修改过数据。</p><p>所以使用 watch 命令对 key 值进行监视即可。修改失败，用 unwatch 解锁，再 watch key，即可。</p><h2 id="8、Go-连接操作-Redis-数据库"><a href="#8、Go-连接操作-Redis-数据库" class="headerlink" title="8、Go 连接操作 Redis 数据库"></a>8、Go 连接操作 Redis 数据库</h2><h2 id="9、Redis-Conf-配置文件"><a href="#9、Redis-Conf-配置文件" class="headerlink" title="9、Redis.Conf 配置文件"></a>9、Redis.Conf 配置文件</h2><p>redis.conf 需要重点理解一下。</p><p>redis 大小写不敏感在配置文件中已经说明了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">daemonize  <span class="built_in">yes</span> <span class="comment"># 后台守护进程开启，默认为 no 。</span></span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 后台运行的 pid 值</span></span><br><span class="line"></span><br><span class="line">save 900 1 <span class="comment"># 快照 900s 内修改一个，就自动保存一次。</span></span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config get / <span class="built_in">set</span> requirepass  <span class="comment"># 设置 redis 的安全密码</span></span><br><span class="line"></span><br><span class="line">maxmemory-policy <span class="comment"># 内存到达上限的处理政策。一般以下 6 中处理方法</span></span><br><span class="line">1、volatile-lru : 直对设置了过期时间的 key 进行 lru </span><br><span class="line">2、allkeys-lru</span><br><span class="line">3、volatile-random 随机删除设置了过期时间的 key </span><br><span class="line">4、allkeys-lru</span><br><span class="line">5、volatile-ttl 删除即将过期的</span><br><span class="line">6、noeviction 永不过期，返回错误</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10、AOF-与-RDB"><a href="#10、AOF-与-RDB" class="headerlink" title="10、AOF 与 RDB"></a>10、AOF 与 RDB</h2><p>在大部分情况下，RDB 是默认的持久化配置，大部分的情况下都够用了。</p><p>一般进行数据持久化的保存操作过程一般分为五步：</p><blockquote><p>(1) 客户端向服务端发送写操作 (数据在客户端的内存中);</p><p>(2) 数据库服务端接收到写请求的数据 (数据在服务端的内存中);</p><p>(3) 服务端调用系统调用函数 write，将数据写入磁盘 (数据在系统内存的缓冲区中);</p><p>(4) 操作系统将缓冲区中的数据转移到磁盘控制器上 (数据在磁盘缓存中);</p><p>(5) 磁盘控制器将数据写到磁盘的物理介质中 (数据真正落到磁盘上);</p></blockquote><p>以上五个步骤为在理想条件下，一个正常的保存流程。但是在大多数情况下，我们的机器等等都会有各种各样的故障，这里划分了两种情况：</p><blockquote><p>1、Redis数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成;</p><p>2、操作系统发生故障，必须上面 5 步都完成才可保存。</p></blockquote><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB (Redis DataBase) 操作是<strong>在内存中的数据库记录定时dump到磁盘上的RDB持久化</strong>。这种方式是就是将内存中数据以快照的方式写入到二进制文件中, 默认的文件名为 dump.rdb，下列代码与图为 RDB 的存储字节流的内容格式。</p><p><img src="/images/SQL/RDB.jpg" alt="RDB"></p><p>在执行 RDB 快照备份时候，一般会通过父进程，fork 一个子进程，将数据写到一个临时文件，快照写完后，替换原来的快照文件，子进程就退出，临时文件变成正式的 RDB 文件。</p><p>但是 RDB 对数据的完整性不敏感，最后一次持久化之后的数据在宕机后可能丢失。</p><p>RDB 文件默认的保存文件名称为 dump.rdb</p><p>RDB 的触发条件如下：</p><p>1、满足默认的 save  条件，会触发 rdb 规则<br>2、执行 flushall，也会触发 rdb 规则<br>3、退出 redis，也会产生 rdb 文件</p><p>RDB 的恢复条件如下：</p><p>1、将 dump.rdb 文件放在redis 启动目录即可，redis 会自动检查其中的数据并恢复<br>2、查看需要存在的位置： redis-cli 中 config get dir 即可。</p><p>rdb 适合大规模的数据恢复，但是需要一定的时间间隔进程操作。</p><p>RDB 具体更详细的内容请看此博客： <a href="https://blog.csdn.net/damanchen/article/details/103326964">RDB文件格式</a></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF (Append Only File) ，记录服务器执行的 <strong>所有写操作</strong> 命令，类似于 Mysql 中的日志。在服务器启动时，通过重新执行 AOF 这些命令来还原数据集，相应的配置文件为 appendonly.aof，默认不开启，需要手动进行启动！</p><p>其他相应的配置可以查看 redis 的相应的conf 文件。比如 append async、auto-aof-rewrite-percentage、auto-aof-rewrite-min-size 等。</p><p>aof 文件大小大于 64mb 后就会产生重写的操作。 </p><p>当 aof 文件出现问题时，需要使用 <code>redis-check-aof --fix</code> 工具对 aof 文件进行修复。</p><p>aof 同步设置：</p><ul><li>1、每一次修改都会同步，文件的完整性会更好；</li><li>2、每 1s 同步一次，那么可能会丢失 1s 的数据；</li><li>3、不同步效率是最高的。</li></ul><p>对比 aof 与 rdb，aof 是文件读写流操作，所以运行效率比rdb低，数据文件也比rdb大，修复数据的速度也比 rdb 慢。</p><p>Redis 还可以<strong>同时使用 AOF 持久化和 RDB 持久化</strong>。</p><p>在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p><h2 id="Redis-发布与订阅"><a href="#Redis-发布与订阅" class="headerlink" title="Redis 发布与订阅"></a>Redis 发布与订阅</h2><p>发布订阅 ( pub &#x2F; sub ) 是一种消息通信的模型，发送者发送消息，接收者接受消息。一般此模型涉及三种对象：</p><blockquote><p>1、消息发送者</p><p>2、频道</p><p>3、消息订阅者</p></blockquote><p>模型的视图如下：</p><p><img src="/images/middleware/redis-pub-sub.png" alt="redis-pub-sub"></p><p>redis 的客户端可以订阅任意数量的频道，其相应的操作文档可以参考前文的 redis 官方文档，本博客只是介绍相应 redis pub &#x2F; sub 模型的概念与原理。</p><h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h2><p>只要在企业中， Redis 集群是必用的，其架构通常为主从模式，一个主节点有多个从节点，一个从节点只有一个主节点。</p><p><strong>主从复制的作用如下所示：</strong></p><ul><li>1、数据冗余：主从复制是可以热备份的，是区别于 redis 持久化的另外一种数据冗余的方式</li><li>2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现故障的快速恢复，也能称为服务冗余</li><li>3、负载均衡：主从架构主要是一种多读少写型的架构模式，通过多个 redis 服务器分担读的负载，可以大大提升 redis 服务器的并发量。</li><li>4、高可用的基石：主从复制是哨兵和集群能实施的基础，所以说是基石。</li></ul><blockquote><p>一般来说，单体 redis 服务器一旦发生单点故障，那么很有可能会丢失至少 1s 以上的数据，并且单体redis 需要处理所有的请求负载，压力较大。</p><p>而且，单体 redis 由于服务器的内存有限，不可能让服务器内存全部交给 redis 进行数据存储。单台 redis 内存占用不应超过 20GB 。</p></blockquote><p><code>info replication</code> 表示查看当前的 redis 服务器的角色信息</p><p>实现 redis 集群模式只需要修改三个配置属性即可，然后使用 redis 启动此三个配置即可：</p><ul><li>1、端口</li><li>2、pid</li><li>3、log 文件名</li></ul><p>配置从机时候，使用 <code>slaveof + host + port</code>  即可配置主从形式，但是一旦此redis 重启后，配置文件重置，若需要配置持久化的配置文件，需要手动设置 redis.conf 配置文件。具体可看 redis 的详细配置文件。</p><p>主从复制一般两种形式：全量复制与增量复制。其中，但凡从机只要是重新连接主机，都会发生一次全量复制。</p><hr><p>本篇博客主要介绍相应的使用方法，浅谈一下原理，新开一个博客，用于自己对 redis 的底层源码与原理进行进一步的深入理解。</p>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源的思考</title>
    <link href="/2022/03/16/go/interview/opensouce/"/>
    <url>/2022/03/16/go/interview/opensouce/</url>
    
    <content type="html"><![CDATA[<p>本人是曾经的职业规划是，在读研后学习 NLP、CV 等领域的算法论文，而后向着算法工程师的方向进行努力。而近几年的考研难度以及行业的形式导致自己的期待与期望成了泡沫：</p><h3 id="1、不读-985-211，算法工程师基本做不了"><a href="#1、不读-985-211，算法工程师基本做不了" class="headerlink" title="1、不读 985&#x2F;211，算法工程师基本做不了"></a><strong>1、不读 985&#x2F;211，算法工程师基本做不了</strong></h3><h3 id="2、考研热门程度异常火爆，为什么考研的想法越来越困扰自己"><a href="#2、考研热门程度异常火爆，为什么考研的想法越来越困扰自己" class="headerlink" title="2、考研热门程度异常火爆，为什么考研的想法越来越困扰自己"></a><strong>2、考研热门程度异常火爆，为什么考研的想法越来越困扰自己</strong></h3><p>所以说，在二战也未能达到名校的分数线后，自己毅然决定，不调剂，投入社会进行学习与工作。</p><p>但是困扰自己的问题出现了，学习什么样的技术、向什么样的行业发展，成为自己的一大困惑。通过一段时间的自我认知与自我反省，想到了自己曾经大三时候学习的 go 语言，并且使用 beego 框架进行相应的简易博客开发，所以方向是 go 语言工程师，go 语言中的几个方向：云原生、微服务、高性能 API、服务器端开发、游戏开发。自己这几个方向都还是比较喜欢的，更坚定了自己使用 go 语言进行找工作的决心。</p><p>而在今天看到对于<a href="https://blog.csdn.net/csdnnews/article/details/110508201">云原生社区对 APISIX 的联合创始人&amp;CEO 温铭做的采访</a>，虽然已经过去了一年多的时间，但是其中几个观点，我也是非常认可其中的理念：</p><blockquote><p>1、开源比业务代码更有意义</p><p>2、开源的本质是要拿开发者的杠杆</p><p>3、Apache 的理念是社区比代码更重要</p></blockquote><p>更具体的一些话语可以查看相应的采访博客。</p><p>自己的确非常喜欢开源社区，也十分认同开源的理念，就是能让自己的智慧以及不断发展的能力，给开源社区做出贡献。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>open-source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 年 11 周总结</title>
    <link href="/2022/03/14/summary/22-3-14/"/>
    <url>/2022/03/14/summary/22-3-14/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上一周没怎么写博客，第一个就是上一周杂事比较多，理论方向的学习少；第二就是跟大佬交流，发现自己存在找原因性的思维方式，需要转变自己的思维。因此，一段时间写一次总结性的博客是很有必要的。</p></blockquote><h2 id="1、关于求职"><a href="#1、关于求职" class="headerlink" title="1、关于求职"></a>1、关于求职</h2><p>首先，大佬提醒我，<strong>要建立模板化、模块化的求职思路，如面试之前需要搜集相关的资料，主要关注以下四点：</strong></p><ul><li>1、公司的名称</li><li>2、公司的<strong>核心产品</strong></li><li>3、公司的产品的主要<strong>受众人群</strong></li><li>4、公司招聘的<strong>岗位职责、经营状况、真实业务需求</strong></li></ul><p>​ 在新入职场的初期，可以考虑多往几个方向去投简历，我希望<strong>未来 3-5 年从事 Go 语言的工程师岗位</strong>，而在 Go 语言的发展方向中，以下四种发展方向是我最希望发展的：<strong>云中件、微服务、高性能 API、游戏后端服务器开发</strong>。</p><p>​ 而后再从大厂、中小厂、创业公司去搜集岗位信息以及岗位所对应的产品团队等，在以上四种方向中选公司进行投简历，这样才能了解公司需求，掌握足够多的信息的情况下拿到岗位的 offer 。</p><h2 id="2、关于自身的成长"><a href="#2、关于自身的成长" class="headerlink" title="2、关于自身的成长"></a>2、关于自身的成长</h2><p>首先，能进公司再对公司的业务进行钻研是最能迅速提升的方式，前提是得先进去。</p><p>那么进不去公司的业务如何进行一个迅速的提升呢，一般像我们通过自学提升，流程先是看视频 -&gt; 看书 - &gt; 实践。而看视频只是跟随别人的思路来写项目，虽然能快速浏览项目，但项目的设计、自己的对项目的把握能力都不够，包括看书也如此。</p><p>查看岗位的职责与需要掌握相应的基础技能，如下：</p><blockquote><p>1、计算机或相关专业毕业,本科及以上学历,熟悉 TCP&#x2F;IP、HTTP 等协议，有扎实的网络、存储、安全、计算机体系结构方面的知识,精通 Linux 操作系统,精通 C&#x2F;C++&#x2F;Python&#x2F;Go 任意一门语言，熟悉 shell 脚本</p><p>2、熟练掌握 MySQL 数据库，熟悉 MySQL 使用及基础优化，熟悉主流的非关系型数据库、缓存技术 (Redis、Memcached 等)</p><p>3、有监控、CI&#x2F;CD、DEVOPS 相关工作经验者优先,有的 Hadoop&#x2F;Spark&#x2F;Flink&#x2F;TBase 的实际项目使用者优先。</p><p>4、有责任心,良好的沟通协调能力及团队协作精神，善于学习、分析、思考。</p></blockquote><p>那么根据我自己而言，Go、Linux、网络、计算机体系结构相应的知识只需要每日多复习即可，自己的缺陷在数据库 (MySQL、MongoDB、Redis)、监控、CI&#x2F;CD、DevOps上。</p><p>可以从数据库进行实践，先熟悉一遍执行流程，再思考业务需要这些来做什么样的事情，达成了什么样的效果，效果能不能继续提升(调整优化等)，之后再看看别人对数据库、DevOps、K8S 的思考。也就达到了暂时性的提升效果。至于阶段性的成长，就需要自己对自己所掌握的知识库进行总结与输出了，比如写博客，做演讲等。</p><h2 id="3、目前的任务"><a href="#3、目前的任务" class="headerlink" title="3、目前的任务"></a>3、目前的任务</h2><ul><li><p>1、3月14日 - 3月27日，接下来的两周的计划，在做云中间、游戏开发、微服务、高性能 API 的公司先调研公司的产品、经营状况，而后在每个分支方向选大厂、中小厂、创业公司分别投简历，能进入面试后，再根据自己面试得到的信息，决定具体的发展方向。</p></li><li><p>2、建立思维导图的时间轴，了解公司的业务背景 -&gt; 投简历的时间 -&gt; 一面的时间 -&gt; 二面的时间 -&gt; 三面的时间，对时间需要一定的敏感程度。</p></li><li><p>3、首先要对自己定位，自己是缺乏工作经验的往届生，如果能通过简历筛选关，证明公司注重的是自己的个人修养。需要更好的展现自己曾经做过事，扎实自己作为技术人员的基础。</p></li><li><p>4、个人表述要加强，面试的语速需要清晰，有节奏、谈吐有轻重。同时再回答相应的专业问题时，需要像自己之前写 TCP-IP 协议一样，理清楚自己的思路，总结成模板，形成自己的模板库。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言中的 sync.Mutex 学习</title>
    <link href="/2022/03/06/go/concurrency/mutex/"/>
    <url>/2022/03/06/go/concurrency/mutex/</url>
    
    <content type="html"><![CDATA[<blockquote><p>极客时间专栏，鸟窝大佬的 Go 并发编程课程，由于大佬的课程十分精彩，领悟需要时间与精力！所以再次本文仅仅只能作为知识总结，相应具体内容与源码分析请去极客时间上购买大佬相应的课程！</p></blockquote><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>​ Go 语言中的 sync 包的 mutex 的设计，有四个演变阶段。</p><ul><li>1、初版的 Mutex 采用一个 flag 表示锁是否被持有，实现比较简单</li><li>2、之后为了照顾新来的 Goroutine(下文简称 G )，会让新人能够尽可能的优先获取锁，此为第二个阶段</li><li>3、第三个阶段呢，是使被唤醒的 G 与新来的 G 有更多的机会竞争锁，但是这样会引发相应的饥饿问题，所以目前又加入了饥饿的解决方案</li><li>4、第四个即为解决饥饿的阶段。</li></ul><p>如下图所示</p><p><img src="/images/go/mutex1.png" alt="go-concurrency1"></p><h3 id="初版-mutex-的实现"><a href="#初版-mutex-的实现" class="headerlink" title="初版 mutex 的实现"></a>初版 mutex 的实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2008</span> 年时候， Russ Cox 提交的第一版的 mutex 如下所示</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAS 操作，当时并未抽象出 atomic 原子包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(val *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire</span><span class="params">(*<span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease</span><span class="params">(*<span class="type">int32</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//锁是否被持有</span></span><br><span class="line">    key <span class="type">int32</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//信号量专用，用于阻塞/唤醒 G </span></span><br><span class="line">    sema <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证成功在 val 上添加 delta 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xadd</span><span class="params">(val *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := *val</span><br><span class="line">        <span class="keyword">if</span> cas(val, v, v + delta) &#123;</span><br><span class="line">            <span class="keyword">return</span> v + delta</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">1</span>) == <span class="number">1</span> &#123; <span class="comment">// 标识加 1，如果为 1，则获取到锁</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    semacquire(&amp;m.sema) <span class="comment">//否则阻塞等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">-1</span>) == <span class="number">0</span> &#123;<span class="comment">// 标识减 1，如果为 0，则没有其他的等待者</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    semarelease(&amp;m.sema) <span class="comment">//唤醒其他的 G     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>· 其中，CAS 为一种指令，即将给定的值与内存地址中的值进行相比较，如果是同一个值，就用新值替换内存地址中的旧值。而且 CAS 操作指令是原子性的指令(即数据库中原子性的概念，修改不了数据，事务回滚到修改之前的数据，数据不改变)</p><p><img src="/images/go/mutex2.png%22"></p><blockquote><p>有趣的事情是，Unlock 方法能被任意的 G 调用释放，即使没有持有互斥锁的 G，也能进行相应的操作。</p></blockquote><p>所以在使用 Mutex 的时候，必须保证 G 尽可能不去释放自己未持有的锁，一定遵循 “谁申请，谁释放” 的原则。一般在使用 Mutex 的时候，Lock 与 Unlock 方法都应该在一个方法内成对出现。</p><blockquote><p>在1.14版本中 Go 对 defer 做了相应的优化，采取更有效的内联模式，将之前生成的 defer 对象放入 defer chain 中，所以 defer 对程序执行的影响微乎其微了。</p></blockquote><p>缺点：请求锁时候，G 会排队等待获取互斥锁，虽然看起来挺公平的，但是从性能上来看，并非最优的解法。如果能将锁让给正在用 CPU 时间片的 G 的话，就不需要做上下文的切换，在高并发的情况下，可能会有更好的性能。</p><h3 id="“给新人机会”-阶段"><a href="#“给新人机会”-阶段" class="headerlink" title="“给新人机会” 阶段"></a>“给新人机会” 阶段</h3><p>2011 年 6 月 30 日，Go 语言开发者在 commit 中对 Mutex 做了一次大调整，调整后的 Mutex 实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLock = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">//mutex is locked </span></span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中 Mutex 此版本的设计思想为将第一个 int32 类型的 state 字段，划算为二进制，按二进制的位数进行区分，如下图：</p><p><img src="/images/go/mutex3.png"></p><p>这样可能以最小的内存来实现互斥锁结构，最低位表示锁是否被占有(1|0 占有|非占有)，次低位表示锁是否有被唤醒的 G，其余 30 位表示等待此锁的 G 的数量。与计算机网络的子网划分很相似的设计，一个数值，分为三部分，代表三个意义。</p><p>并且因为 atomic 原子性包的添加，请求锁Lock也变复杂了，。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">//Fast path : 幸运 case，能够直接获取到相应的锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := m.state</span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">//新状态加锁</span></span><br><span class="line">        <span class="keyword">if</span> old &amp; mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">//等待者数量加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="comment">//G 是被唤醒的</span></span><br><span class="line">            <span class="comment">//新状态清除唤醒标志</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^ = mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;<span class="comment">//设置新状态</span></span><br><span class="line">            <span class="keyword">if</span> old &amp; mutexUnlocked == <span class="number">0</span> &#123; <span class="comment">//锁原状态未加锁</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime.Semacquire(&amp;m.sema) <span class="comment">//请求信号量</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">设计包含大量的位运算，要联系 Go 语言的位运算优先级进行思考。</span><br></pre></td></tr></table></figure><h2 id="使用-mutex-的一些注意事项"><a href="#使用-mutex-的一些注意事项" class="headerlink" title="使用 mutex 的一些注意事项"></a>使用 mutex 的一些注意事项</h2><p>1、能不用 mutex, 尽量不用 mutex, 使用读写锁合适</p><p>2、尽量使用 defer 释放锁，防止因为 panic 而导致锁未释放</p><p>3、mutex.Lock() 后是不可重入的，写递归时候，不能调用 mutex</p><p>4、尽量使用读写锁！sync.RLock&#x2F;RUnlock, sync.WLock&#x2F;WUnlock</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sync</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】未来学习计划</title>
    <link href="/2022/03/05/plan/"/>
    <url>/2022/03/05/plan/</url>
    
    <content type="html"><![CDATA[<blockquote><p>已经掌握的知识，必须要及时进行复盘与总结，并且进行文字化的输出!</p><p>这样许多的问题就能刻入自己的骨髓，不会轻易忘记！</p></blockquote><h2 id="Go-学习前言"><a href="#Go-学习前言" class="headerlink" title="Go 学习前言"></a>Go 学习前言</h2><p>Go 语言的应用场景有许多，但是语言主要的优势在以下三大块:</p><blockquote><p>1、云原生 (微服务 + DevOps + PaaS 等中间件) </p><p>2、高性能 API</p><p>3、服务器端开发</p></blockquote><p>如果职业方向是往以上几个方向发展，那么 Go 语言的学习是至关重要的，市场上初步的任职要求如下：</p><blockquote><p>编程语言:  使用 Go 独立实现一套完整的 Web 服务器</p><p>基础知识:  操作系统 &#x2F; 网络编程 &#x2F; 数据结构与算法等</p><p>常见中间件:  MySQL &#x2F; Redis &#x2F; Kafka &#x2F; Nginx等</p><p>软技能:  学习 &#x2F; 沟通 &#x2F; 抗压 &#x2F; 解决问题的能力</p></blockquote><p>而本博客，主要为梳理 Go 语言需要掌握知识的细节，以及作为一个刚入行的 Go 新人，需要积累的知识。</p><h3 id="1、目前掌握的相关知识"><a href="#1、目前掌握的相关知识" class="headerlink" title="1、目前掌握的相关知识"></a>1、目前掌握的相关知识</h3><ul><li><p>1、Go 基础: 关键字、常量、变量、数据类型、数据结构、流程控制、函数、方法、协程、通道。</p></li><li><p>2、GMP 模型基础: 包括早期的 GM 模型，以及后期的 GMP 模式设计方法、调度机制等</p></li><li><p>3、GC 基础: 包括标志清除法、三色标记法、插入写屏障、删除写屏障、混合写屏障。</p></li><li><p>4、go 语言一些常用包：net&#x2F;http、sync 等</p></li></ul><h3 id="2、目前的学习计划"><a href="#2、目前的学习计划" class="headerlink" title="2、目前的学习计划"></a>2、目前的学习计划</h3><ul><li><p>1、Go 语言并发编程(鸟窝大佬的极客时间专栏，常见的并发原语：Mutex、RWmutex、Once、Map、WaitGroup、channel 等)</p></li><li><p>2、Go 内存逃逸、GC 的优化问题、熟练使用 go trace(查频繁的 GC)、pprof(内存泄漏、CPU 过高、程序慢、锁竞争、程序阻塞)。</p></li><li><p>3、Go 技术栈常用的组件： <a href="https://github.com/grpc/grpc">grpc</a>、<a href="https://github.com/protocolbuffers/protobuf">protobuf</a>、<a href="https://github.com/prometheus/prometheus">Prometheus</a>、<a href="https://github.com/istio/istio">istio</a> 等</p></li><li><p>4、学习云原生开源组织的相应的技术分享。</p></li></ul><h3 id="3、Go-服务器开发自我总结"><a href="#3、Go-服务器开发自我总结" class="headerlink" title="3、Go 服务器开发自我总结"></a>3、Go 服务器开发自我总结</h3><h4 id="1、工具"><a href="#1、工具" class="headerlink" title="1、工具"></a>1、工具</h4><p>1）语言：Go, SQL, JS;</p><p>2）IDE：Goland、VScode;</p><p>3）版本管理工具：Git、SVN（游戏场景使用）;</p><p>4）依赖管理：go mod;</p><h4 id="2、生态"><a href="#2、生态" class="headerlink" title="2、生态"></a>2、生态</h4><p>1）消息队列：kafka、RocketMQ;</p><p>2）存储：MySQL、Redis、Mongodb、PostgreSQL;</p><p>3）web 框架：gin、goframe 等；</p><p>4）微服务：go-zero、go-mirco、go-kit 等（微服务架构上基本上是做的集成，市场上关于微服务完整的银弹方法几乎不存在）</p><h4 id="3、容器"><a href="#3、容器" class="headerlink" title="3、容器"></a>3、容器</h4><p>1）Swarm (docker);</p><p>2）K8S (基本一统江湖);</p><h4 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h4><p>1）通识的 Go 语言原理：GC、GMP、runtime 等;</p><p>2）中间件的原理：主要看业务需要。</p><h3 id="4、学习方式"><a href="#4、学习方式" class="headerlink" title="4、学习方式"></a>4、学习方式</h3><p>主要推荐我旁边的推荐博客：</p><p>1、基础推荐七米老师的博客</p><p>2、进阶可以看极客兔兔的博客、鸟窝大佬的博客。</p><p>3、追求硬核理解的可以看面向信仰编程作者的博客！</p><h3 id="5、技术写作规范"><a href="#5、技术写作规范" class="headerlink" title="5、技术写作规范"></a>5、技术写作规范</h3><p>详细参考<a href="https://github.com/chaggle/document-style-guide">阮一峰的写作规范</a>，个人觉得让他人拥有良好的阅读体验也是软技能之一！</p><h3 id="6、晋升分解法"><a href="#6、晋升分解法" class="headerlink" title="6、晋升分解法"></a>6、晋升分解法</h3><p>1、目前自己定级 P5（工作 1 ~ 3 年）需要别人带领自己达成任务（已于2023年达成升职）</p><p>2、下一级 P6 (工作 3 ~ 5 年) 能独立完成任务（已达到此层级，未来目标 p7）</p><p>3、需要专项提升某一项技能的能力，资深技术专家建议：持续花 6 个月时间进行专项提升。</p><p>4、比如现在主要提升 Mysql 与 PostgreSQL、Redis 与 Memcache 的技术水平。计划大致如下：</p><p>5、Mysql 与 PostgreSQL</p><blockquote><p>1、1.5 个月：（已经完毕！）学完 <a href="https://www.bilibili.com/video/BV1es411u7we">bilibili SQL进阶课程</a>、通读 High Performance Mysql。</p><p>2、3 个月：<a href="https://github.com/digoal/blog/blob/master/README.md">github 大神的 PostgreSQL 修炼手册学习</a></p><p>3、1.5 个月：实战 Mysql 与 PostgreSQL</p></blockquote><p>6、Redis 与 Memcache </p><blockquote><p>1、1.5 个月：（已经学完！）学完 <a href="https://www.bilibili.com/video/BV1S54y1R7SB">bilibili redis 基础 + 进阶课程</a>，建立一个完备的 redis 知识体系</p><p>2、3 个月：通读+学好 Redis设计与实现 （蓝书）</p><p>3、1.5 个月：实战 Redis</p></blockquote><p>7、除此之后，TDD 学习要进行 Java 的学习，除此之外，就是多用 Go + Python 语言，课程 <a href="https://coding.imooc.com/class/469.html">Go + Python 双语言开发</a> 也很好。</p><hr><h2 id="Java-学习前言"><a href="#Java-学习前言" class="headerlink" title="Java 学习前言"></a>Java 学习前言</h2><blockquote><p>因为工作后需要，开始转变方向为 Java，但是 go 的学习也不会停止！</p></blockquote><p>转方向为 Java 后，所需要学习的业务中间件远超 go 语言，相应的框架也是如此，不过 Java 技术栈更新也不会太快。</p><p>经历一段时间的工作后，自己的人生状态也发生相应的改变，首先需要将自己的业务技能锻炼强。业务能力不等于技术能力，比如业务流程、沟通流程，比纯粹技术性的学习要强很多！</p><h3 id="1、Java-基础"><a href="#1、Java-基础" class="headerlink" title="1、Java 基础"></a>1、Java 基础</h3><p>Java 基础不是语言类的基础，本次的 Java 基础主要是为了跟 SpringCloud 做区分，比如 JUC 、Spring、Mybatis、SpringMVC、SpringBoot 都是属于 Java 基础，因为这样的东西才构成了 Java 整个语言的生态体系，叫做基础。</p><p>而且 408 中有三门课程也是属于 Java 基础：数据结构、操作系统、计算机网络。</p><h3 id="2、Java-企业级开发框架"><a href="#2、Java-企业级开发框架" class="headerlink" title="2、Java 企业级开发框架"></a>2、Java 企业级开发框架</h3><p>首先肯定是 Java 基础，之后就是上框架 SpringBoot、 SpringCloud 组成的单体与微服务的架构，中小型公司基本上以此两种框架为主流。<br>当然也有 solon 等国产化的后起之秀，但是在技术选型上需要进行权衡，比如人员的学习成本、后续排查问题的成本，如使用的话需要考虑好。<br>而后需要进行理解的就是框架中使用的技术组件：jpa、mybatis、</p><p>此处也推荐 Java 社区中比较活跃的脚手架</p><ul><li>1、ruoyi-vue 脚手架，最经典的脚手架，会教会很多技术组件的使用、业务相关的理解：如权限管理、多数据源、定时任务、代码生成器等。</li><li>2、yudao-boot 脚手架，基于 ruoyi-vue 脚手架进行二次开发，会进一步理解好的企业级脚手架是如何建立，集成度较高，适合快速进行业务开发与使用。</li></ul><h3 id="3、基础设施中的中间件"><a href="#3、基础设施中的中间件" class="headerlink" title="3、基础设施中的中间件"></a>3、基础设施中的中间件</h3><p>1、负载均衡中间件：Nginx、Nacos、ApiSix、Kong、Envoy 等<br>2、数据库中间件：Mysql、PostgreSQL、Sqlite、MongoDB、TiDB、OceanBase、ElasticSearch<br>3、缓存中间件：Redis、Memcache、Tair、Codis<br>4、消息中间件：RocketMQ、Kafaka、RabbitMQ </p><p>精通与熟练都是需要时间进行打磨，高级程序员、架构师的要求也是不仅局限于使用的层次，到底层技术细节实现的理解也一直比较重要，技术能力的提升与理解都是在不断的学习中进行的，也如大厂晋升指南中体现：</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go 学习方向</title>
    <link href="/2022/03/04/go/interview/direction/"/>
    <url>/2022/03/04/go/interview/direction/</url>
    
    <content type="html"><![CDATA[<blockquote><p>通过几次面试，来总结一些现在阶段，对于自己的职业规划的发展与思考！</p></blockquote><p>​ 经历了三四次面试，收获挺大的。面试不是目的，只是一种过程，要在不断的面试中，找到适合自己发展的领域才是面试的目的！</p><h2 id="1、现阶段发展的方向"><a href="#1、现阶段发展的方向" class="headerlink" title="1、现阶段发展的方向"></a>1、现阶段发展的方向</h2><p>​ 首先，Go 语言的云原生跟云中件发展是非常迅速的，而且 Go 语言社区中，讨论最多的也是云计算的发展，docker、K8S集群、普罗米修斯，都是云中件的代表，所以去学习其中设计的思想、源码的思想是非常重要的！</p><h2 id="2、Go-面试"><a href="#2、Go-面试" class="headerlink" title="2、Go 面试"></a>2、Go 面试</h2><blockquote><p>总结一下面试的问题：</p><p>1、数组与链表的区别（数据结构基础知识）</p><p>2、进程、线程、协程有什么区别 （操作系统的知识，加 Go 语言特有的协程）</p><p>3、Redis 与 MYSQL 熟悉吗，Redis 有哪几种数据结构，缓存过期（TTL 网络中的生存时间），Redis 一般使用在哪一些场景里面（针对热点数据进行缓存、限时数据缓存、热点权值数据进行缓存）</p><p>4、channel 有几种类型(自己回答是读、写、读写三种，不一定对，也可能chan int、string、byte)</p><p>5、控制 Goroutine 数量的几种方式(channel 控制，sync.WaitGroup 控制)</p><p>6、Go 语言调度模型：GMP 模型（hand off 机制没回答特别好）</p><p>7、Go 语言的 GC (标记清除法、三色标记法、混合写屏障机制)</p><p>8、Go GC 在什么时候会导致 GC 效率不高（STW 次数多的时候效率不高，毕竟依赖于 STW 机制）</p><p>9、TCP 的 CLOSE_WAIT 状态出现在那一步</p><p>10、slice 与 map 底层源码 (slice 底层为指针 Array 类型，Go 中的 map 是 slice + list 数组加链表，而 java 里面是最简单的是 数组, 规模达到一定程度转换为数组 + 链表或数组 + 红黑树的形式)</p><p>11、Go 语言的内存泄漏、内存逃逸问题 (内存逃逸就是栈上开辟空间存放的变量，逃逸到堆上去了，内存泄漏主要是看 OS 的环境, Linux 下使用 top&#x2F;htop)</p><p>12、几道 Go 语言面试的题目：闭包传参、向空 slice append 数等</p><p>13、Go 语言如何 debug (自己回答是 采用单元测试的办法、pprof 等方式方法)</p><p>14、算法题目：三数之和，返回二维数组，二维数组内不能有重复值，即数组内元素相等</p></blockquote><h2 id="3、5-月-21-日温故而知新"><a href="#3、5-月-21-日温故而知新" class="headerlink" title="3、5 月 21 日温故而知新"></a>3、5 月 21 日温故而知新</h2><blockquote><p>1、Go 语言中协程出现了panic 的情况，有什么样的机制保证协程恢复并继续执行下去？</p><p>2、Go 语言中的调试信息使用什么查看？</p><p>3、Go 语言中的内存模型与内存回收机制</p><p>4、Go 与 Python 语言的协程对比有什么区别</p><p>5、<strong>Mysql 里面执行计划的概念</strong>(之前复盘都没有听出来这个问题，一个劲在说不知道)</p><p>6、redo-log、undo-log、bin-log 三个 log 文件的作用与区别，如何使用 redo 与 bin 两种日志去保证数据的一致性？</p><p>7、<strong>数据库出现过性能问题嘛，千万级数据量的表如何进行一个排查+ 处理</strong></p><p>8、grom 操作数据库是如何操作的 ？</p><p>9、<strong>redis 中 AOF 与 RDB 两种快照日志主要是为了解决什么样的问题？</strong></p><p>10、gin 框架的源码看过吗，里面路由具体的实现机制是怎样的</p><p>11、平时关注那样一些开源技术？</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Direction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 垃圾回收机制</title>
    <link href="/2022/03/01/go/basic/GC/"/>
    <url>/2022/03/01/go/basic/GC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习 Go 语言中的各个版本的垃圾回收的机制。</p></blockquote><h2 id="1、Go-V1-3-版本之前的标记清除-mark-and-sweep"><a href="#1、Go-V1-3-版本之前的标记清除-mark-and-sweep" class="headerlink" title="1、Go V1.3 版本之前的标记清除(mark and sweep)"></a>1、Go V1.3 版本之前的标记清除(mark and sweep)</h2><p>此版本的垃圾回收机制，一般分为以下四步：</p><blockquote><p>1、暂停程序业务逻辑，找出不可达的对象以及可达的对象</p><p>2、开始标记，程序找出其所有可达的对象，并进行标记</p><p>3、标记完之后，开始清除未标记的对象</p><p>4、继续运行程序。循环以上的过程，知道程序的生命周期终止为止</p></blockquote><p>但是相应的，V1.3 版本中的垃圾回收的问题也较大：</p><p>首先有个 STW 暂停程序，这会浪费大量的时间去处理垃圾回收，不利于效率的提升，其次每一次的标记需要扫描整个 Heap 堆区，而且清除相关的数据也会产生内存堆的碎片。</p><h2 id="2、Go-v1-5-版本的三色标记法"><a href="#2、Go-v1-5-版本的三色标记法" class="headerlink" title="2、Go v1.5 版本的三色标记法"></a>2、Go v1.5 版本的三色标记法</h2><p>此时，垃圾回收机制将运行中的程序状态分为：白、黑、灰三种状态</p><blockquote><p>1、每一步默认创建的对象均标记均为”白色”</p><p>2、每一次 GC 回收的时候，均会从根节点遍历所有的对象，而且把遍历的对象从白色的集合放入”灰色” 的集合中，遍历为非递归形式。</p><p>3、遍历灰色的集合，将灰色对象引用的对象从白色集合中放入灰色集合，然后将灰色对象放入黑色集合中。</p><p>4、重复第三步，直到灰色集合中中无任何对象。</p><p>5、回收所有白色集合中的对象，即回收垃圾。</p></blockquote><p>但是此处有两个问题:</p><ul><li><p>1、如果黑色对象后之间引用指向一个白色的对象，那么在第二步的时候，此白色对象并不能进行相应的染色，所以说此处会导致白色对象被清除！</p></li><li><p>2、如果之前白色对象被灰色对象引用，而在扫描时系统发生了故障，导致灰色对象引用白色对象的指针丢失，导致白色对象被清除。</p></li></ul><p>所以这样也引入了相应的优化方法：插入屏障与删除屏障机制。</p><h2 id="3、Go-插入写屏障、删除写屏障"><a href="#3、Go-插入写屏障、删除写屏障" class="headerlink" title="3、Go 插入写屏障、删除写屏障"></a>3、Go 插入写屏障、删除写屏障</h2><p>​ 插入写屏障主要应用为：在强三色不变式下（黑色直接引用白色的对象），那么此时，使用插入写屏障机制，强行改写黑色引用对象白色为灰色。但是插入写屏障机制会有几个缺点：需要重新扫描栈，大约 10 ms ~ 100 ms，也消耗了相应的系统资源。</p><p>​ 删除写屏障主要应用为：在弱三色不变式下（黑色引用白色对象，白色对象其他上游的引用对象有灰色对象进行引用：解决方法之后写），其也存在相应的不足：回收精度低、一个对象即使被删除了最后一个指向它的指针也依旧能活过这一轮，在下一轮的 GC 中被清除。</p><h2 id="4、Go-V1-8-三色标记法与混合写屏障"><a href="#4、Go-V1-8-三色标记法与混合写屏障" class="headerlink" title="4、Go V1.8 三色标记法与混合写屏障"></a>4、Go V1.8 三色标记法与混合写屏障</h2><p>​ 混合标记法其实很容易理解，就是把插入写屏障与删除写屏障混合起来进行使用，其相应的步骤如下：</p><blockquote><p>1、在 Go GC 触发之前，递归扫描分配在栈上的对象，使栈上的对象全部标记为”黑色”（此处因为是标记为全部 “黑色”，所以不会使用 STW 机制）</p><p>2、在 Go GC 运行期间，如果往栈上插入对象，将栈上的对象全部标记为 “黑色”。</p><p>3、同理，在 Go GC 运行，所有往堆上插入或者删除的对象，都标记为 “灰色”</p></blockquote><h2 id="5、Go-GC-性能不佳的原因"><a href="#5、Go-GC-性能不佳的原因" class="headerlink" title="5、Go GC 性能不佳的原因"></a>5、Go GC 性能不佳的原因</h2><p>1、建立的 struct 对象过小，所以导致频繁的 GC 检查；</p><p>2、Go 文件中出现内存泄漏的问题。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMP 模型分析</title>
    <link href="/2022/02/24/go/concurrency/GMP/"/>
    <url>/2022/02/24/go/concurrency/GMP/</url>
    
    <content type="html"><![CDATA[<p>​ 关于 GMP 模型的一些理解，G 为 goroutine, M 为 thread(内核级线程)、P 为 Processor(处理器)。</p><h2 id="1、Golang-早期调度器的由来"><a href="#1、Golang-早期调度器的由来" class="headerlink" title="1、Golang 早期调度器的由来"></a>1、Golang 早期调度器的由来</h2><p>​ 在讲述早期调度器之前，让我们先聊一下早期的操作系统。</p><p>​ 在没有多核 CPU 之前，操作系统以单进程的任务执行，计算机在只能一个任务一个任务完整的执行的情况。在此情况下，操作系统不仅存在工作效率低下的问题，而且一旦正在执行任务被阻塞时，CPU 资源无法释放，会导致其 CPU 资源与时间的浪费，因此操作系统采用了时间片轮询的方式调度进程，而此举动也无法改变单核 CPU 的硬件条件。</p><p>​ 为了解决上述缺陷，随后引入了多进程、多线程的解决方式。虽然多进程与多线程的方式很好解决了 CPU 调度的，效率问题，但是设计多进程、多线程的架构会变得异常复杂。不仅如此，当进程与线程数量越多的时候，多进程多线程系统进行进程线程切换的成本就越大，资源浪费现象也越明显：如(锁、竞争资源冲突等)，所以在多进程、多线程模型中也存在相应的壁垒，即高内存占用与高 CPU 调度消耗。</p><p>​ 而 Go 语言为了更好的解决操作系统中线程调度的开销大，引入了比线程更轻量级的协程，其内存占用一般只有 4KB ，调度灵活，切换成本低。并且开发出 Go 语言早期的调度器：基本的全局 Go 队列和比较传统的轮询方法，利用多个 M 进行 G 的调度，可以称其为 GM 模型。</p><h2 id="2、GM-早期调度器的缺点"><a href="#2、GM-早期调度器的缺点" class="headerlink" title="2、GM 早期调度器的缺点"></a>2、GM 早期调度器的缺点</h2><p>​ Go 语言早期的调度器 GM 模型虽然能够利用多核的 CPU ，但是其相应的缺点也非常明显：</p><blockquote><ul><li>1、创建、销毁、调度 G 都需要每个 M 获取锁，形成了激烈的锁竞争</li><li>2、M 调度 G 时，会造成延迟以及额外的系统负载</li><li>3、系统调用(CPU 在 M 之间的切换)导致频繁的线程阻塞和取消操作，增加了系统开销。</li></ul></blockquote><p>​ 所以为了解决以上的问题，引入了 GMP 模型。</p><h2 id="3、GMP-现代调度器简介"><a href="#3、GMP-现代调度器简介" class="headerlink" title="3、GMP 现代调度器简介"></a>3、GMP 现代调度器简介</h2><p>​ 如下图可知，GMP 现代调度器，采用了两种队列：全局队列以及本地队列。</p><p><img src="/images/go/GMP2.png"></p><p>全局队列很好理解，可视为全局变量，本地队列则能理解为局部变量。本地队列的个数依赖于 P 的个数，即 GOMAXPROCS 的个数，此值由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行。每一个 P 的本地队列中能存放 G 的个数不超过 256 个。新建的 G 一般优先放置在 P 的本地队列中。</p><p>​ Go 语言本身限定 M 数量的最大量为 10000 (忽略)，一般操作系统也达不到 10000 个线程。使用 runtime&#x2F;debug 包中的SetMaxThreads 函数来设置。有一个 M 阻塞，就会创建一个新的 M，如果有 M 空闲，则会进行回收或者睡眠。</p><h2 id="4、GMP-调度策略"><a href="#4、GMP-调度策略" class="headerlink" title="4、GMP 调度策略"></a>4、GMP 调度策略</h2><p>​ 设计策略有以下四种：</p><blockquote><p>1、线程复用</p><p>​ 采用两种机制：work stealing 机制 与 hand off 机制。</p><p>​ work stealing 机制：当本线程无可运行的 G 时，尝试从其他的线程绑定的 P 偷取 G，而不是销毁线程，优先级是先从全局队列中获取 G，再从其他的 P 的本地队列中获取 G 。</p><p>​ hand off 机制：当本线程因为 G 进行系统调用阻塞的时候，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</p><p>2、并行应用</p><p>​ 一般来说，GOMAXPROCS 限定的 P 个数为 CPU 的核心数量的一半。</p><p>3、抢占</p><p>​ 有多个 G 等待执行时候，每个 G 在 cpu 执行下不超过 10ms，防止其他 G 被饿死现象。</p><p>4、全局 G 队列</p><p>​ 基于work stealing 机制进行的补充。从其他 P 本地队列偷不到 G 时，偷取全局队列的 G 。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go web 的相关知识复习</title>
    <link href="/2022/02/22/go/basic/gin/"/>
    <url>/2022/02/22/go/basic/gin/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开始动手学习一些框架的基本样例，抛开学习底层的设计不谈，主要还是参考文档进行相应的组件开发。参考文档见文末</p></blockquote><h2 id="1、Beego-与-gin"><a href="#1、Beego-与-gin" class="headerlink" title="1、Beego 与 gin"></a>1、Beego 与 gin</h2><p>​ 首先学习框架之前，需要我们理解一个道理，学习框架的目的是首先是适应业务场景的需要，其次是有两种大类：一种是为了开发效率，另一种是为了追求运行的性能。</p><p>​ 追求运行性能的框架包含的东西挺好，比如 GIN ，另一种追求开发效率的框架封装得非常好，即是 Beego 框架。</p><h2 id="2、路由分组"><a href="#2、路由分组" class="headerlink" title="2、路由分组"></a>2、路由分组</h2><p>​ gin 框架的路由分组为：对 router 创建 Group 即为分组，同一分组拥有同一前缀和同一中间件。其相关的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">v1 := r.Group(<span class="string">&quot;v1&quot;</span>) </span><br><span class="line">&#123;</span><br><span class="line">    v1.POST(<span class="string">&quot;/login&quot;</span>, login)</span><br><span class="line">    v1.POST(<span class="string">&quot;/submit&quot;</span>, <span class="function"><span class="keyword">func</span>)</span></span><br><span class="line">    v1.POST(<span class="string">&quot;/read&quot;</span>, <span class="function"><span class="keyword">func</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由分组的目的是：使路由更加清晰，方便管理路由</p><h2 id="3、中间件"><a href="#3、中间件" class="headerlink" title="3、中间件"></a>3、中间件</h2><p>​ 在请求到达路由的方法前和后进行的一系列的操作，使用中间件的时候，在路由组上进行 use 操作，后面传入中间件函数即可。中间件有概念叫做<a href="https://zhuanlan.zhihu.com/p/279391637">洋葱中间件</a>，此处引用知乎博主的图：</p><p><img src="/images/go/gin.jpg" alt="gin"></p><p>用 Go 语言写的还有以下的相关中间件</p><blockquote><p>日志: 一般日志使用其他的工具：如 go-logging、logrus 等开源库。以及配合相应的日志切割工具去使用。</p><p>Gorm: orm 为是一种数据库操作辅助工具。Gorm 即是在 go 语言结构体和数据库产生映射，使得数据库关系、表内容可以直观的体现在结构体上。即可使用结构体完成增删改查的操作！至于 Gorm 如何使用，可以参考相应的详细文档，简单的增删改查可以使用 Gorm。设计复杂的结构以及优化操作，建议阅读 MYSQL 性能调优，阅读相应的例子进行优化。</p></blockquote><h2 id="4、框架的学习"><a href="#4、框架的学习" class="headerlink" title="4、框架的学习"></a>4、框架的学习</h2><p>​快速掌握代码库中的库函数，最适合的学习方法为：先读库函数 -&gt;  再读相应的结构体定义 -&gt; 最后读相应的结构体绑定的方法。</p><p>​其中前两部分只需要执行 go doc 命令即可查看相应的函数与结构体，而第三部分需要仔细阅读相应的源码。记录学习的过程，建议使用思维导图，最后导入 markdown 文件中。</p><h2 id="5、Restful-风格"><a href="#5、Restful-风格" class="headerlink" title="5、Restful 风格"></a>5、Restful 风格</h2><p>其中 restful 主要是四种方式 GET、POST、PUT、DELETE</p><blockquote><p>GET 用于获取资源</p><p>POST 用于创建资源</p><p>PUT 用于修改资源</p><p>DELETE 用于删除资源</p></blockquote><hr><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949415">https://www.kancloud.cn/shuangdeyu/gin_book/949415</a></p><p><a href="https://gorm.io/zh_CN/docs/">https://gorm.io/zh_CN/docs/</a></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 与 SQL 复习</title>
    <link href="/2022/02/19/middleware/mysql1/"/>
    <url>/2022/02/19/middleware/mysql1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>轻量化复盘一下 sql 操作，以及 MySQL</p></blockquote><h2 id="1、SELECT-语句"><a href="#1、SELECT-语句" class="headerlink" title="1、SELECT 语句"></a>1、SELECT 语句</h2><p>​ 数据查询为关系运算理论在 SQL 语言中的主要体现。SQL 的数据查询只一条 SELECT 语句，其使用最广泛。一个完整的 SELECT 语句包含了六个字句，前两个字句是必备的，其他字句可以省略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 完整格式：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] 目标列名序列 <span class="comment">------ 查看的列 [distinct] 为去重操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> 表名或视图名 <span class="comment">------------------- 数据来源</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">WHERE</span> 条件表达式] <span class="comment">------------------ 查询条件</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">+</span> 列名] <span class="comment">------------------ 分组依据</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">+</span> 组条件表达式] <span class="comment">------------- 分组条件</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">+</span> 列名 <span class="operator">+</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]序列]<span class="comment">--- 排序依据</span></span><br></pre></td></tr></table></figure><p>​ 其中使用 distinct 时要注意列名要在 distinct 的后面，而使用聚合函数时，则是在 count[distinct&lt;列名&gt;] 语法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> device_id </span><br><span class="line"><span class="keyword">FROM</span> usr_profile</span><br></pre></td></tr></table></figure><p>​ 查询列后，将列取别名操作，要使用 as ，但是也能省略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">列名 <span class="operator">|</span> 表达式 [ <span class="keyword">AS</span> ] 新列名 或 新列名＝列名 <span class="operator">|</span> 表达式</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id <span class="keyword">as</span> user_infos_example </span><br><span class="line"><span class="keyword">FROM</span> user_profile</span><br><span class="line"></span><br><span class="line"># 等同于</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id user_infos_example </span><br><span class="line"><span class="keyword">FROM</span> user_profile</span><br></pre></td></tr></table></figure><h2 id="2、LIMIT-语句"><a href="#2、LIMIT-语句" class="headerlink" title="2、LIMIT 语句"></a>2、LIMIT 语句</h2><p>​ 在大表中，一般很少一次性查出所有数据，这样对数据库的压力太大，如果只是抽查一些数据，就可以使用LIMIT关键字来查询。 LIMIT 子句的使用，用于强制 SELECT 语句返回指定的记录数。其接受一个或两个数字参数，且参数必须为整型常量。</p><p>​ 如果只给定一个参数，返回最大的记录行数目</p><p>​ 给的两个参数，第一个参数是行数序号（从0开始表示第一行），第二个参数是数量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line">LIMIT <span class="number">5</span>,<span class="number">5</span> # 检索记录行<span class="number">6</span><span class="number">-10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line">LIMIT <span class="number">10</span>,<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>​ 也能结合offset 一起使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">device_id </span><br><span class="line"><span class="keyword">from</span> user_profile </span><br><span class="line">limit <span class="number">2</span> <span class="keyword">offset</span> <span class="number">0</span> # 跳过<span class="number">0</span>条，从第一条数据开始取，取两条数据</span><br></pre></td></tr></table></figure><h2 id="3、BETWEEN-语句"><a href="#3、BETWEEN-语句" class="headerlink" title="3、BETWEEN 语句"></a>3、BETWEEN 语句</h2><p>​ 当需要查询某个范围值的时候，一般使用两种语句，between and， 以及 and 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id, gender, age </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">where</span> age </span><br><span class="line"><span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br><span class="line"># 等价于</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id, gender, age </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">23</span></span><br></pre></td></tr></table></figure><h2 id="4、NOT-IN-语句"><a href="#4、NOT-IN-语句" class="headerlink" title="4、NOT IN 语句"></a>4、NOT IN 语句</h2><p>​ 当需要查询集合中指定属性值时，使用 IN ，除此属性值之外的所有值使用 NOT IN</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 [<span class="keyword">NOT</span>] <span class="keyword">IN</span> <span class="string">&#x27;属性值&#x27;</span></span><br></pre></td></tr></table></figure><p>​ IN：当列中的值与IN中的某个常量值相等时，则结果为True，表明此记录为符合查询条件的记录。<br>​ NOT IN：当列中的值与某个常量值相等时，结果为False，表明此记录为不符合查询条件的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">where</span> university <span class="keyword">NOT</span> <span class="keyword">IN</span> <span class="string">&#x27;复旦大学&#x27;</span></span><br></pre></td></tr></table></figure><p>​ 当需要过滤空值时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id, gender, age, university </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">!=</span><span class="string">&#x27;&#x27;</span>; </span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id, gender, age, university </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">is</span> <span class="keyword">NOT NULL</span></span><br></pre></td></tr></table></figure><h2 id="5、AND-OR-语句"><a href="#5、AND-OR-语句" class="headerlink" title="5、AND OR 语句"></a>5、AND OR 语句</h2><p>​ bool 值运算关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id, gender, age, university, gpa </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">WHERE</span> gpa <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><p>​ 混合使用，AND 的优先级大于 OR</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">device_id, gender, age, university, gpa </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">WHERE</span> (gpa <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">and</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span>) <span class="keyword">OR</span> (gpa <span class="operator">&gt;</span> <span class="number">3.8</span> <span class="keyword">and</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="6、模糊匹配"><a href="#6、模糊匹配" class="headerlink" title="6、模糊匹配"></a>6、模糊匹配</h2><p>​ 数据库中要进行模糊查询，主要使用以下操作</p><blockquote><ol><li>_ ：下划线，代表匹配任意一个字符；</li><li>% ：百分号，代表匹配0个或多个字符；</li><li>[]: 中括号，代表匹配其中的任意一个字符；</li><li>[^]: ^尖冒号 代表 非，取反的意思；不匹配中的任意一个字符。</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">like</span> 模糊查询用法：</span><br><span class="line">  <span class="string">&#x27;%北京&#x27;</span>   北京开头的</span><br><span class="line">  <span class="string">&#x27;_北京%&#x27;</span>  第二三个字为北京 </span><br><span class="line">  <span class="string">&#x27;%北京%&#x27;</span>  含有北京的</span><br><span class="line"></span><br><span class="line">tips: </span><br><span class="line"> 你了解哪些数据库优化技术？ </span><br><span class="line"> 答：<span class="keyword">SQL</span>语句优化也属于数据库优化一部分，而我们的 <span class="keyword">like</span> 模糊查询会引起全表扫描，速度比较慢，应该尽量避免使用<span class="keyword">like</span>关键字进行模糊查询。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> device_id,age,university <span class="keyword">FROM</span> user_profile</span><br><span class="line"><span class="keyword">WHERE</span> university <span class="keyword">LIKE</span> <span class="string">&#x27;%北京%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="7、SQL-中相应的一些函数"><a href="#7、SQL-中相应的一些函数" class="headerlink" title="7、SQL 中相应的一些函数"></a>7、SQL 中相应的一些函数</h2><p>​ 1、max</p><p>​ 查找某个条件限制下的最小最大值时候，一般有两种方法：第一种为使用 最高分-降序排序，取第一一位。第二种为使用 max 函数也行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">max</span>(gpa) </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">WHERE</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span></span><br><span class="line"></span><br><span class="line"># 上为第二种，下为第一种方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    gpa </span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">WHERE</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> gpa </span><br><span class="line"><span class="keyword">DESC</span> limit <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">order</span> <span class="keyword">by</span> 为升序排列，<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">desc</span> 为降序排列</span><br></pre></td></tr></table></figure><p>​ 2、count、round、avg 函数</p><p>​ count 用于统计某个值的数量，round 用于保留几位小数，avg 用于求某一列的平均值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="built_in">COUNT</span>(gender) <span class="keyword">as</span> male_num,</span><br><span class="line">    round(<span class="built_in">avg</span>(gpa), <span class="number">1</span>) <span class="keyword">as</span> avg_gpa</span><br><span class="line"><span class="keyword">from</span> user_profile <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><p>​ 3、聚合函数结果作为筛选条件时，不能用where，而是用having语法，配合重命名即可；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    university,</span><br><span class="line">    <span class="built_in">avg</span>(question_cnt) <span class="keyword">as</span> avg_question_cnt,</span><br><span class="line">    <span class="built_in">avg</span>(answer_cnt) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">FROM</span> user_profile </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> university</span><br><span class="line"><span class="keyword">HAVING</span> avg_question_cnt <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">OR</span> avg_answer_cnt <span class="operator">&lt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="8、多表查询"><a href="#8、多表查询" class="headerlink" title="8、多表查询"></a>8、多表查询</h2><p>​ 若一个查询同时涉及两个或两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询。</p><p>​ 连接查询包括：内连接、外连接、交叉连接等</p><p>​ 连接查询用于连接两个表的条件称为连接条件或者连接谓词。</p><p>​ 相应的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> …</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line">[<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 被连接表</span><br><span class="line"><span class="keyword">ON</span> 连接条件</span><br><span class="line"></span><br><span class="line">#以上结果中会包含重复的列</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 学生表</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 班级表 <span class="keyword">ON</span> 学生表.班号<span class="operator">=</span>班级表.班号</span><br><span class="line"></span><br><span class="line">#去除重复列！</span><br><span class="line"><span class="keyword">SELECT</span> 学号, 姓名, 班级表.班号, 班名 <span class="keyword">FROM</span> 学生表 <span class="keyword">JOIN</span> 班级表 <span class="keyword">ON</span> 学生表.班号<span class="operator">=</span>班级表.班号</span><br><span class="line"></span><br><span class="line"># 举几个多表连接的例子，多体会</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    u.university,</span><br><span class="line">    <span class="built_in">count</span>(q.question_id) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> (q.device_id)) <span class="keyword">as</span> avg_answer_cnt </span><br><span class="line"><span class="keyword">from</span> user_profile <span class="keyword">as</span> u</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> question_practice_detail <span class="keyword">as</span> q </span><br><span class="line"><span class="keyword">on</span> u.device_id <span class="operator">=</span> q.device_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> u.university</span><br><span class="line"></span><br><span class="line"># <span class="keyword">right</span> <span class="keyword">join</span> 联结结果保留右表的全部数据</span><br><span class="line"># <span class="keyword">left</span> <span class="keyword">join</span>  联结结果保留左表的全部数据</span><br><span class="line"># <span class="keyword">inner</span> <span class="keyword">join</span> 保留两表的公共数据</span><br></pre></td></tr></table></figure><h2 id="9、组合查询"><a href="#9、组合查询" class="headerlink" title="9、组合查询"></a>9、组合查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目：现在运营想要分别查看学校为山东大学或者性别为男性的用户的device_id、gender、age和gpa数据，请取出相应结果，结果不去重。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    device_id, gender, age, gpa </span><br><span class="line"><span class="keyword">from</span> user_profile </span><br><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    device_id, gender, age, gpa </span><br><span class="line"><span class="keyword">from</span> user_profile </span><br><span class="line"><span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br><span class="line"> </span><br><span class="line">使用以下语句，会去重</span><br><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span> <span class="keyword">or</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> 会去重， <span class="keyword">union</span> <span class="keyword">all</span> 不会去重</span><br></pre></td></tr></table></figure><hr><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://www.nowcoder.com/exam/oj?tab=SQL%E7%AF%87&topicId=199">https://www.nowcoder.com/exam/oj?tab=SQL%E7%AF%87&amp;topicId=199</a></p>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1791. 找出星型图的中心节点</title>
    <link href="/2022/02/18/Leetcode/1791/"/>
    <url>/2022/02/18/Leetcode/1791/</url>
    
    <content type="html"><![CDATA[<h1 id="1791-找出星型图的中心节点"><a href="#1791-找出星型图的中心节点" class="headerlink" title="1791. 找出星型图的中心节点"></a><strong><a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">1791. 找出星型图的中心节点</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">有一个无向的 星型 图，由 n 个编号从 <span class="number">1</span> 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - <span class="number">1</span> 条边将中心节点与其他每个节点连接起来。</span><br><span class="line"></span><br><span class="line">给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，节点 <span class="number">2</span> 与其他每个节点都相连，所以节点 <span class="number">2</span> 是中心节点。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> &lt;= n &lt;= <span class="number">105</span></span><br><span class="line">edges.length == n - <span class="number">1</span></span><br><span class="line">edges[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">1</span> &lt;= ui, vi &lt;= n</span><br><span class="line">ui != vi</span><br><span class="line">题目数据给出的 edges 表示一个有效的星型图</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、使用一个计数排序，可以使用 map，也能使用结构体，遍历然后取次数最大的一个即可</li><li>2、星型线的定义，所有点只与中心点连接，所以只要判断两个点即可</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findCenter</span><span class="params">(edges [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法 1：遍历二维数组，时间复杂度O(n ^ 2) </span></span><br><span class="line"><span class="comment">    n, m := len(edges), len(edges[0])</span></span><br><span class="line"><span class="comment">    hash := map[int]int&#123;&#125;</span></span><br><span class="line"><span class="comment">    for i := 0; i &lt; n; i++ &#123;</span></span><br><span class="line"><span class="comment">        for j := 0; j &lt; m; j++ &#123;</span></span><br><span class="line"><span class="comment">            hash[edges[i][j]]++ </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    p := hash[0]</span></span><br><span class="line"><span class="comment">    q := 0</span></span><br><span class="line"><span class="comment">    for i, v := range hash &#123;</span></span><br><span class="line"><span class="comment">        if v &gt; p &#123;</span></span><br><span class="line"><span class="comment">            p = v</span></span><br><span class="line"><span class="comment">            q = i</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return q */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二 ：由于是星型线，所以每个子数组两个值必有一个值相等</span></span><br><span class="line">    <span class="keyword">if</span> edges[<span class="number">0</span>][<span class="number">0</span>] == edges[<span class="number">1</span>][<span class="number">0</span>] || edges[<span class="number">0</span>][<span class="number">0</span>] == edges[<span class="number">1</span>][<span class="number">1</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edges[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2) &#x2F; O(1)</p></li><li><p>空间复杂度：O(n) &#x2F; O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些刷算法的小模版</title>
    <link href="/2022/02/18/Leetcode/template/"/>
    <url>/2022/02/18/Leetcode/template/</url>
    
    <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(q []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> l == r &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> x := q[(l+r)&gt;&gt;<span class="number">1</span>]</span><br><span class="line"> i, j := l<span class="number">-1</span>, r+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">   i++</span><br><span class="line">   <span class="keyword">if</span> q[i] &gt;= x &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">   j--</span><br><span class="line">   <span class="keyword">if</span> q[j] &lt;= x &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">   q[i], q[j] = q[j], q[i]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> QuickSort(q, l, j)</span><br><span class="line"> QuickSort(q, j+<span class="number">1</span>, r)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="归并排序（针对单个数组版本）"><a href="#归并排序（针对单个数组版本）" class="headerlink" title="归并排序（针对单个数组版本）"></a>归并排序（针对单个数组版本）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(p, q []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> l == r &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> mid := (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line"> MergeSort(p, q, l, mid)</span><br><span class="line"> MergeSort(p, q, mid+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"> k, i, j := <span class="number">0</span>, l, mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= r &#123;</span><br><span class="line">  <span class="keyword">if</span> q[i] &lt;= q[j] &#123;</span><br><span class="line">   p[k] = q[i]</span><br><span class="line">   k++</span><br><span class="line">   i++</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   p[k] = q[j]</span><br><span class="line">   k++</span><br><span class="line">   j++</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> i &lt;= mid &#123;</span><br><span class="line">  p[k] = q[i]</span><br><span class="line">  k++</span><br><span class="line">  i++</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> j &lt;= r &#123;</span><br><span class="line">  p[k] = q[j]</span><br><span class="line">  k++</span><br><span class="line">  j++</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> i, j = l, <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i &lt; r &#123;</span><br><span class="line">  q[i] = p[j]</span><br><span class="line">  i++</span><br><span class="line">  j++</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 基础知识点自我总结</title>
    <link href="/2022/02/13/go/basic/go-study/"/>
    <url>/2022/02/13/go/basic/go-study/</url>
    
    <content type="html"><![CDATA[<blockquote><p>tips: 总结知识点一定要自己动手，这样知识点才能牢记！</p><p>​比如开源社区有雨痕大佬的 Go 语言笔记，但是光看几个用法，而不进行代码的编写，代码能力提升不明显，能看懂，但是做不到，形成一种眼高手低的习惯。更何况，以后的工作本来就是写需求的代码，所以，各种基础知识点，快速过完！</p></blockquote><h2 id="1、保留字与预定义字"><a href="#1、保留字与预定义字" class="headerlink" title="1、保留字与预定义字"></a>1、保留字与预定义字</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保留字有 25 个</span></span><br><span class="line"><span class="keyword">break</span>  <span class="keyword">continue</span>  <span class="function"><span class="keyword">func</span>  <span class="title">interface</span>  <span class="title">select</span></span> </span><br><span class="line"><span class="keyword">case</span>  <span class="keyword">defer</span>   <span class="keyword">go</span>  <span class="keyword">map</span>   <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>  <span class="keyword">else</span>   <span class="keyword">goto</span>  <span class="keyword">package</span>   <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">switch</span>   <span class="keyword">if</span>  <span class="keyword">range</span>   <span class="keyword">type</span></span><br><span class="line"><span class="keyword">default</span>  <span class="keyword">for</span>   <span class="keyword">import</span>  <span class="keyword">return</span>    <span class="keyword">var</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为相关的预定义字</span></span><br><span class="line"><span class="literal">true</span>  <span class="literal">false</span>   <span class="literal">iota</span>  <span class="literal">nil</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//内建字类型</span></span><br><span class="line"><span class="type">int</span>  <span class="type">int16</span>  <span class="type">int32</span> <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span>  <span class="type">uint16</span>   <span class="type">uint32</span>  <span class="type">uint64</span></span><br><span class="line"><span class="type">float32</span>  <span class="type">float64</span>   <span class="type">complex64</span> <span class="type">complex128</span></span><br><span class="line"><span class="type">bool</span>  <span class="type">byte</span>   <span class="type">rune</span>  <span class="type">string</span>   <span class="type">error</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//内建函数</span></span><br><span class="line"><span class="built_in">make</span>  <span class="built_in">len</span>   <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span></span><br><span class="line"><span class="built_in">copy</span>  <span class="built_in">close</span>   <span class="built_in">delete</span>  <span class="built_in">complex</span>  <span class="built_in">real</span></span><br><span class="line"><span class="built_in">imag</span>  <span class="built_in">panic</span>   <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h2 id="2、Go-中的一些常用函数"><a href="#2、Go-中的一些常用函数" class="headerlink" title="2、Go 中的一些常用函数"></a>2、Go 中的一些常用函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>          -- 用来追加元素到数组、slice中,返回修改后的数组、slice</span><br><span class="line"><span class="built_in">close</span>           -- 主要用来关闭 channel </span><br><span class="line"><span class="built_in">delete</span>          -- 从<span class="keyword">map</span>中删除 key 对应的 value</span><br><span class="line"><span class="built_in">panic</span>           -- 停止常规的 goroutine (<span class="built_in">panic</span>和<span class="built_in">recover</span>：用来做错误处理)</span><br><span class="line">   <span class="built_in">recover</span>         -- 允许程序定义goroutine的<span class="built_in">panic</span>动作</span><br><span class="line"><span class="built_in">real</span>            -- 返回<span class="built_in">complex</span>的实部 (<span class="built_in">complex</span>、<span class="built_in">real</span> <span class="built_in">imag</span>用于创建和操作复数)</span><br><span class="line">   <span class="built_in">imag</span>            -- 返回<span class="built_in">complex</span>的虚部</span><br><span class="line">   <span class="built_in">make</span>            -- 用来分配内存，返回 Type 本身(只能应用于 slice, <span class="keyword">map</span>, channel )</span><br><span class="line">   <span class="built_in">new</span>             -- 用来分配内存，主要用来分配值类型，如 <span class="type">int</span>、<span class="keyword">struct</span> 返回指向 Type 的指针</span><br><span class="line">   <span class="built_in">cap</span>             -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 <span class="keyword">map</span>）</span><br><span class="line">   <span class="built_in">copy</span>            -- 用于复制和连接 slice，返回复制的数目</span><br><span class="line">   <span class="built_in">len</span>             -- 来求长度，比如 <span class="type">string</span>、array、slice、<span class="keyword">map</span>、channel，返回长度</span><br></pre></td></tr></table></figure><h2 id="3、Go-中的-Array-数组"><a href="#3、Go-中的-Array-数组" class="headerlink" title="3、Go 中的 Array 数组"></a>3、Go 中的 Array 数组</h2><blockquote><p>答：Go 语言中的数组与其他语言的数组不一样<br>1、Go 语言中的数组是值类型，赋值和传参会复制整个数组，而不是指针</p><p>​ 2、Go 语言中的数组长度必须是常量，而且是类型的组成成分，[2]int,[3]int 是不同类型</p><p>​ 3、Go 语言中的数组能支持 “&#x3D;&#x3D;” “!&#x3D;” 操作，因为内存被初初始化过。</p><p>​ 4、指针数组 [n]<em>T &#x2F;&#x2F;表示由 n 个</em>T 指针构成</p><p>​ 5、数组指针 *[n]T &#x2F;&#x2F;表示由一个指针指向这个数组，可以视为一维数组来看</p><p>​ 6、array 数组不建议拷贝，如需要拷贝使用 slice 更好，或者数组指针</p></blockquote><h2 id="4、Go-中的-slice"><a href="#4、Go-中的-slice" class="headerlink" title="4、Go 中的 slice"></a>4、Go 中的 slice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> slice 为结构体，通过内部指针和相关的结构属性引用数组片段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> Slice &#123;</span><br><span class="line"> <span class="type">byte</span>* array  <span class="comment">//引用类型，但是是结构体，所以采用值拷贝传递</span></span><br><span class="line">    uintgo <span class="built_in">len</span>  <span class="comment">//slice 数量，读写不超过该限制</span></span><br><span class="line">    uintgo <span class="built_in">cap</span>  <span class="comment">//slice 容量，不能超出数组限制</span></span><br><span class="line"> <span class="comment">//slice == nil, len = cap = 0</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Go 中还有一个关于 slice 的拼接问题 如下</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> s2 := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"> s1 = <span class="built_in">append</span>(s1, s2)</span><br><span class="line"> fmt.Println(s1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述代码编译失败 8:13: cannot use s2 (type []int) as type int in append； 两个slice 在 append 的时候，记住需要进行第二个 slice 时候，将slice打散再拼接！</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, s2...)</span><br></pre></td></tr></table></figure><h2 id="5、Go-中的面向对象"><a href="#5、Go-中的面向对象" class="headerlink" title="5、Go 中的面向对象"></a>5、Go 中的面向对象</h2><p>​ 面向对象的三大特征：多态、继承、封装<br>Go 语言只支持封装行为，没有继承与多态，也没有 class 关键字但是能做到 struct 中嵌入 struct类型</p><h2 id="6、Go-方法"><a href="#6、Go-方法" class="headerlink" title="6、Go 方法"></a>6、Go 方法</h2><p>方法：方法是绑定对象实例的，隐式将实例作为第一形参</p><ul><li>1、只能为当前包内命名类型定义方法</li><li>2、参数 receiver 随意命名，如果未使用此名称，可省略</li><li>3、参数 receiver 类型可以为 T、*T，但是基类T不能是指针与接口</li><li>4、不支持方法重载，receiver 为参数签名的组成成分</li><li>5、可用实例 value 或 pointer 调用全部方法，编译器自动转换</li><li>6、通常使用简单工厂模式返回对象实例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span>&#123;</span><br><span class="line">    elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Queue&#123;</span><br><span class="line">        <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Queue)</span></span> push(e <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (Queue) push(e int) error &#123;</span></span><br><span class="line"><span class="comment">//    panic(&quot;not implemented&quot;)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> length() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.elements)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、Go-接口"><a href="#6、Go-接口" class="headerlink" title="6、Go 接口"></a>6、Go 接口</h2><p>​ 接口是方法的集合，由于不支持重载，所以每个方法命名唯一</p><ul><li>1、接口命名以 er 结尾，结构体</li><li>2、接口不实现方法</li><li>3、接口无数据字段</li><li>4、接口内可以嵌入其他接口</li><li>5、类型可实现多接口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stringer</span><br><span class="line">    Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *User)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User %d, %s&quot;</span>, this.id, this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *User)</span></span> Print() &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Println(this.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、Goroutine"><a href="#7、Goroutine" class="headerlink" title="7、Goroutine"></a>7、Goroutine</h2><p>​ Goroutine 为 go 协程，仅仅需要在函数调用语句前添加 go 关键字即可调用goroutine，并且创建并发执行单元。goroutine 的设计具有轻量级！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>) <span class="comment">//此为 goroutine  </span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//main 函数的执行其实也是 goroutine </span></span><br><span class="line">runtime.Goexit() <span class="comment">//立即终止当前 goroutine 的执行</span></span><br><span class="line">此处学一下使用即可，具体 CSP 的模式与 GMP 的模型下一篇博客继续学习</span><br></pre></td></tr></table></figure><h2 id="8、Channel"><a href="#8、Channel" class="headerlink" title="8、Channel"></a>8、Channel</h2><p>​ 引用类型 channel 为 CSP 的模式的具体实现，使用 channel 用于多个 goroutine 的通信，确保并发安全，尽量使用 channel 来代替锁进行同步。<br>​ channel 默认为同步的模式，需要发送和接受配对，否则一直处于被阻塞的状态，直到两边都处于活跃状态然后才被唤醒。<br>​ 以下为同步模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 数据交换队列</span></span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// 退出通知</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> data &#123; <span class="comment">// 从队列迭代接收数据，直到 close 。</span></span><br><span class="line">            fmt.Println(d)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;recv over.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        exit &lt;- <span class="literal">true</span> <span class="comment">// 发出退出通知。</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    data &lt;- <span class="number">1</span> <span class="comment">// 发送数据。</span></span><br><span class="line"></span><br><span class="line">    data &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    data &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(data) <span class="comment">// 关闭队列。</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;send over.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-exit <span class="comment">// 等待退出通知。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​异步方式：通过判断缓冲区来决定是否阻塞。<br>如果缓冲区满，发送阻塞；缓冲区为空，接受阻塞。<br>通常情况下，异步的 channel 可以减少排队阻塞，具有更高的效率。<br>​但是应该考虑使用指针规避大对象的拷贝，将大对象分治为小对象，如多个元素打包、减小缓冲区大小等。</p><p>以下为异步模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 数据交换队列</span></span><br><span class="line"></span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// 退出通知</span></span><br><span class="line"></span><br><span class="line">    data &lt;- <span class="number">1</span> <span class="comment">// 在缓冲区未满前，不会阻塞。</span></span><br><span class="line">    data &lt;- <span class="number">2</span></span><br><span class="line">    data &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d := <span class="keyword">range</span> data &#123; <span class="comment">// 在缓冲区未空前，不会阻塞。</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line">    &#125;</span><br><span class="line">    exit &lt;- <span class="literal">true</span> <span class="comment">// 发出退出通知。</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    data &lt;- <span class="number">4</span></span><br><span class="line">    data &lt;- <span class="number">5</span></span><br><span class="line">    <span class="built_in">close</span>(data)</span><br><span class="line"></span><br><span class="line">    &lt;-exit <span class="comment">// 等待退出通知。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 其中缓冲区是内部属性，非类型构成要素，内置函数 <span class="built_in">len</span> 返回未被读取的缓冲元素数量， <span class="built_in">cap</span> 返回缓冲区⼤⼩。  </span><br><span class="line"> channel 是第一类对象，可传参 (内部实现为指针) 或者作为结构成员。</span><br></pre></td></tr></table></figure><p>Go 语言还内建了 <code>close()</code> 函数来关闭一个 channel<br>但是存在以下几种情况：</p><blockquote><p>1、读写 nil Channel 会永远阻塞，关闭 nil Channel 会导致 panic</p><p>2、关闭一个已关闭的 Channel 会导致 panic</p><p>3、向已经关闭的 Channel 发送数据会导致 panic</p><p>4、向已经关闭的 Channel 读取数据不会导致 panic，但读取的值为 Channel 传递的数据类型的零值，可以通过接受语句第二个返回值来检查 Channel 是否关闭且排空：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">... <span class="comment">// 如果是非缓冲 Channel ，说明已经关闭；</span></span><br><span class="line">    <span class="comment">// 如果是带缓冲 Channel ，说明已经关闭，且其内部缓冲区已经排空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、Go-中的-select-用法"><a href="#9、Go-中的-select-用法" class="headerlink" title="9、Go 中的 select 用法"></a>9、Go 中的 select 用法</h2><p>​ select 是Go中的一个控制结构，类似于用于通信的 switch 语句，其用于处理异步的 I&#x2F;O 操作。。其有以下的几个特征</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、每个<span class="keyword">case</span>都必须是一个通信，所有 channel 表达式都会被求值。</span><br><span class="line">   </span><br><span class="line">   <span class="number">3</span>、所有被发送的表达式都会被求值</span><br><span class="line">   </span><br><span class="line">   <span class="number">4</span>、如果任意某个通信可以进行，它就执行；其他被忽略。</span><br><span class="line">   </span><br><span class="line"><span class="number">5</span>、如果有多个<span class="keyword">case</span>都可以运行，<span class="keyword">select</span> 会随机 (看源码) 公平地选出一个执行。其他不会执行。</span><br><span class="line">   </span><br><span class="line">   <span class="number">6</span> 、如果有<span class="keyword">default</span>子句，则执行该语句。如果没有<span class="keyword">default</span>字句，<span class="keyword">select</span>将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</span><br></pre></td></tr></table></figure><p>select 会监听每个 case 中 channel 的读写操作，但是每次只能运行一个channel 进行读或写</p><h2 id="10、初始化函数"><a href="#10、初始化函数" class="headerlink" title="10、初始化函数"></a>10、初始化函数</h2><p>初始化函数 init()：go语言中<code>init</code>函数用于包<code>(package)</code>的初始化，该函数是go语言的一个重要特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span> 每个包可以拥有多个init函数</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span> 包的每个源文件也可以拥有多个init函数</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span> 同一个包中多个init函数的执行顺序<span class="keyword">go</span>语言没有明确的定义(说明)</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span> 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</span><br><span class="line"></span><br><span class="line">   <span class="number">6</span> init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</span><br><span class="line"></span><br><span class="line">main 对比 init 函数，main函数只能用于main包中，且只能定义一个。</span><br></pre></td></tr></table></figure><h2 id="11、go-mod-包管理"><a href="#11、go-mod-包管理" class="headerlink" title="11、go mod 包管理"></a>11、go mod 包管理</h2><p> go mod 有以下几种命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化模块 <span class="keyword">go</span> mod init &lt;项目模块名称&gt;</span><br><span class="line">依赖关系处理 ,根据<span class="keyword">go</span>.mod文件 <span class="keyword">go</span> mod tidy</span><br><span class="line">将依赖包复制到项目下的 vendor目录。 <span class="keyword">go</span> mod vendor 如果包被屏蔽(墙),可以使用这个命令，随后使用<span class="keyword">go</span> build -mod=vendor编译</span><br><span class="line">显示依赖关系 <span class="keyword">go</span> list -m all</span><br><span class="line">显示详细依赖关系 <span class="keyword">go</span> list -m -json all</span><br><span class="line">下载依赖 <span class="keyword">go</span> mod download [path@version] [path@version]是非必写的</span><br></pre></td></tr></table></figure><h2 id="12、go-debug"><a href="#12、go-debug" class="headerlink" title="12、go debug"></a>12、go debug</h2><ul><li>go run -race 可以查看有无相应的锁竞争一块</li><li>go tool complie -S [filename] 查看相应的汇编代码</li><li>Linux 下使用 top&#x2F;htop 指令查看 CPU、Memory、VIRT 等信息，其中关于内存泄漏的相应的问题，主要查看的是 VIRT 是否出现不断增长的一种情况。</li></ul><h2 id="13、go-内存逃逸"><a href="#13、go-内存逃逸" class="headerlink" title="13、go 内存逃逸"></a>13、go 内存逃逸</h2><p>内存逃逸的主要概念是：编译时 go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当<strong>发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆</strong>。</p><p>一般内存逃逸都是编译器进行分析的，go 语言的设计者不希望我们过多的研究这个方面的内容，所以一般不用管！</p><hr><blockquote><p>————END 如果本博客存在误解的问题，恳请大家指出！—————-</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 面试复盘</title>
    <link href="/2022/02/12/go/interview/Interview/"/>
    <url>/2022/02/12/go/interview/Interview/</url>
    
    <content type="html"><![CDATA[<blockquote><p>先上总结：</p><ul><li>面经光看没用，只有自己不断的面试，然后总结，自己理解性的进行描述才有意义，否则只是像八股文一样去背记，从而未能理解真正的含义。那么，可能下一次面试的时候，上一次面试的问题依然处于一种遗留的状态，这样就无法在技术的关键节点进行成长。</li><li>尤其是算法题，如果一两个月不复盘算法问题，那么算法思维存在，但是代码熟练度会下降，从而导致写算法的时间变长，以及相应的心态焦虑。至于算法的时间复杂度与空间复杂度放在下文具体说明。</li><li>以下为自己答的不好与没答出的问题。</li></ul></blockquote><h2 id="1、TCP-三次握手"><a href="#1、TCP-三次握手" class="headerlink" title="1、TCP 三次握手"></a>1、TCP 三次握手</h2><blockquote><p>答：TCP的三次握手为：</p><p>​ 1、客户端发送的报文为 SYN 报文，并选择一个初始的 Seq 序号，之后客户端进入监听状态（SYN-SENT）。</p><p>​ 2、服务器在接受到客户端第一次发送的 ACK 报文之后，如果同意连接，即向客户端发送连接确认报文，即 SYN + ACK 报文，也附加一个自选的初始 Seq 序号，并且此序号与客户端的序号无关，之后服务器端继续维持监听状态（SYN-REVD)</p><p>​ 3、客户端在接受到服务器发送回的报文之后，再向服务器端发送确认报文，确认号为服务器初始的  Seq 序号 + 1，序号为自己初始的 Seq 序号 + 1。</p><p>​ 4、此后服务器与客户端正式建立连接，开始发送数据，双方状态为ESTABLISHED。</p></blockquote><p>此处引用哔哩哔哩 up 主<a href="https://www.bilibili.com/video/BV1kV411j7hA?spm_id_from=333.999.0.0">掌芝士zzs</a>的图片</p><p><img src="/images/go/tcp3.png" alt="tcp3"></p><h2 id="2、TCP-需要三次握手的原因"><a href="#2、TCP-需要三次握手的原因" class="headerlink" title="2、TCP 需要三次握手的原因"></a>2、TCP 需要三次握手的原因</h2><blockquote><p>答：采用第三次握手的原因是:</p><p>​ 1、如果第一次客户端的报文中途出现延迟，而客户端开始重发第一次的报文，并且重发报文被服务器正确接收。</p><p>​ 2、而此时，第一次客户端发送的报文又到达服务端，服务端接受后，又返回一个报文，相当于服务器同一个客户端建立了两个连接，而客户端只认为自己建立的一个连接，造成了状态不一致，同时服务器的资源也被浪费了。</p><p>​ 3、故为了尽可能保证连接的建立及时、有效且资源节约，故采用 TCP 三次握手。</p></blockquote><h2 id="3、TCP-四次挥手"><a href="#3、TCP-四次挥手" class="headerlink" title="3、TCP 四次挥手"></a>3、TCP 四次挥手</h2><blockquote><p>答：TCP 的四次挥手过程为</p><p>​ 1、首先由客户端向服务器端发送关闭连接请求报文，即 FIN 报文，此时客户端由 ESTABLISHED 状态转变为 FIN-WAIT-1 状态，此时还能继续接受服务器所发送的数据。</p><p>​ 2、服务器在接受到客户端向服务器端发送的 FIN 包后，向客户端发送确认报文，即 ACK 报文，此时服务器的状态由 ESTABLISHED 状态转变为 CLOSED-WAIT状态，此时服务器端还能继续把未能发送完的数据继续发送。</p><p>​ 3、客户端在接受了服务器端发回的 ACK 确认报文之后由 FIN-WAIT-1 转变为 FIN-WAIT-2 状态，并且能继续接受数据，直到服务器发送终止报文，即 FIN 包为止。</p><p>​ 4、服务器向客户端发送 FIN 包，此时服务器端由 CLOSED-WAIT 状态转变为 LAST-ACK 状态，等待客户端返回最后一次确认报文，即 ACK 为止。</p><p>​ 5、客户端接收到 FIN 包后，由 FIN-WAIT-2 变为 TIME-WAIT 状态，超过一定的时间后自动转变为 CLOSED 状态。</p><p>​ 6、服务器端收到客户端的 ACK 报文后，即由 LAST-ACK 状态转变为 CLOSED 状态，不再发送与接受客户端的数据。</p></blockquote><p>此处引用哔哩哔哩 up 主 <a href="https://www.bilibili.com/video/BV1kV411j7hA?spm_id_from=333.999.0.0">掌芝士zzs</a> 的图片</p><p><img src="/images/go/tcp4.png" alt="tcp4"></p><h2 id="4、TCP-需要四次挥手的原因"><a href="#4、TCP-需要四次挥手的原因" class="headerlink" title="4、TCP 需要四次挥手的原因"></a>4、TCP 需要四次挥手的原因</h2><blockquote><p>答：采用第四次挥手的原因是:</p><p>​ 1、如果客户端第四次发送 ACK 报文后就直接进入 CLOSED 状态，那么如果第四次发送的ACK报文在传输的过程中丢失，服务器由于一直未能接收客户端发送的 ACK 报文，再次向客户端发送相应的 FIN 报文，而此时客户端已经关闭，接受不到服务器发送的 FIN 报文。即造成了服务器的资源浪费</p><p>​ 2、故为了保证通信尽可能的可靠，采用 TCP 四次握手，但是在考研中，有种特殊的情况，在确保第三次握手能成立的情况下，第四次握手可以被省略。若将一个往返视为 RTT 的情况下，最短的释放连接所需要的时间为 1.5 个 RTT 即可，不需要 2 个 RTT，所以这也是为了节省资源所考虑的情况，并不一定视为错误答案。</p></blockquote><h2 id="5、TCP粘包问题"><a href="#5、TCP粘包问题" class="headerlink" title="5、TCP粘包问题"></a>5、TCP粘包问题</h2><blockquote><p>答：TCP 对比 UDP，前者主要是以字节流的形式传输数据，而UDP则以报文的形式传输数据。</p><p>​ 其中报文与字节流的区别主要是，字节流传输是以字节为单位进行数据传输，与每一个数据中的独立的内容无关，而报文传输为传输以报文为单位，保留了报文内容的边界。所以就会导致TCP传输字节时候，有可能区分不了数据的边界，导致最后解包数据所造成的解码乱码现象，即TCP的粘包的问题。</p><p>​ 解决 TCP 粘包问题的办法有许多种，其中在之前所学的Zinx框架中，刘丹冰老师(后面称为 Aceld 老师)解释了一种 TLV 格式的封包解包办法（如下图），即使用 datalen、msgID、data作为封包解包的字段，首先读取一遍封包的头部长度，即 datalen 与 msgID 字段的大小，此处按照自己设置的来。一般设置是两个 uint32 类型，即为 8 Byte 的。</p><p>​ 其中解析开头的 datalen为 data字段的数据长度，msgID 为相应的数据包编号。然后根据开头的 datalen 的具体数值来读取之后的 data 段的数据。至于TCP发送数据流中出现的错误，利用好 TCP 的错误重传机制就好，go 语言也有 TCP 包的实现，具体以后看底层代码来解释，本篇博客暂时不讨论此问题。</p></blockquote><p><img src="/images/go/TLV.jpeg" alt="TLV"></p><h2 id="6、写代码：channel"><a href="#6、写代码：channel" class="headerlink" title="6、写代码：channel"></a>6、写代码：channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多多练习一下代码能力，要脱离相应的视频项目开发，变为生产实际开发，有些东西，一段时间没用就会忘记，比如算法时间复杂度，以及相应的代码熟练度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个channel，一个 channel 输出 ping，一个channel 输出 pang，并发执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//22-5-13 日再回头看，发现问题很显然了，自己当时写一个经典的并发案例没写出来就是属于基础不够好，这个代码也不符合面试官需要达到的要求，只是效果达到了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">q := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">p &lt;- <span class="string">&quot;ping&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">q &lt;- <span class="string">&quot;pang&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c := &lt;-q</span><br><span class="line">a := &lt;-p</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若没有IDE，在vim 看 c 与a 的类型要使用如下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of c : %T\n&quot;</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a : %T\n&quot;</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7、Go-中-map-查询的时间复杂度为-O-1"><a href="#7、Go-中-map-查询的时间复杂度为-O-1" class="headerlink" title="7、Go 中 map 查询的时间复杂度为 O(1)"></a>7、Go 中 map 查询的时间复杂度为 O(1)</h2><blockquote><p>答：查看了相应的各种博客，了解到：</p><ul><li><p>1、java 中 map 的底层源代码实现为数组 + 链表 + 红黑树，所以在数据量极小的情况下，相应的<strong>查询时间复杂度为 O(1)</strong>，而在数据量较多的情况，map 的查询时间复杂度应该是大于 O(1)，小于 O(N)，接近 O(logN) 的时间复杂度的！</p></li><li><p>2、所以说关于 map 的查询时间复杂度是一个很老的问题了，一般使用情况默认为 O(1) 的时间复杂度。但是这并不意味着就要否认 map 的查询时间复杂度是 O(logN) 的说法。</p></li><li><p>3、不懂不理解的问题，一定需要事后进行相关资料的查询，以及总结。</p></li></ul></blockquote><p>关于map 查询的时间复杂度，<a href="https://stackoverflow.com/questions/1055243/is-a-java-hashmap-search-really-o1">StackOverFlow</a> 上给出的说法挺多</p><p><img src="/images/go/mapsearch.png" alt="mapsearch"></p><p><img src="/images/go/mapAnswer1.png" alt="mapAnswer1"></p><p><img src="/images/go/mapAnswer2.png" alt="mapAnswer2"></p><h2 id="8、GMP-模型"><a href="#8、GMP-模型" class="headerlink" title="8、GMP 模型"></a>8、GMP 模型</h2><blockquote><p>强烈推荐 Aceld 老师的 GMP 模式详细解释，可以明白调度器的调度行为。<br>GMP 模型已经单独作为一篇博客存在，所以此处不再阐述。</p></blockquote><h2 id="9、Go-GC-在什么情况下性能比较低"><a href="#9、Go-GC-在什么情况下性能比较低" class="headerlink" title="9、Go GC 在什么情况下性能比较低"></a>9、Go GC 在什么情况下性能比较低</h2><p>1、内存泄露。</p><p>2、小对象，结构体比指针的好</p><hr><blockquote><p>————END 如果本博客存在误解的问题，恳请大家指出！—————-</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1984. 学生分数的最小差值</title>
    <link href="/2022/02/11/Leetcode/1984/"/>
    <url>/2022/02/11/Leetcode/1984/</url>
    
    <content type="html"><![CDATA[<h1 id="1984-学生分数的最小差值"><a href="#1984-学生分数的最小差值" class="headerlink" title="1984. 学生分数的最小差值"></a><a href="https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/">1984. 学生分数的最小差值</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">给你一个 下标从 <span class="number">0</span> 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。</span><br><span class="line"></span><br><span class="line">从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。</span><br><span class="line"></span><br><span class="line">返回可能的 最小差值 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">90</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：选出 <span class="number">1</span> 名学生的分数，仅有 <span class="number">1</span> 种方法：</span><br><span class="line">- [<span class="number">90</span>] 最高分和最低分之间的差值是 <span class="number">90</span> - <span class="number">90</span> = <span class="number">0</span></span><br><span class="line">可能的最小差值是 <span class="number">0</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：选出 <span class="number">2</span> 名学生的分数，有 <span class="number">6</span> 种方法：</span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">4</span> = <span class="number">5</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">1</span> = <span class="number">8</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">7</span> = <span class="number">2</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">4</span> - <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">7</span> - <span class="number">4</span> = <span class="number">3</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">7</span> - <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">可能的最小差值是 <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= nums.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、最简单的方法就是排序之后使用滑动窗口的办法，找寻最小差值就需要两个数都处于排序之后居中的位置。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumDifference</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums) <span class="comment">//go sort</span></span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">range</span> nums[:<span class="built_in">len</span>(nums) - k + <span class="number">1</span>]&#123;</span><br><span class="line">        ans = min(ans, nums[i + k - <span class="number">1</span>] - num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>707. 设计链表</title>
    <link href="/2022/02/10/Leetcode/707/"/>
    <url>/2022/02/10/Leetcode/707/</url>
    
    <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707.设计链表</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 <span class="number">0</span>-index 的。</span><br><span class="line"></span><br><span class="line">在链表类中实现这些功能：</span><br><span class="line"></span><br><span class="line">get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回<span class="number">-1</span>。</span><br><span class="line">addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</span><br><span class="line">addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</span><br><span class="line">addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于<span class="number">0</span>，则在头部插入节点。</span><br><span class="line">deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyLinkedList linkedList = <span class="built_in">new</span> MyLinkedList();</span><br><span class="line">linkedList.addAtHead(<span class="number">1</span>);</span><br><span class="line">linkedList.addAtTail(<span class="number">3</span>);</span><br><span class="line">linkedList.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//链表变为1-&gt; 2-&gt; 3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            <span class="comment">//返回2</span></span><br><span class="line">linkedList.deleteAtIndex(<span class="number">1</span>);  <span class="comment">//现在链表是1-&gt; 3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            <span class="comment">//返回3</span></span><br><span class="line"></span><br><span class="line">所有val值都在 [<span class="number">1</span>, <span class="number">1000</span>] 之内。</span><br><span class="line">操作次数将在  [<span class="number">1</span>, <span class="number">1000</span>] 之内。</span><br><span class="line">请不要使用内置的 LinkedList 库。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、使用 Go 语言实现基础的数据结构</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line"> Val  <span class="type">int</span></span><br><span class="line"> Next *MyLinkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line">    <span class="comment">// 该节点为头结点，不会用到</span></span><br><span class="line"> <span class="keyword">return</span> MyLinkedList&#123;</span><br><span class="line">        Val: <span class="number">-1</span>,</span><br><span class="line">        Next: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"> tmp := this.Next</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; tmp != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == index &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp.Val</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = tmp.Next</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="type">int</span>) &#123;</span><br><span class="line"> this.Next = &amp;MyLinkedList&#123;</span><br><span class="line">  Val:  val,</span><br><span class="line">  Next: this.Next,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="type">int</span>) &#123;</span><br><span class="line"> tmp := this</span><br><span class="line"> <span class="keyword">for</span> tmp.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">  tmp = tmp.Next</span><br><span class="line"> &#125;</span><br><span class="line"> tmp.Next = &amp;MyLinkedList&#123;</span><br><span class="line">  Val:  val,</span><br><span class="line">  Next: <span class="literal">nil</span>,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="type">int</span>, val <span class="type">int</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> index &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  this.AddAtHead(val)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line">    tmp := this.Next</span><br><span class="line">    <span class="comment">// 遍历到index处</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; index &amp;&amp; tmp.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">        tmp = tmp.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index超出链表长度</span></span><br><span class="line">    <span class="keyword">if</span> tmp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp.Next = &amp;MyLinkedList&#123;</span><br><span class="line">        Val:  val,</span><br><span class="line">        Next: tmp.Next,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 空链表</span></span><br><span class="line">    <span class="keyword">if</span> this.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span> index &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  this.Next = this.Next.Next</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> tmp := this.Next</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; index &amp;&amp; tmp.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">  tmp = tmp.Next</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// index超出链表长度</span></span><br><span class="line"> <span class="keyword">if</span> tmp.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> tmp.Next = tmp.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(index);</span></span><br><span class="line"><span class="comment"> * obj.AddAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.DeleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LinkList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zinx 框架的学习</title>
    <link href="/2022/01/10/go/zinx/zinx/"/>
    <url>/2022/01/10/go/zinx/zinx/</url>
    
    <content type="html"><![CDATA[<p>开始学习 Go 语言实现的 zinx 框架,项目地址为：<a href="https://github.com/chaggle/zinx-study">https://github.com/chaggle/zinx-study</a></p><blockquote><p>使用 go mod 管理, 初始化为 go mod init github.com&#x2F;chaggle&#x2F;zinx-study<br>并部署代码到 github.com 以及使用 go get 同步到本地 Gopath 的 github 包下！</p></blockquote><h2 id="V0-1-基础的-server-模块"><a href="#V0-1-基础的-server-模块" class="headerlink" title="V0.1 基础的 server 模块"></a>V0.1 基础的 server 模块</h2><blockquote><p>方法</p><p>初始化服务器 – NewServer(name string) ziface.IServer</p><p>启动服务器 – Start()</p><p>停止服务器 – Stop()</p><p>运行服务器 – Serve()</p><p>属性</p><p>名称 – name</p><p>IP 版本 – IPVersion</p><p>监听 IP – IP</p><p>监听端口 – Port</p></blockquote><h2 id="V0-2-简单的链接封装和业务绑定"><a href="#V0-2-简单的链接封装和业务绑定" class="headerlink" title="V0.2 简单的链接封装和业务绑定"></a>V0.2 简单的链接封装和业务绑定</h2><blockquote><p>方法</p><p>启动链接 – Start()</p><p>停止链接 – Stop()</p><p>获取当前链接的 conn 对象 (套接字) – GetTCPConnection() *net.TCPConn</p><p>得到链接 ID – GetConnID() uint32</p><p>得到客户端连接的地址和端口 – RemoteAddr() net.TCPAddr</p><p>发送数据的方法 – Send(data []byte) error</p><p>属性<br>socket TCP 套接字 – Conn *net.TCPConn</p><p>链接的 ID – ConnID uint32</p><p>当前链接状态 (是否已经关闭) – isClosed bool</p><p>与当前链接所绑定的处理业务与方法 – handlerAPI ziface.HandleFunc</p><p>等待退出的 channel 管道 – ExitChan chan bool</p></blockquote><h2 id="V0-3-基础的-router-模块"><a href="#V0-3-基础的-router-模块" class="headerlink" title="V0.3 基础的 router 模块"></a>V0.3 基础的 router 模块</h2><blockquote><p>Request 请求封装</p><p>将链接与数据绑定一起</p><p>属性<br>链接的句柄 – GetConnection() IConnection</p><p>请求数据 – GetData() []byte</p><p>方法<br>得到链接– func (r *Request) GetConnection() ziface.IConnection</p><p>得到数据 – func (r *Request) GetData() []byte</p><p>新建一个 Request 请求</p><p>Router 模块</p><p>抽象的 IRouter</p><p>处理业务之前的方法 PreHandle(request IRequest) &#x2F;&#x2F;处理 conn 业务之前的方法</p><p>处理业务的主方法 Handle(request IRequest) &#x2F;&#x2F;处理 conn 业务的主方法</p><p>处理业务之后的方法 PostHandle(request IRequest) &#x2F;&#x2F;处理 conn 业务之后的方法</p><p>具体的 BaseRouter</p><p>处理业务之前的方法 func (br *BaseRouter) PreHandle(request ziface.IRequest)</p><p>处理业务的主方法 func (br *BaseRouter) Handle(request ziface.IRequest)</p><p>处理业务之后的方法 func (br *BaseRouter) PostHandle(request ziface.IRequest)</p><p>zinx 集成 Router 模块</p><p>IServer 增添路由功能 - AddRouter(router IRouter)</p><p>Server 类增加 Router 成员 —&gt; 去掉之前的 HandAPI</p><p>Connection 类绑定一个 Router 成员</p><p>在 Connection 调用已经注册过的 Router 处理业务</p><p>使用 zinxV0.3 版本开发服务器</p><p>1、创建一个服务器句柄</p><p>2、给当前的 zinx 框架加一个自定义的业务路由</p><p>3、启动 server</p><p>4、需要继承 BaseRouter 去实现三个接口的方法</p><p>当前版本只有一个路由能使用，目前只能使用一个路由模块，在加入路由模块会使上一个路由模块方法进行重写覆盖。</p></blockquote><h2 id="V0-4-全局配置模块"><a href="#V0-4-全局配置模块" class="headerlink" title="V0.4 全局配置模块"></a>V0.4 全局配置模块</h2><blockquote><p>路径 ：服务器项目主地址&#x2F;conf&#x2F;zinx.json (用户进行填写)</p><p>创建一个 zinx 的全局配置模块 utils&#x2F;globalobj.go</p><p>初始化后读取用户配置的 zinx.json —&gt; globalobj 对象中对应的 zinx 服务器句柄代码进行参数替换</p><p>提供一个 GlobalObject 对象 — var GlobalObject *GlobalObj</p><p>使用 zinx0.4 版本进行开发</p></blockquote><h2 id="V0-5-消息封装"><a href="#V0-5-消息封装" class="headerlink" title="V0.5 消息封装"></a>V0.5 消息封装</h2><blockquote><p>定义消息的结构 Message</p><p>属性<br>消息的 ID</p><p>消息的长度</p><p>消息的内容</p><p>方法<br>SetMsgId(uint32) &#x2F;&#x2F;设置消息 ID</p><p>SetData([]byte) &#x2F;&#x2F;设置消息内容</p><p>SetDataLen(uint32) &#x2F;&#x2F;设置消息长度</p><p>GetDataLen() uint32 &#x2F;&#x2F;获取消息长度</p><p>GetMsgId() uint32 &#x2F;&#x2F;获取消息 ID</p><p>GetData() []byte &#x2F;&#x2F;获取消息内容</p><p>定义解决 TCP 粘包问题的封包拆包的模块</p><p>针对 Message 进行 TLV 格式的封装 – func (dp *DataPack) Pack(msg ziface.IMessage) ([]byte, error)</p><p>写 Message 的长度</p><p>写 Message 的 ID</p><p>写 Message 的内容</p><p>针对 Message 进行 TLV 格式的拆包 – func (dp *DataPack) Unpack(binaryData []byte) (ziface.IMessage, error)</p><p>先读取固定长度的 head —&gt; 消息的长度和消息的类型</p><p>再根据消息内容的长度，再进行一次读写，从 conn 中读取消息的内容</p><p>将消息封装机制集成到 Zinx 框架中</p><p>将 Message 添加到 Request 属性字段</p><p>修改连接读取数据的机制，将之前的单纯读取 byte 改成拆包形式，读取按照 TLV 形式进行读取</p><p>给链接提供一个发包的机制：将发送的消息打包，再发送</p><p>使用 zinxV0.5 开发</p></blockquote><h2 id="V0-6-多路由模式"><a href="#V0-6-多路由模式" class="headerlink" title="V0.6 多路由模式"></a>V0.6 多路由模式</h2><blockquote><p>消息管理模块(支持多路由 API 调度管理)</p><p>属性</p><p>集合 - 消息 ID 与对应 router 的关系 - map Apis map[uint32]ziface.IRouter</p><p>方法</p><p> 根据 MsgId 来索引调度路由方法 func (mh *MsgHandle) DoMsgHandler(request ziface.IRequest)</p><p> 添加路由方法到 map 集合中 func (mh *MsgHandle) AddRouter(msgID uint32, router ziface.IRouter)</p><p>消息管理模块集成到 Zinx 框架中</p><p>将 server 模块里面的 Router 属性变为 MsgHandle 属性</p><p>将 server 模块中的 AddRouter 修改调用 MsgHandler 的 AddRouter</p><p>将 connection 模块中的 Router 属性替换为 MsgHandle 属性</p><p>将 connection 模块中的 Router 业务调度 Router 的业务改为调度 MsgHandle 调度， 并修改 StartRead 方法</p><p>使用 Zinx V0.6 版本开发</p></blockquote><h2 id="V0-7-读写协程分离-小修改，新增一个-goroutine-即可"><a href="#V0-7-读写协程分离-小修改，新增一个-goroutine-即可" class="headerlink" title="V0.7 读写协程分离(小修改，新增一个 goroutine 即可)"></a>V0.7 读写协程分离(小修改，新增一个 goroutine 即可)</h2><blockquote><p>1、添加一个 Reader 和 Writer 之间通信的 channel</p><p>2、添加一个 Writer Goroutine</p><p>3、Reader 由之前发送给客户端 改成 发送给 通信 Channel</p><p>4、启动 Reader 和 Writer 一同工作</p></blockquote><h2 id="V0-8-消息队列以及多任务"><a href="#V0-8-消息队列以及多任务" class="headerlink" title="V0.8 消息队列以及多任务"></a>V0.8 消息队列以及多任务</h2><blockquote><p>消息队列以及 Worker 工作池的实现</p><pre><code>创建一个消息队列 --- MsgHandler 消息管理模块  消息队列 TaskQueue []chan ziface.IRequest  工作池的数量 WorkPoolSize uint32创建多任务work工作池，并且启动​  创建一个 worker 工作池 :func (mh *MsgHandle) StartWorkerPool() ​  根据 WorkPoolSize 的数量去创建 Worker   每个 worker 都应该用一个 Go 去承载​  1、阻塞等待当前 worker 的对应的 channel 的消息​  2、一旦有消息到来， worker 应该处理当前消息对应的业务​  3、将之前的发送消息，全部改成将消息发送给消息队列和 worker 工作池处理定义一个方法，将消息发送给消息队列工作池的方法   func (mh *MsgHandle) SendMsgToTaskQueue(request ziface.IRequest)将消息队列机制集成到 Zinx 框架中: 1、开启并调用消息队列及 worker 工作池, 保证 workerPool 只有一个，应该在创建 Server模块时候开启(在Server listen 之前添加)2、将从客户端处理的消息，发送给当前的Worker 工作池来处理，在处理完拆包，得到了 request 请求，交给工作池来处理使用 Zinx V0.8 版本开发</code></pre></blockquote><p>小型项目，具体以技术方案跟思考为主，而与需求、产品、测试、运维的沟通可以让步于项目的上线</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zinx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言实现的轻量级IM项目</title>
    <link href="/2022/01/04/go/go-im/"/>
    <url>/2022/01/04/go/go-im/</url>
    
    <content type="html"><![CDATA[<h2 id="使用-go-实现的微型服务器"><a href="#使用-go-实现的微型服务器" class="headerlink" title="使用 go 实现的微型服务器"></a>使用 go 实现的微型服务器</h2><p>项目地址：<a href="https://github.com/chaggle/go-im">https://github.com/chaggle/go-im</a></p><h3 id="V0-1-建立基础的-main-go-server-go，相应功能如下"><a href="#V0-1-建立基础的-main-go-server-go，相应功能如下" class="headerlink" title="V0.1 :建立基础的 main.go server.go，相应功能如下"></a>V0.1 :建立基础的 main.go server.go，相应功能如下</h3><blockquote><p>main 功能主要为创建服务器以及启动服务器</p><p>server 功能有：</p><p>1、创建 server 对象</p><p>2、启动 Server 服务(TCP socket 套接字)</p><p>3、处理链接的业务</p></blockquote><h3 id="V0-2-用户上线功能"><a href="#V0-2-用户上线功能" class="headerlink" title="V0.2 :用户上线功能"></a>V0.2 :用户上线功能</h3><blockquote><p>user 功能新增</p><p>1、创建 user 对象</p><p>2、监听每个 user 对应的 channel 的消息</p><p>server 新增功能</p><p>1、新增 OnlineMap 与 Message 属性</p><p>2、在处理客户端上线的 Handler 创建并添加用户（使用到 OS 中的同步 Lock ）</p><p>3、新增广播消息方法以及监听广播消息的 channel 方法</p></blockquote><h3 id="V0-3-用户消息广播机制完善"><a href="#V0-3-用户消息广播机制完善" class="headerlink" title="V0.3 :用户消息广播机制完善"></a>V0.3 :用户消息广播机制完善</h3><blockquote><p>server 新增功能</p><p>1、完善 handle 模块处处理业务的方法，启动一个针对与当前客户端的读 goroutine</p></blockquote><h3 id="V0-4-用户业务层封装"><a href="#V0-4-用户业务层封装" class="headerlink" title="V0.4 :用户业务层封装"></a>V0.4 :用户业务层封装</h3><blockquote><p>对于用户层业务的层次化、模块化</p><p>server 中的 user 业务进行迁移</p><p>1、server 关联</p><p>2、新增 Online、Offline、Domessage 方法</p></blockquote><h3 id="V0-5-查询用户名以及用户名修改"><a href="#V0-5-查询用户名以及用户名修改" class="headerlink" title="V0.5 :查询用户名以及用户名修改"></a>V0.5 :查询用户名以及用户名修改</h3><blockquote><p>user 新增两个功能，</p><p>1、用户名查询的功能</p><p>2、用户名修改的功能，保证每个用户名唯一</p></blockquote><h3 id="V0-6-超时强制下线以及私聊功能"><a href="#V0-6-超时强制下线以及私聊功能" class="headerlink" title="V0.6 :超时强制下线以及私聊功能"></a>V0.6 :超时强制下线以及私聊功能</h3><blockquote><p>user 新增两个功能，</p><p>1、设置定时器，超时强制剔除，发消息代表活跃，长时间不发消息代表超时，即强制关闭用户连接</p><p>2、私聊功能，通过获取用户名队列中的用户名，来向用户发起私聊</p></blockquote><h3 id="V1-0-、v1-1-客户端基本功能"><a href="#V1-0-、v1-1-客户端基本功能" class="headerlink" title="V1.0 、v1.1 :客户端基本功能"></a>V1.0 、v1.1 :客户端基本功能</h3><blockquote><p>新增 client 客户端，当然并非 GUI 界面版本，也可以使用带 GUI 界面版本，满足通信协议即可</p><p>1、连接建立功能、命令行解析功能</p><p>2、客户端菜单功能的预写</p></blockquote><h3 id="V1-2-客户端的相应基本请求"><a href="#V1-2-客户端的相应基本请求" class="headerlink" title="V1.2 :客户端的相应基本请求"></a>V1.2 :客户端的相应基本请求</h3><blockquote><p>client 新增</p><p>1、用户名修改请求，通过 io.copy() 阻塞监听的方式进行回显输出</p><p>2、用户进入公聊模式，进行消息的广播与退出公聊模式</p><p>3、用户进行私聊模式，选择用户功能封装以及单独对其发送消息</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Instant Messaging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 91 1206. 设计跳表</title>
    <link href="/2021/12/09/Leetcode/91-day/day-91/"/>
    <url>/2021/12/09/Leetcode/91-day/day-91/</url>
    
    <content type="html"><![CDATA[<h1 id="1206-设计跳表"><a href="#1206-设计跳表" class="headerlink" title="1206. 设计跳表"></a><strong><a href="https://leetcode-cn.com/problems/design-skiplist/">1206. 设计跳表</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">不使用任何库函数，设计一个跳表。</span><br><span class="line"></span><br><span class="line">跳表是在 <span class="built_in">O</span>(<span class="built_in">log</span>(n)) 时间内完成增加、删除、搜索操作的数据结构。</span><br><span class="line"></span><br><span class="line">跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</span><br><span class="line"></span><br><span class="line">例如，一个跳表包含 [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">90</span>]，然后增加 <span class="number">80</span>、<span class="number">45</span> 到跳表中，以下图的方式操作：</span><br><span class="line"></span><br><span class="line">跳表中有很多层，每一层是一个短的链表。</span><br><span class="line"></span><br><span class="line">在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <span class="built_in">O</span>(n)。</span><br><span class="line"></span><br><span class="line">跳表的每一个操作的平均时间复杂度是 <span class="built_in">O</span>(<span class="built_in">log</span>(n))，空间复杂度是 <span class="built_in">O</span>(n)。</span><br><span class="line"></span><br><span class="line">在本题中，你的设计应该要包含这些函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> : 返回target是否存在于跳表中。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">void add(int num): 插入一个元素到跳表。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回 false.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果存在多个 num ，删除其中任意一个即可。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">了解更多 : https://en.wikipedia.org/wiki/Skip_list</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">样例:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Skiplist skiplist =</span> <span class="keyword">new</span> <span class="built_in">Skiplist</span>();</span><br><span class="line"></span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line">skiplist.<span class="built_in">search</span>(<span class="number">0</span>);   <span class="comment">// 返回 false</span></span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">4</span>);</span><br><span class="line">skiplist.<span class="built_in">search</span>(<span class="number">1</span>);   <span class="comment">// 返回 true</span></span><br><span class="line">skiplist.<span class="built_in">erase</span>(<span class="number">0</span>);    <span class="comment">// 返回 false，0 不在跳表中</span></span><br><span class="line">skiplist.<span class="built_in">erase</span>(<span class="number">1</span>);    <span class="comment">// 返回 true</span></span><br><span class="line">skiplist.<span class="built_in">search</span>(<span class="number">1</span>);   <span class="comment">// 返回 false，1 已被擦除</span></span><br><span class="line">约束条件:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= num, target &lt;= <span class="number">20000</span></span><br><span class="line">最多调用 <span class="number">50000</span> 次 search, add, 以及 erase操作。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、没啥时间重新写一个vector，现在偷点懒用一下vector的库函数。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    vector&lt;Node*&gt; nexts;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> level,<span class="type">int</span> k) : <span class="built_in">nexts</span>(level + <span class="number">1</span>),<span class="built_in">key</span>(k) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="type">int</span> allLevel = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Skiplist</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">31</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curLevel = allLevel; curLevel &gt;= <span class="number">0</span>; curLevel--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur -&gt; nexts[curLevel] &amp;&amp; cur -&gt; nexts[curLevel] -&gt; key &lt; key) &#123;</span><br><span class="line">                cur = cur -&gt; nexts[curLevel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; nexts[curLevel] &amp;&amp; cur -&gt; nexts[curLevel] -&gt; key == key) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> newLevel = <span class="built_in">getLevel</span>();</span><br><span class="line">        allLevel = <span class="built_in">max</span>(allLevel, newLevel);</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(newLevel, key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curLevel = allLevel; curLevel &gt;= <span class="number">0</span>; curLevel--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur -&gt; nexts[curLevel] &amp;&amp; cur -&gt; nexts[curLevel] -&gt; key &lt; key)&#123;</span><br><span class="line">                cur = cur -&gt; nexts[curLevel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curLevel &lt;= newLevel)</span><br><span class="line">            &#123;</span><br><span class="line">                newNode -&gt; nexts[curLevel] = cur -&gt; nexts[curLevel];</span><br><span class="line">                cur -&gt; nexts[curLevel] = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curLevel = allLevel; curLevel &gt;= <span class="number">0</span>; curLevel--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur -&gt; nexts[curLevel] &amp;&amp; cur -&gt; nexts[curLevel] -&gt; key &lt; key) &#123;</span><br><span class="line">                cur = cur -&gt; nexts[curLevel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur -&gt; nexts[curLevel] &amp;&amp; cur -&gt; nexts[curLevel] -&gt; key == key) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                Node* tmp = cur -&gt; nexts[curLevel] -&gt; nexts[curLevel];</span><br><span class="line">                cur -&gt; nexts[curLevel] -&gt; nexts[curLevel] = <span class="literal">nullptr</span>;</span><br><span class="line">                cur -&gt; nexts[curLevel] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans &lt; <span class="number">32</span> &amp;&amp; <span class="built_in">rand</span>() &lt; RAND_MAX * <span class="number">0.25</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Skiplist object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Skiplist* obj = new Skiplist();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;search(target);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;erase(num);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n ^ 2)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skip List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 90 1054. 距离相等的条形码</title>
    <link href="/2021/12/08/Leetcode/91-day/day-90/"/>
    <url>/2021/12/08/Leetcode/91-day/day-90/</url>
    
    <content type="html"><![CDATA[<h1 id="1054-距离相等的条形码"><a href="#1054-距离相等的条形码" class="headerlink" title="1054. 距离相等的条形码"></a><strong><a href="https://leetcode-cn.com/problems/distant-barcodes/">1054. 距离相等的条形码</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。</span><br><span class="line"></span><br><span class="line">请你重新排列这些条形码，使其中两个相邻的条形码 不能相等。 </span><br><span class="line"></span><br><span class="line">你可以返回任何满足该要求的答案，此题保证存在答案。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= barcodes.length &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">1</span> &lt;= barcodes[i] &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、每次取最大堆中的两个对子，然后进行间隔插入即可.</li><li>2、最后两日了，明天打卡 91 日后，要考试了，所以停止更新。直到 12 月 30 日开始，重头复盘 91 日，每日复盘 4 题左右，顺便开始阅读相应的论文，并展开研究型的工作。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = barcodes.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; up;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : barcodes) up[i]++;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [x, fx] : up) ans.<span class="built_in">push_back</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;x, fx&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), </span><br><span class="line">        [&amp;](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [x, fx] : ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; fx; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= n) m = <span class="number">1</span>;</span><br><span class="line">                res[m] = x;</span><br><span class="line">                m += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 89 378. 有序矩阵中第 K 小的元素</title>
    <link href="/2021/12/07/Leetcode/91-day/day-89/"/>
    <url>/2021/12/07/Leetcode/91-day/day-89/</url>
    
    <content type="html"><![CDATA[<h1 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><strong><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</span><br><span class="line">请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">15</span>]], k = <span class="number">8</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：矩阵中的元素为 [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">15</span>]，第 <span class="number">8</span> 小元素是 <span class="number">13</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[<span class="number">-5</span>]], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-5</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">300</span></span><br><span class="line"><span class="number">-109</span> &lt;= matrix[i][j] &lt;= <span class="number">109</span></span><br><span class="line">题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列</span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= n^<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、题目中最合适的办法理应是二分的思想。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> mid, <span class="type">int</span> k, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = n - <span class="number">1</span>, j = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt;= mid)</span><br><span class="line">            &#123;</span><br><span class="line">                num += i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = matrix[<span class="number">0</span>][<span class="number">0</span>], r = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(matrix, mid, k, n)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 88 451. 根据字符出现频率排序</title>
    <link href="/2021/12/06/Leetcode/91-day/day-88/"/>
    <url>/2021/12/06/Leetcode/91-day/day-88/</url>
    
    <content type="html"><![CDATA[<h1 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451. 根据字符出现频率排序"></a><strong><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line"><span class="string">&quot;tree&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;eert&quot;</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="string">&#x27;e&#x27;</span>出现两次，<span class="string">&#x27;r&#x27;</span>和<span class="string">&#x27;t&#x27;</span>都只出现一次。</span><br><span class="line">因此<span class="string">&#x27;e&#x27;</span>必须出现在<span class="string">&#x27;r&#x27;</span>和<span class="string">&#x27;t&#x27;</span>之前。此外，<span class="string">&quot;eetr&quot;</span>也是一个有效的答案。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line"><span class="string">&quot;cccaaa&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;cccaaa&quot;</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="string">&#x27;c&#x27;</span>和<span class="string">&#x27;a&#x27;</span>都出现三次。此外，<span class="string">&quot;aaaccc&quot;</span>也是有效的答案。</span><br><span class="line">注意<span class="string">&quot;cacaca&quot;</span>是不正确的，因为相同的字母必须放在一起。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line"><span class="string">&quot;Aabb&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;bbAa&quot;</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，<span class="string">&quot;bbaA&quot;</span>也是一个有效的答案，但<span class="string">&quot;Aabb&quot;</span>是不正确的。</span><br><span class="line">注意<span class="string">&#x27;A&#x27;</span>和<span class="string">&#x27;a&#x27;</span>被认为是两种不同的字符。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、如题目所说，手写一个 cmp 函数然后按照其中排序，返回其值即可。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; up;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s) up[i]++;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> <span class="type">char</span> &amp;a, <span class="type">const</span> <span class="type">char</span> &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> up[a] == up[b] ? a &gt; b : up[a] &gt; up[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 87 23. 合并K个升序链表</title>
    <link href="/2021/12/05/Leetcode/91-day/day-87/"/>
    <url>/2021/12/05/Leetcode/91-day/day-87/</url>
    
    <content type="html"><![CDATA[<h1 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><strong><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表数组，每个链表都已经按升序排列。</span><br><span class="line"></span><br><span class="line">请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">k == lists.length</span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line"><span class="number">0</span> &lt;= lists[i].length &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">-10</span>^<span class="number">4</span> &lt;= lists[i][j] &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 <span class="number">10</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题目 day69 日有使用分治的思想做题，今日使用大顶堆解决问题。（非手写堆，这两日时间花费有些多，故今日不写）</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> min = [](ListNode *a, ListNode *b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a -&gt; val &gt; b -&gt; val;</span><br><span class="line">            &#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(min)&gt; <span class="built_in">ans</span>(min);</span><br><span class="line">        <span class="keyword">auto</span> *root = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:  lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) ans.<span class="built_in">push</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!ans.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = ans.<span class="built_in">top</span>(); ans.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(tmp -&gt; next != <span class="literal">nullptr</span>) ans.<span class="built_in">push</span>(tmp-&gt;next);</span><br><span class="line">            tmp -&gt; next = cur -&gt; next;</span><br><span class="line">            cur -&gt; next = tmp;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 86 1046. 最后一块石头的重量</title>
    <link href="/2021/12/04/Leetcode/91-day/day-86/"/>
    <url>/2021/12/04/Leetcode/91-day/day-86/</url>
    
    <content type="html"><![CDATA[<h1 id="1046-最后一块石头的重量"><a href="#1046-最后一块石头的重量" class="headerlink" title="1046. 最后一块石头的重量"></a><strong><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">有一堆石头，每块石头的重量都是正整数。</span><br><span class="line"></span><br><span class="line">每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。</span><br><span class="line"></span><br><span class="line">假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</span><br><span class="line"></span><br><span class="line">如果 x == y，那么两块石头都会被完全粉碎；</span><br><span class="line"></span><br><span class="line">如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</span><br><span class="line"></span><br><span class="line">最后，最多只会剩下一块石头。</span><br><span class="line"></span><br><span class="line">返回此石头的重量。如果没有石头剩下，就返回 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">先选出 <span class="number">7</span> 和 <span class="number">8</span>，得到 <span class="number">1</span>，所以数组转换为 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">再选出 <span class="number">2</span> 和 <span class="number">4</span>，得到 <span class="number">2</span>，所以数组转换为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">接着是 <span class="number">2</span> 和 <span class="number">1</span>，得到 <span class="number">1</span>，所以数组转换为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，</span><br><span class="line">最后选出 <span class="number">1</span> 和 <span class="number">1</span>，得到 <span class="number">0</span>，最终数组转换为 [<span class="number">1</span>]，这就是最后剩下那块石头的重量。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= stones.length &lt;= <span class="number">30</span></span><br><span class="line"><span class="number">1</span> &lt;= stones[i] &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、今日仍为最大堆的使用办法，拒绝使用库函数自己写。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildmaxheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> i, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = stones[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; n; j = <span class="number">2</span> * j + <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; stones[j] &lt; stones[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (p &gt;= stones[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                stones[i] = stones[j];</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stones[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max1, max2;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">buildmaxheap</span>(stones, i, n);</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max1 = stones[<span class="number">0</span>];</span><br><span class="line">            stones[<span class="number">0</span>] = stones[--n];</span><br><span class="line">            <span class="built_in">buildmaxheap</span>(stones, <span class="number">0</span>, n);</span><br><span class="line">            max2 = stones[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (max1 == max2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> stones[<span class="number">0</span>] = stones[--n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> stones[<span class="number">0</span>] = <span class="built_in">abs</span>(max1 - max2);</span><br><span class="line">            <span class="built_in">buildmaxheap</span>(stones, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 85 215. 数组中的第K个最大元素</title>
    <link href="/2021/12/03/Leetcode/91-day/day-85/"/>
    <url>/2021/12/03/Leetcode/91-day/day-85/</url>
    
    <content type="html"><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</span><br><span class="line"></span><br><span class="line">请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">10</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、今日题目是很好的题目，一个复习快排的思想，一个复习如何建立堆。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;ans, <span class="type">int</span> i, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, max = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; ans[l] &gt; ans[max]) max = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; ans[r] &gt; ans[max]) max = r;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (max != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(ans[i], ans[max]);</span><br><span class="line">            <span class="built_in">heap_sort</span>(ans, max, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ans, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) <span class="built_in">heap_sort</span>(ans, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">buildHeap</span>(nums, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            --n;</span><br><span class="line">            <span class="built_in">heap_sort</span>(nums, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(logn)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 83-84 28. 实现 strStr()</title>
    <link href="/2021/12/02/Leetcode/91-day/day-84/"/>
    <url>/2021/12/02/Leetcode/91-day/day-84/</url>
    
    <content type="html"><![CDATA[<h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><strong><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">实现 <span class="built_in">strStr</span>() 函数。</span><br><span class="line"></span><br><span class="line">给你两个字符串 haystack 和 needle 在 haystack 字符串中</span><br><span class="line"></span><br><span class="line">找出 needle 字符串出现的第一个位置（下标从 <span class="number">0</span> 开始）。</span><br><span class="line"></span><br><span class="line">如果不存在，则返回  <span class="number">-1</span> 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">当 needle 是空字符串时我们应当返回什么值呢？</span><br><span class="line"></span><br><span class="line">对于本题而言，当 needle 是空字符串时我们应当返回 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line">这与 C 语言的 <span class="built_in">strstr</span>() 以及 Java 的 <span class="built_in">indexOf</span>() 定义相符。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：haystack = <span class="string">&quot;hello&quot;</span>, needle = <span class="string">&quot;ll&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：haystack = <span class="string">&quot;aaaaa&quot;</span>, needle = <span class="string">&quot;bba&quot;</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：haystack = <span class="string">&quot;&quot;</span>, needle = <span class="string">&quot;&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= haystack.length, needle.length &lt;= <span class="number">5</span> * <span class="number">104</span></span><br><span class="line">haystack 和 needle 仅由小写英文字符组成</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、经典一看，发现是 KMP 算法的喜悦，将 haystack 替换为 s 主串，needle 替换为模式串。</li><li>2、昨日 BF 今日 KMP，我刚好相反。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//KMP</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BF算法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">                i = l;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(m + n) &#x2F;&#x2F; KMP</li><li>空间复杂度：O(m + n) &#x2F;&#x2F; KMP</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 82 47. 全排列 II</title>
    <link href="/2021/11/30/Leetcode/91-day/day-82/"/>
    <url>/2021/11/30/Leetcode/91-day/day-82/</url>
    
    <content type="html"><![CDATA[<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><strong><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">8</span></span><br><span class="line"><span class="number">-10</span> &lt;= nums[i] &lt;= <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、回溯法，只不过今日的较为简单</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; res</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j] || (j &gt; <span class="number">0</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; !vis[j - <span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(nums[j]);</span><br><span class="line">            vis[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, ans, i + <span class="number">1</span>, res);</span><br><span class="line">            vis[j] = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, ans, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O($2 ^ n * n$)</li><li>空间复杂度：O($n$)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 81 40. 组合总和 II</title>
    <link href="/2021/11/29/Leetcode/91-day/day-81/"/>
    <url>/2021/11/29/Leetcode/91-day/day-81/</url>
    
    <content type="html"><![CDATA[<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><strong><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 candidates 和一个目标数 target </span><br><span class="line"></span><br><span class="line">找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的每个数字在每个组合中只能使用一次。</span><br><span class="line"></span><br><span class="line">注意：解集不能包含重复的组合。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= candidates.length &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">1</span> &lt;= candidates[i] &lt;= <span class="number">50</span></span><br><span class="line"><span class="number">1</span> &lt;= target &lt;= <span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、同昨日一样的回溯法，看leetcode官方解答可以使用pair存储，但是其实与存储缓存过程中的数据类型 vector<int> 是一样的。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n &amp;&amp; target - res[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; res[i] == res[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(res[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(i + <span class="number">1</span>, target - res[i]);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">this</span> -&gt; res = candidates;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O($2 ^ n * n$)</li><li>空间复杂度：O($n$)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 80 39. 组合总和</title>
    <link href="/2021/11/29/Leetcode/91-day/day-80/"/>
    <url>/2021/11/29/Leetcode/91-day/day-80/</url>
    
    <content type="html"><![CDATA[<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><strong><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的正整数数组 candidates 和一个正整数 target</span><br><span class="line"></span><br><span class="line">找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </span><br><span class="line"></span><br><span class="line">对于给定的输入，保证和为 target 的唯一组合数少于 <span class="number">150</span> 个。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">输出: [[<span class="number">7</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span></span><br><span class="line">输出: [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">2</span>], target = <span class="number">1</span></span><br><span class="line">输出: []</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">1</span>], target = <span class="number">1</span></span><br><span class="line">输出: [[<span class="number">1</span>]]</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入: candidates = [<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= candidates.length &lt;= <span class="number">30</span></span><br><span class="line"><span class="number">1</span> &lt;= candidates[i] &lt;= <span class="number">200</span></span><br><span class="line">candidate 中的每个元素都是独一无二的。</span><br><span class="line"><span class="number">1</span> &lt;= target &lt;= <span class="number">500</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、经典递归算法</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, </span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; combine, <span class="type">int</span> idx</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(s)</li><li>空间复杂度：O(target)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 79 814. 二叉树剪枝</title>
    <link href="/2021/11/26/Leetcode/91-day/day-79/"/>
    <url>/2021/11/26/Leetcode/91-day/day-79/</url>
    
    <content type="html"><![CDATA[<h1 id="814-二叉树剪枝"><a href="#814-二叉树剪枝" class="headerlink" title="814. 二叉树剪枝"></a><strong><a href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">给你二叉树的根结点 root ，此外树的每个结点的值要么是 <span class="number">0</span> ，要么是 <span class="number">1</span> 。</span><br><span class="line"></span><br><span class="line">返回移除了所有不包含 <span class="number">1</span> 的子树的原二叉树。</span><br><span class="line"></span><br><span class="line">节点 node 的子树为 node 本身加上所有 node 的后代。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,null,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,null,<span class="number">0</span>,null,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line">只有红色节点满足条件“所有不包含 <span class="number">1</span> 的子树”。 右图为返回的答案。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,null,<span class="number">1</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,null,<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">1</span>, <span class="number">200</span>] 内</span><br><span class="line">Node.val 为 <span class="number">0</span> 或 <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、二叉树递归的想法。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">dfs</span>(root -&gt; left);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(!l) root -&gt; left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r) root -&gt; right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> root -&gt; val + l + r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root) != <span class="number">0</span> ? root : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tree</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 78 1319. 连通网络的操作次数</title>
    <link href="/2021/11/26/Leetcode/91-day/day-78/"/>
    <url>/2021/11/26/Leetcode/91-day/day-78/</url>
    
    <content type="html"><![CDATA[<h1 id="1319-连通网络的操作次数"><a href="#1319-连通网络的操作次数" class="headerlink" title="1319. 连通网络的操作次数"></a><strong><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 <span class="number">0</span> 到 n<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。</span><br><span class="line"></span><br><span class="line">网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</span><br><span class="line"></span><br><span class="line">给你这个计算机网络的初始布线 connections，</span><br><span class="line"></span><br><span class="line">你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。</span><br><span class="line"></span><br><span class="line">请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 <span class="number">-1</span> 。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">4</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：拔下计算机 <span class="number">1</span> 和 <span class="number">2</span> 之间的线缆，并将它插到计算机 <span class="number">1</span> 和 <span class="number">3</span> 上。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">6</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">6</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：线缆数量不足。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">5</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= connections.length &lt;= <span class="built_in">min</span>(n*(n<span class="number">-1</span>)/<span class="number">2</span>, <span class="number">10</span>^<span class="number">5</span>)</span><br><span class="line">connections[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">0</span> &lt;= connections[i][<span class="number">0</span>], connections[i][<span class="number">1</span>] &lt; n</span><br><span class="line">connections[i][<span class="number">0</span>] != connections[i][<span class="number">1</span>]</span><br><span class="line">没有重复的连接。</span><br><span class="line">两台计算机不会通过多条线缆连接。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、昨日说法</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Djset</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  <span class="comment">// 记录节点的根</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;  <span class="comment">// 记录根节点的深度（用于优化）</span></span><br><span class="line">    <span class="type">int</span> count;         <span class="comment">// 记录连通分量的个数</span></span><br><span class="line">    <span class="type">int</span> rest;          <span class="comment">// 记录多余的连接数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Djset</span>(<span class="type">int</span> n): <span class="built_in">parent</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)), <span class="built_in">rank</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)), <span class="built_in">count</span>(n), <span class="built_in">rest</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 压缩方式：直接指向根节点</span></span><br><span class="line">        <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootx = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rooty = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="comment">// 按秩合并</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(rootx, rooty);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] == rank[rooty]) rank[rootx] += <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rest++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">makeConnected</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="function">Djset <span class="title">ds</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e :connections) &#123;</span><br><span class="line">            ds.<span class="built_in">merge</span>(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ds.<span class="built_in">getRest</span>() &lt; ds.<span class="built_in">getCount</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ds.<span class="built_in">getCount</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O($n^2$)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UnionFind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 77 924. 尽量减少恶意软件的传播</title>
    <link href="/2021/11/25/Leetcode/91-day/day-77/"/>
    <url>/2021/11/25/Leetcode/91-day/day-77/</url>
    
    <content type="html"><![CDATA[<h1 id="924-尽量减少恶意软件的传播"><a href="#924-尽量减少恶意软件的传播" class="headerlink" title="924. 尽量减少恶意软件的传播"></a><strong><a href="https://leetcode-cn.com/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">在节点网络中，只有当 graph[i][j] = <span class="number">1</span> 时，每个节点 i 能够直接连接到另一个节点 j。</span><br><span class="line"></span><br><span class="line">一些节点 initial 最初被恶意软件感染。</span><br><span class="line"></span><br><span class="line">只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。</span><br><span class="line"></span><br><span class="line">这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</span><br><span class="line"></span><br><span class="line">假设 <span class="built_in">M</span>(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</span><br><span class="line"></span><br><span class="line">如果从初始列表中移除某一节点能够最小化 <span class="built_in">M</span>(initial)，</span><br><span class="line"></span><br><span class="line">返回该节点。如果有多个节点满足条件，就返回索引最小的节点。</span><br><span class="line"></span><br><span class="line">请注意，如果某个节点已从受感染节点的列表 initial 中删除，</span><br><span class="line"></span><br><span class="line">它以后可能仍然因恶意软件传播而受到感染。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：graph = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]], initial = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：graph = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]], initial = [<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：graph = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], initial = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt; graph.length = graph[<span class="number">0</span>].length &lt;= <span class="number">300</span></span><br><span class="line"><span class="number">0</span> &lt;= graph[i][j] == graph[j][i] &lt;= <span class="number">1</span></span><br><span class="line">graph[i][i] == <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &lt;= initial.length &lt; graph.length</span><br><span class="line"><span class="number">0</span> &lt;= initial[i] &lt; graph.length</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、有些小难，首先要计算当前 graph 图中的连通分量块，以及连通块的大小</li><li>2、然后计算 initial 表中的每个分量块的大小</li><li>3、连通分量块为1的时候，搜索该块在原表中的实际大小，找到最大的块进行删除即可得到最少的感染节点，块大小相等时返回索引最小的点</li><li>4、不存在连通分量块为1的情况，返回initial中最小值</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cnt; <span class="comment">// 每个节点连通块大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* int root = x;</span></span><br><span class="line"><span class="comment">        while (data[root] &gt;= 0) root = data[root];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //路径压缩</span></span><br><span class="line"><span class="comment">        while (x != root) &#123;</span></span><br><span class="line"><span class="comment">            int tmp = data[x]; //tmp 指向 x 的父节点</span></span><br><span class="line"><span class="comment">            data[x] = root;   //挂到根节点下</span></span><br><span class="line"><span class="comment">            x = tmp;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return root; //返回根节点的编号。 */</span></span><br><span class="line">        <span class="comment">//上述的优化会超时！</span></span><br><span class="line">        <span class="keyword">if</span>(data[x] != x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(data[x]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        data[p] = q;</span><br><span class="line">        <span class="keyword">if</span> (p != q) &#123;</span><br><span class="line">            cnt[q] += cnt[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetCnt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">        UnionFind u;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>(), m = graph[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        u.<span class="built_in">init</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(initial.<span class="built_in">begin</span>(), initial.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] == <span class="number">1</span>) u.<span class="built_in">Union</span>(i, j);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算initial中共连通块元素个数</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : initial) &#123;</span><br><span class="line">            count[u.<span class="built_in">find</span>(c)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : initial) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[u.<span class="built_in">find</span>(c)] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> size = u.<span class="built_in">GetCnt</span>(c);</span><br><span class="line">                <span class="keyword">if</span> (size &gt; res) &#123;</span><br><span class="line">                    res = size;</span><br><span class="line">                    ans = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="keyword">return</span> initial[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O($n^2$)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UnionFind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 76 547. 省份数量</title>
    <link href="/2021/11/24/Leetcode/91-day/day-76/"/>
    <url>/2021/11/24/Leetcode/91-day/day-76/</url>
    
    <content type="html"><![CDATA[<h1 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><strong><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">有 n 个城市，其中一些彼此相连，另一些没有相连。</span><br><span class="line"></span><br><span class="line">如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</span><br><span class="line"></span><br><span class="line">省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</span><br><span class="line"></span><br><span class="line">给你一个 n x n 的矩阵 isConnected ，</span><br><span class="line"></span><br><span class="line">其中 isConnected[i][j] = <span class="number">1</span> 表示第 i 个城市和第 j 个城市直接相连，</span><br><span class="line"></span><br><span class="line">而 isConnected[i][j] = <span class="number">0</span> 表示二者不直接相连。</span><br><span class="line"></span><br><span class="line">返回矩阵中 省份 的数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：isConnected = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：isConnected = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">200</span></span><br><span class="line">n == isConnected.length</span><br><span class="line">n == isConnected[i].length</span><br><span class="line">isConnected[i][j] 为 <span class="number">1</span> 或 <span class="number">0</span></span><br><span class="line">isConnected[i][i] == <span class="number">1</span></span><br><span class="line">isConnected[i][j] == isConnected[j][i]</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、刚好考研今年也新增并查集的学习，所以本次刚好可以复习一下UnionFind class 的相应的写法。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; data; <span class="comment">//存储父节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">//记录数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> root = x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(data[root] &gt;= <span class="number">0</span>) root = data[root];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">while</span>(x != root) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = data[x]; <span class="comment">//tmp 指向 x 的父节点</span></span><br><span class="line">            data[x] = root;   <span class="comment">//挂到根节点下</span></span><br><span class="line">            x = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//返回根节点的编号。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isconnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p != q) &#123;</span><br><span class="line">            data[p] = q;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">count</span>(x) == <span class="number">0</span>) &#123;</span><br><span class="line">            data[x] = <span class="number">-1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        UnionFind u;</span><br><span class="line">        <span class="type">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            u.<span class="built_in">add</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j]) u.<span class="built_in">merge</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.<span class="built_in">getCnt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O($n^2$ * logn)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UnionFind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 75 面试题 17.17. 多次搜索</title>
    <link href="/2021/11/23/Leetcode/91-day/day-75/"/>
    <url>/2021/11/23/Leetcode/91-day/day-75/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题-17-17-多次搜索"><a href="#面试题-17-17-多次搜索" class="headerlink" title="面试题 17.17. 多次搜索"></a><strong><a href="https://leetcode-cn.com/problems/multi-search-lcci/">面试题 17.17. 多次搜索</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个较长字符串big和一个包含较短字符串的数组smalls，</span><br><span class="line"></span><br><span class="line">设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。</span><br><span class="line"></span><br><span class="line">输出smalls中的字符串在big里出现的所有位置positions，</span><br><span class="line"></span><br><span class="line">其中positions[i]为smalls[i]出现的所有位置。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">big = <span class="string">&quot;mississippi&quot;</span></span><br><span class="line">smalls = [<span class="string">&quot;is&quot;</span>,<span class="string">&quot;ppi&quot;</span>,<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;sis&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;ssippi&quot;</span>]</span><br><span class="line">输出： [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">8</span>],[],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>],[<span class="number">5</span>]]</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">len</span>(big) &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">len</span>(smalls[i]) &lt;= <span class="number">1000</span></span><br><span class="line">smalls的总字符数不会超过 <span class="number">100000</span>。</span><br><span class="line">你可以认为smalls中没有重复字符串。</span><br><span class="line">所有出现的字符均为英文小写字母。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、Tire 树经典方法，明年 1 月份再博客再进行复盘，讲述一步一步的思路。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">multiSearch</span>(string big, vector&lt;string&gt;&amp; smalls) &#123;</span><br><span class="line">        Trie* root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="type">int</span> n = smalls.<span class="built_in">size</span>(), m = big.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            Trie* p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> s : smalls[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p -&gt; next[s - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    Trie* q = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                    p -&gt; next[s - <span class="string">&#x27;a&#x27;</span>] = q;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p -&gt; next[s - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            p -&gt; index = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) </span><br><span class="line">        &#123;</span><br><span class="line">            Trie* p = root;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; p -&gt; next[big[j] - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                p = p -&gt; next[big[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (p -&gt; index != <span class="number">-1</span>)</span><br><span class="line">                    ans[p -&gt; index].<span class="built_in">push_back</span>(i);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n * m * c)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 74 677. 键值映射</title>
    <link href="/2021/11/22/Leetcode/91-day/day-74/"/>
    <url>/2021/11/22/Leetcode/91-day/day-74/</url>
    
    <content type="html"><![CDATA[<h1 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><strong><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">实现一个 MapSum 类，支持两个方法，insert 和 sum：</span><br><span class="line"></span><br><span class="line"><span class="built_in">MapSum</span>() 初始化 MapSum 对象</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(String key, <span class="type">int</span> val)</span> 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> 返回所有以该前缀 prefix 开头的键 key 的值的总和。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入：</span></span><br><span class="line"><span class="function">[&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]</span></span><br><span class="line"><span class="function">[[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]</span></span><br><span class="line"><span class="function">输出：</span></span><br><span class="line"><span class="function">[null, null, 3, null, 5]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">解释：</span></span><br><span class="line"><span class="function">MapSum mapSum </span>= <span class="keyword">new</span> <span class="built_in">MapSum</span>();</span><br><span class="line">mapSum.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>);  </span><br><span class="line">mapSum.<span class="built_in">sum</span>(<span class="string">&quot;ap&quot;</span>);           <span class="comment">// return 3 (apple = 3)</span></span><br><span class="line">mapSum.<span class="built_in">insert</span>(<span class="string">&quot;app&quot;</span>, <span class="number">2</span>);    </span><br><span class="line">mapSum.<span class="built_in">sum</span>(<span class="string">&quot;ap&quot;</span>);           <span class="comment">// return 5 (apple + app = 3 + 2 = 5)</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= key.length, prefix.length &lt;= <span class="number">50</span></span><br><span class="line">key 和 prefix 仅由小写英文字母组成</span><br><span class="line"><span class="number">1</span> &lt;= val &lt;= <span class="number">1000</span></span><br><span class="line">最多调用 <span class="number">50</span> 次 insert 和 sum</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、最简单方法直接使用cpp的四大容器组件即可中，但是由于是学习trie树的使用,所以使用tire来构建</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3000</span>;</span><br><span class="line"><span class="type">int</span> ans[N][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MapSum</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans); <span class="comment">// 也可以使用动态数组进行i</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : key) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q = i - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ans[p][q]) ans[p][q] = ++idx;</span><br><span class="line">            p = ans[p][q];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[p] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : prefix) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q = i - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ans[p][q]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            p = ans[p][q];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = cnt[p];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            res += <span class="built_in">dfs</span>(ans[p][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MapSum* obj = new MapSum();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(key,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sum(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n * m * C)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 73 208. 实现 Trie (前缀树)</title>
    <link href="/2021/11/21/Leetcode/91-day/day-73/"/>
    <url>/2021/11/21/Leetcode/91-day/day-73/</url>
    
    <content type="html"><![CDATA[<h1 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><strong><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Trie（发音类似 <span class="string">&quot;try&quot;</span>）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。</span><br><span class="line"></span><br><span class="line">这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</span><br><span class="line"></span><br><span class="line">请你实现 Trie 类：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Trie</span>() 初始化前缀树对象。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(String word)</span> 向前缀树中插入字符串 word 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">boolean <span class="title">search</span><span class="params">(String word)</span> 如果字符串 word 在前缀树中, 返回 <span class="literal">true</span></span>; 否则，返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="function">boolean <span class="title">startsWith</span><span class="params">(String prefix)</span> 如果之前已经插入的字符串 word 的前缀之一，返回 <span class="literal">true</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入</span></span><br><span class="line"><span class="function">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span></span><br><span class="line"><span class="function">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span></span><br><span class="line"><span class="function">输出</span></span><br><span class="line"><span class="function">[null, null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, null, <span class="literal">true</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">解释</span></span><br><span class="line"><span class="function">Trie trie </span>= <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">trie.<span class="built_in">insert</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 True</span></span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 False</span></span><br><span class="line">trie.<span class="built_in">startsWith</span>(<span class="string">&quot;app&quot;</span>); <span class="comment">// 返回 True</span></span><br><span class="line">trie.<span class="built_in">insert</span>(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">trie.<span class="built_in">search</span>(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 True</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= word.length, prefix.length &lt;= <span class="number">2000</span></span><br><span class="line">word 和 prefix 仅由小写英文字母组成</span><br><span class="line">insert、search 和 startsWith 调用次数 总计 不超过 <span class="number">3</span> * <span class="number">104</span> 次</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、Trie树的设计模板题目，建议先了解其概念，然后背模板实现，多做几道Trie树的题目即可。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    vector&lt;Trie*&gt; next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">next</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* T = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (T -&gt; next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                T -&gt; next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            T = T -&gt; next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        T -&gt; isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* T = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) </span><br><span class="line">        &#123;</span><br><span class="line">            T = T -&gt; next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T -&gt; isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* T = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) </span><br><span class="line">        &#123;</span><br><span class="line">            T = T -&gt; next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(1 + |S|)</li><li>空间复杂度：O(|T| * sum)</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 72 78. 子集</title>
    <link href="/2021/11/20/Leetcode/91-day/day-72/"/>
    <url>/2021/11/20/Leetcode/91-day/day-72/</url>
    
    <content type="html"><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><strong><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[[],[<span class="number">0</span>]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">-10</span> &lt;= nums[i] &lt;= <span class="number">10</span></span><br><span class="line">nums 中的所有元素 互不相同</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题目若是求子集个数该多好，直接全排列即可，可惜是求每一个对应的子集。</li><li>2、利用两个数组，一个存最后的答案，一个用来做缓存数组，两个dfs的意思为，先加入所有的子元素，然后一个一个剔除，剔除一个元素，最终的答案数组将其存入。</li><li>3、最后34天要考研了，写的会比较紧张。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(i + <span class="number">1</span>, nums);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(i + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n*2^n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 71 260. 只出现一次的数字 III</title>
    <link href="/2021/11/19/Leetcode/91-day/day-71/"/>
    <url>/2021/11/19/Leetcode/91-day/day-71/</url>
    
    <content type="html"><![CDATA[<h1 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><strong><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 </span><br><span class="line"></span><br><span class="line">找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</span><br><span class="line"></span><br><span class="line">进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">5</span>, <span class="number">3</span>] 也是有效的答案。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">-231</span> &lt;= nums[i] &lt;= <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">除两个只出现一次的整数外，nums 中的其他数字都出现两次</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、因为只有两个数字不重复，看到则想到位运算的方法。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) sum ^= i;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span> &amp;&amp; k == <span class="number">-1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((sum &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) k = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">1</span>) ans[<span class="number">1</span>] ^= i;</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">0</span>] ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Partition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 70 932. 漂亮数组</title>
    <link href="/2021/11/17/Leetcode/91-day/day-70/"/>
    <url>/2021/11/17/Leetcode/91-day/day-70/</url>
    
    <content type="html"><![CDATA[<h1 id="932-漂亮数组"><a href="#932-漂亮数组" class="headerlink" title="932. 漂亮数组"></a><strong><a href="https://leetcode-cn.com/problems/beautiful-array/">932. 漂亮数组</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">对于某些固定的 N，如果数组 A 是整数 <span class="number">1</span>, <span class="number">2</span>, ..., N 组成的排列，使得：</span><br><span class="line"></span><br><span class="line">对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * <span class="number">2</span> = A[i] + A[j]。</span><br><span class="line"></span><br><span class="line">那么数组 A 是漂亮数组。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">给定 N，返回任意漂亮数组 A（保证存在一个）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">5</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= N &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、分治法的逻辑题目。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">beautifulArray</span>((n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">beautifulArray</span>(n / <span class="number">2</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : l) ans.<span class="built_in">push_back</span>(<span class="number">2</span> * x - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : r) ans.<span class="built_in">push_back</span>(<span class="number">2</span> * x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(logn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Partition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 69 23. 合并K个升序链表</title>
    <link href="/2021/11/17/Leetcode/91-day/day-69/"/>
    <url>/2021/11/17/Leetcode/91-day/day-69/</url>
    
    <content type="html"><![CDATA[<h1 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><strong><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表数组，每个链表都已经按升序排列。</span><br><span class="line"></span><br><span class="line">请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">k == lists.length</span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line"><span class="number">0</span> &lt;= lists[i].length &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">-10</span>^<span class="number">4</span> &lt;= lists[i][j] &lt;= <span class="number">10</span>^<span class="number">4</span></span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 <span class="number">10</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、看题目很明显，merge_sort的考察要点，使用的大多是分治的思想。</li><li>2、由于为 k 个升序的链表，但是仍可以分解为两两合并。</li><li>3、y神给的模板进行改写，确实十分好用</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_sort</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *p = a, *q = b;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p -&gt; val &lt; q -&gt; val) &#123;</span><br><span class="line">                tail -&gt; next = p; </span><br><span class="line">                p = p -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tail -&gt; next = q; </span><br><span class="line">                q = q -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail -&gt; next = (p ? p : q);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector &lt;ListNode*&gt;&amp; lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(k * logk)</p></li><li><p>空间复杂度：O(logk)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>merge_sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 68 96. 不同的二叉搜索树</title>
    <link href="/2021/11/16/Leetcode/91-day/day-68/"/>
    <url>/2021/11/16/Leetcode/91-day/day-68/</url>
    
    <content type="html"><![CDATA[<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><strong><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数 n ，求恰由 n 个节点组成且节点值</span><br><span class="line"></span><br><span class="line">从 <span class="number">1</span> 到 n 互不相同的 二叉搜索树 有多少种？</span><br><span class="line"></span><br><span class="line">返回满足题意的二叉搜索树的种数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">19</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题采用动态规划求解子问题，其中 dp[j - 1] 为左子树 j 个节点组成的二叉树种数，dp[i - j]为右子树 i - j 个节点组成的二叉树种数。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 67 881. 救生艇</title>
    <link href="/2021/11/15/Leetcode/91-day/day-67/"/>
    <url>/2021/11/15/Leetcode/91-day/day-67/</url>
    
    <content type="html"><![CDATA[<h1 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a><strong><a href="https://leetcode-cn.com/problems/boats-to-save-people/">881. 救生艇</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</span><br><span class="line"></span><br><span class="line">每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</span><br><span class="line"></span><br><span class="line">返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：people = [<span class="number">1</span>,<span class="number">2</span>], limit = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">1</span> 艘船载 (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：people = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], limit = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 艘船分别载 (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>) 和 (<span class="number">3</span>)</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：people = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>], limit = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">4</span> 艘船分别载 (<span class="number">3</span>), (<span class="number">3</span>), (<span class="number">4</span>), (<span class="number">5</span>)</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= people.length &lt;= <span class="number">50000</span></span><br><span class="line"><span class="number">1</span> &lt;= people[i] &lt;= limit &lt;= <span class="number">30000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、贪心法加双指针，双指针的思考方法跟快排一致。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRescueBoats</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; people, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l= <span class="number">0</span>, r = people.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[l] + people[r] &gt; limit) r--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l++;r--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(logn)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greed</tag>
      
      <tag>quick sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 66 435. 无重叠区间</title>
    <link href="/2021/11/14/Leetcode/91-day/day-66/"/>
    <url>/2021/11/14/Leetcode/91-day/day-66/</url>
    
    <content type="html"><![CDATA[<h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><strong><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">可以认为区间的终点总是大于它的起点。</span><br><span class="line"></span><br><span class="line">区间 [<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">2</span>,<span class="number">3</span>] 的边界相互“接触”，但没有相互重叠。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [<span class="number">1</span>,<span class="number">2</span>] 来使剩下的区间没有重叠。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、单刀直入，按照右边界排序，值越大越在后面，而后按照每一个子 vector 元素的右边界值与失分产生重叠来删除区间即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span> &amp; a, <span class="type">const</span> <span class="keyword">auto</span> &amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> del = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; r) del++;</span><br><span class="line">            <span class="keyword">else</span> r = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> del;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(logn)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 65 455. 分发饼干</title>
    <link href="/2021/11/13/Leetcode/91-day/day-65/"/>
    <url>/2021/11/13/Leetcode/91-day/day-65/</url>
    
    <content type="html"><![CDATA[<h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><strong><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">假设你是一位很棒的家长，想要给你的孩子们一些小饼干。</span><br><span class="line"></span><br><span class="line">但是，每个孩子最多只能给一块饼干。</span><br><span class="line"></span><br><span class="line">对每个孩子 i，都有一个胃口值 g[i]，</span><br><span class="line"></span><br><span class="line">这是能让孩子们满足胃口的饼干的最小尺寸；</span><br><span class="line"></span><br><span class="line">并且每块饼干 j，都有一个尺寸 s[j] 。</span><br><span class="line"></span><br><span class="line">如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。</span><br><span class="line"></span><br><span class="line">你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: g = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], s = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，<span class="number">3</span>个孩子的胃口值分别是：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是<span class="number">1</span>，你只能让胃口值是<span class="number">1</span>的孩子满足。</span><br><span class="line">所以你应该输出<span class="number">1</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: g = [<span class="number">1</span>,<span class="number">2</span>], s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，<span class="number">2</span>个孩子的胃口值分别是<span class="number">1</span>,<span class="number">2</span>。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出<span class="number">2.</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= g.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">1</span> &lt;= g[i], s[j] &lt;= <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、贪心法，优先满足最近的原则，排序两个数组，优先满足胃口最小的孩子，返回满足孩子的个数即可。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = g.<span class="built_in">size</span>(), m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++, j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; g[i] &gt; s[j]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; m) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 64 518. 零钱兑换 II</title>
    <link href="/2021/11/12/Leetcode/91-day/day-64/"/>
    <url>/2021/11/12/Leetcode/91-day/day-64/</url>
    
    <content type="html"><![CDATA[<h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><strong><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</span><br><span class="line"></span><br><span class="line">请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line">假设每一种面额的硬币有无限个。 </span><br><span class="line"></span><br><span class="line">题目数据保证结果符合 <span class="number">32</span> 位带符号整数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span><span class="number">+2</span><span class="number">+1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span><span class="number">+1</span><span class="number">+1</span><span class="number">+1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span><span class="number">+1</span><span class="number">+1</span><span class="number">+1</span><span class="number">+1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：amount = <span class="number">3</span>, coins = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：只用面额 <span class="number">2</span> 的硬币不能凑成总金额 <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：amount = <span class="number">10</span>, coins = [<span class="number">10</span>] </span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= coins.length &lt;= <span class="number">300</span></span><br><span class="line"><span class="number">1</span> &lt;= coins[i] &lt;= <span class="number">5000</span></span><br><span class="line">coins 中的所有值 互不相同</span><br><span class="line"><span class="number">0</span> &lt;= amount &lt;= <span class="number">5000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、与昨天的题目不同的是，本次的硬币的数据规模变小了，而且coins中的所有值互不相同，所以本次题目用模板解决问题会更加简单。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : coins) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2)</p></li><li><p>空间复杂度：O(n)</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/</a></p>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 63 322. 零钱兑换</title>
    <link href="/2021/11/11/Leetcode/91-day/day-63/"/>
    <url>/2021/11/11/Leetcode/91-day/day-63/</url>
    
    <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><strong><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span><br><span class="line"></span><br><span class="line">计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 <span class="number">-1</span> 。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">1</span>], amount = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">1</span>], amount = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：coins = [<span class="number">1</span>], amount = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= coins.length &lt;= <span class="number">12</span></span><br><span class="line"><span class="number">1</span> &lt;= coins[i] &lt;= <span class="number">231</span> - <span class="number">1</span></span><br><span class="line"><span class="number">0</span> &lt;= amount &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、相同思路，看以往题目与参考资料，即可改动模板化解决问题。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = coins[i]; j &lt;= amount; j++)</span><br><span class="line">            &#123;                </span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INF) dp[amount] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2)</p></li><li><p>空间复杂度：O(n)</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/</a></p>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 62 494. 目标和</title>
    <link href="/2021/11/10/Leetcode/91-day/day-62/"/>
    <url>/2021/11/10/Leetcode/91-day/day-62/</url>
    
    <content type="html"><![CDATA[<h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><strong><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给你一个 只包含正整数 的 非空 数组 nums 。</span><br><span class="line"></span><br><span class="line">请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>] 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、np背包问题查看大佬的模板解法，仅需要进行一些改动即可解题，本质上属于同一类的题目</li><li>2、两种边界条件的情况可以直接排除，数组和小于目标值以及数组差值为奇数。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>((sum - target) % <span class="number">2</span> == <span class="number">1</span> || sum &lt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = (sum - target) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= i; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - i]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2)</p></li><li><p>空间复杂度：O(n)</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/</a></p>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 61 416. 分割等和子集</title>
    <link href="/2021/11/09/Leetcode/91-day/day-61/"/>
    <url>/2021/11/09/Leetcode/91-day/day-61/</url>
    
    <content type="html"><![CDATA[<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><strong><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给你一个只包含正整数的非空数组 nums 。</span><br><span class="line"></span><br><span class="line">请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>] 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、今天进入 np 的背包的问题，np背包问题只有 0 或 1；两种返回值，本题为求数组等分两个值相同的子数组。</li><li>2、可见数组值相加一定为偶数，所以和为奇数的数组直接舍弃。</li><li>3、找子集和为sum &#x2F; 2的子数组即可。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2)</p></li><li><p>空间复杂度：O(n)</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-a7dd/</a></p>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 60 464. 我能赢吗</title>
    <link href="/2021/11/08/Leetcode/91-day/day-60/"/>
    <url>/2021/11/08/Leetcode/91-day/day-60/</url>
    
    <content type="html"><![CDATA[<h1 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a><strong><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="string">&quot;100 game&quot;</span> 这个游戏中，两名玩家轮流选择从 <span class="number">1</span> 到 <span class="number">10</span> 的任意整数，累计整数和，</span><br><span class="line"></span><br><span class="line">先使得累计整数和达到或超过 <span class="number">100</span> 的玩家，即为胜者。</span><br><span class="line"></span><br><span class="line">如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</span><br><span class="line"></span><br><span class="line">例如，两个玩家可以轮流从公共整数池中抽取从 <span class="number">1</span> 到 <span class="number">15</span> 的整数（不放回），直到累计整数和 &gt;= <span class="number">100</span>。</span><br><span class="line"></span><br><span class="line">给定一个整数 maxChoosableInteger 和另一个整数 desiredTotal，判断先出手的玩家是否能稳赢？</span><br><span class="line"></span><br><span class="line">你可以假设 maxChoosableInteger 不会大于 <span class="number">20</span>， desiredTotal 不会大于 <span class="number">300</span>。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">maxChoosableInteger = <span class="number">10</span></span><br><span class="line">desiredTotal = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">无论第一个玩家选择哪个整数，他都会失败。</span><br><span class="line">第一个玩家可以选择从 <span class="number">1</span> 到 <span class="number">10</span> 的整数。</span><br><span class="line">如果第一个玩家选择 <span class="number">1</span>，那么第二个玩家只能选择从 <span class="number">2</span> 到 <span class="number">10</span> 的整数。</span><br><span class="line">第二个玩家可以通过选择整数 <span class="number">10</span>（那么累积和为 <span class="number">11</span> &gt;= desiredTotal），从而取得胜利.</span><br><span class="line">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题只有两种对立的选择，必赢和必输，就是赌博中的稳赢的选择方法。如果先手方A选择某数X可以保证后手方B无论选择其他何数都保证赢，则必赢返回True，否则A选择任意数后B均有必赢方法，返回False</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canIWin</span><span class="params">(<span class="type">int</span> stable, <span class="type">int</span> desired)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stable &gt;= desired) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stable * (stable + <span class="number">1</span>) / <span class="number">2</span> &lt; desired) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; up;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canWin</span>(stable, desired, <span class="number">0</span>, up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> sum, <span class="type">int</span> k, unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt;&amp; up)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (up.<span class="built_in">count</span>(k)) <span class="keyword">return</span> up[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> ((cur &amp; k) == <span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//这个值没有使用过</span></span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= i + <span class="number">1</span> || !<span class="built_in">dfs</span>(n, sum - (i + <span class="number">1</span>), cur | k, up))</span><br><span class="line">                &#123;</span><br><span class="line">                    up[k] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        up[k] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 59 688. “马”在棋盘上的概率</title>
    <link href="/2021/11/07/Leetcode/91-day/day-59/"/>
    <url>/2021/11/07/Leetcode/91-day/day-59/</url>
    
    <content type="html"><![CDATA[<h1 id="688-“马”在棋盘上的概率"><a href="#688-“马”在棋盘上的概率" class="headerlink" title="688. “马”在棋盘上的概率"></a><strong><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/">688. “马”在棋盘上的概率</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 <span class="number">0</span> 开始。</span><br><span class="line"></span><br><span class="line">即最左上角的格子记为 (<span class="number">0</span>, <span class="number">0</span>)，最右下角的记为 (N<span class="number">-1</span>, N<span class="number">-1</span>)。 </span><br><span class="line"></span><br><span class="line">现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 </span><br><span class="line"></span><br><span class="line">如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 <span class="number">2</span> 个格子，</span><br><span class="line"></span><br><span class="line">然后向与之相垂直的方向再移动 <span class="number">1</span> 个格子，共有 <span class="number">8</span> 个可选的位置。</span><br><span class="line"> </span><br><span class="line">现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，</span><br><span class="line"></span><br><span class="line">直到移动了 K 次或跳到了棋盘外面。</span><br><span class="line"></span><br><span class="line">求移动结束后，“马” 仍留在棋盘上的概率。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">输出: <span class="number">0.0625</span></span><br><span class="line">解释: </span><br><span class="line">输入的数据依次为 N, K, r, c</span><br><span class="line">第 <span class="number">1</span> 步时，有且只有 <span class="number">2</span> 种走法令 “马” 可以留在棋盘上（跳到（<span class="number">1</span>,<span class="number">2</span>）或（<span class="number">2</span>,<span class="number">1</span>））。</span><br><span class="line"></span><br><span class="line">对于以上的两种情况，各自在第<span class="number">2</span>步均有且只有<span class="number">2</span>种走法令 “马” 仍然留在棋盘上。</span><br><span class="line"></span><br><span class="line">所以 “马” 在结束后仍在棋盘上的概率为 <span class="number">0.0625</span>。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">N 的取值范围为 [<span class="number">1</span>, <span class="number">25</span>]</span><br><span class="line">K 的取值范围为 [<span class="number">0</span>, <span class="number">100</span>]</span><br><span class="line">开始时，“马” 总是位于棋盘上</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、这题目暂时没有看懂，先下个坑，抄个答案。。。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> d[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">                    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, - <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;</span><br><span class="line">         &#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> K, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt; &gt; <span class="built_in">dp</span>(N, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(N, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ans = dp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                    ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">8</span>; ++l) &#123;</span><br><span class="line">                        <span class="type">int</span> r = i + d[l][<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> c = j + d[l][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; N &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line">                            ans[i][j] += dp[r][c] / <span class="number">8</span>;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(ans, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(K * N)</p></li><li><p>空间复杂度：O(r * c)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 58 62. 不同路径</title>
    <link href="/2021/11/06/Leetcode/91-day/day-58/"/>
    <url>/2021/11/06/Leetcode/91-day/day-58/</url>
    
    <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><strong><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span><br><span class="line"></span><br><span class="line">机器人每次只能向下或者向右移动一步。</span><br><span class="line"></span><br><span class="line">机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span><br><span class="line"></span><br><span class="line">问总共有多少条不同的路径？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">100</span></span><br><span class="line">题目数据保证答案小于等于 <span class="number">2</span> * <span class="number">10</span>^<span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、典型二维dp简单题目，第一行第一列全1，然后慢慢往下加，其实也是一个全排列的问题</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) ans[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i][j] = ans[i - <span class="number">1</span>][j] + ans[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n * m)</p></li><li><p>空间复杂度：O(n * m)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 57 1143. 最长公共子序列</title>
    <link href="/2021/11/05/Leetcode/91-day/day-57/"/>
    <url>/2021/11/05/Leetcode/91-day/day-57/</url>
    
    <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><strong><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。</span><br><span class="line"></span><br><span class="line">如果不存在 公共子序列 ，返回 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line">一个字符串的 子序列 是指这样一个新的字符串：</span><br><span class="line"></span><br><span class="line">它是由原字符串在不改变字符的相对顺序的情况下删除某些字符后组成的新字符串。</span><br><span class="line"></span><br><span class="line">例如，<span class="string">&quot;ace&quot;</span> 是 <span class="string">&quot;abcde&quot;</span> 的子序列，但 <span class="string">&quot;aec&quot;</span> 不是 <span class="string">&quot;abcde&quot;</span> 的子序列。</span><br><span class="line"></span><br><span class="line">两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= text<span class="number">1.l</span>ength, text<span class="number">2.l</span>ength &lt;= <span class="number">1000</span></span><br><span class="line">text1 和 text2 仅由小写英文字符组成。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li><p>1、本题可以使用两个一维数组解决问题，也可以使用二维数组解决问题，故选择使用二维数组解决问题。</p></li><li><p>2、优化后同之前做的三题目一致，可以优化空间为一个列为 2 的数组，行为 text2.size()的数组进行优化，由于时间问题，暂时作为 TODO。</p></li><li><p>3、研究状态转移方程为: <code>text1[i] == text2[j] : ans[i][j] = ans[i - 1][j - 1] + 1 即是 s1[i] 与 s2[j] 时最长公共子序列的的长度.</code></p><p><code>text1[i] != text2[j] : ans[i][j] = max(ans[i - 1][j], ans[i][j - 1]。代表必然不使用 s1[i](但可能使用s2[j]) 时和必然不使用 s2[j](但可能使用s1[i])时的长度。</code></p></li><li><p>4、使用空格是能够更好的处理边界条件</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text<span class="number">1.</span><span class="built_in">size</span>(), m = text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    text1 = <span class="string">&quot; &quot;</span> + text1;</span><br><span class="line">        text2 = <span class="string">&quot; &quot;</span> + text2;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) ans[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">    <span class="keyword">if</span>(text1[i] == text2[j])  </span><br><span class="line">&#123;</span><br><span class="line">ans[i][j] = <span class="built_in">max</span>(</span><br><span class="line">ans[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, </span><br><span class="line"><span class="built_in">max</span>(ans[i - <span class="number">1</span>][j], ans[i][j - <span class="number">1</span>])</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> ans[i][j] = <span class="built_in">max</span>(ans[i - <span class="number">1</span>][j], ans[i][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n][m] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n * m)</p></li><li><p>空间复杂度：O(n + m)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 56 673. 最长递增子序列的个数</title>
    <link href="/2021/11/04/Leetcode/91-day/day-56/"/>
    <url>/2021/11/04/Leetcode/91-day/day-56/</url>
    
    <content type="html"><![CDATA[<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个未排序的整数数组，找到最长递增子序列的个数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 有两个最长递增子序列，分别是 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>] 和[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 最长递增子序列的长度是<span class="number">1</span>，并且存在<span class="number">5</span>个子序列的长度为<span class="number">1</span>，因此输出<span class="number">5</span>。</span><br><span class="line">注意: 给定的数组长度不超过 <span class="number">2000</span> 并且结果一定是<span class="number">32</span>位有符号整数</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题思考有两个难点：找最长的递增序列，以及能够达成最长递增序列的数组的个数。</li><li>2、有一种做法是树状数组的做法，留待日后学习，现在消化不了，目前使用的方法有些麻烦。</li><li>3、使用两个数组，一个记录最长的数组长度，一个记录个数，全赋值为 1 因为每一个数组中的值均独立，可视为一个单独的子序列，而后对区间 [0, i)的所有数进行一次遍历，对于每一个 nums[j] &lt; nums[i]，说明 nums[i]可以添加在 nums[j]后面形成上升子序列，故可更新 len[i]的长度与 mlen[i]中的个数，此值为处于 i 处时候，len[i]最大的长度，以及此时子数组内最大长度的个数，同时使用 maxlen 表示原数组内最大长度的个数。</li><li>4、最后将最大长度等于 maxlen 的值对应保存在 mlen 数组中的位置的数相加，即可得到结果，过程比较复杂，第一个可能难以看明白。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">len</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">mlen</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(len[i] &lt; len[j] + <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        len[i] = len[j] + <span class="number">1</span>;</span><br><span class="line">                        mlen[i] = mlen[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len[i] == len[j] + <span class="number">1</span>) mlen[i] += mlen[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = <span class="built_in">max</span>(maxlen, len[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len[i] == maxlen) ans += mlen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n ^ 2)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 55 198. 打家劫舍</title>
    <link href="/2021/11/03/Leetcode/91-day/day-55/"/>
    <url>/2021/11/03/Leetcode/91-day/day-55/</url>
    
    <content type="html"><![CDATA[<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><strong><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。</span><br><span class="line"></span><br><span class="line">每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，</span><br><span class="line"></span><br><span class="line">如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，</span><br><span class="line"></span><br><span class="line">计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">400</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、dp是原来掌握最熟练的部分，但是由于好久没分析状态方程了，居然错了许多次。</li><li>2、把握好状态方程即可解决问题，分析为 dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</li><li>3、故优化空间后，跟fib一样只需要维护两个空间即可。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> best = <span class="built_in">max</span>(dp[<span class="number">0</span>] + nums[i], dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = best;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 54 746. 使用最小花费爬楼梯</title>
    <link href="/2021/11/02/Leetcode/91-day/day-54/"/>
    <url>/2021/11/02/Leetcode/91-day/day-54/</url>
    
    <content type="html"><![CDATA[<h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><strong><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 <span class="number">0</span> 开始）。</span><br><span class="line"></span><br><span class="line">每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，</span><br><span class="line"></span><br><span class="line">你就可以选择向上爬一个阶梯或者爬两个阶梯。</span><br><span class="line"></span><br><span class="line">请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 <span class="number">0</span> 或 <span class="number">1</span> 的元素作为初始阶梯。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：cost = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：最低花费是从 cost[<span class="number">1</span>] 开始，然后走两步即可到阶梯顶，一共花费 <span class="number">15</span> 。</span><br><span class="line"> 示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最低花费方式是从 cost[<span class="number">0</span>] 开始，逐个经过那些 <span class="number">1</span> ，跳过 cost[<span class="number">3</span>] ，一共花费 <span class="number">6</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">cost 的长度范围是 [<span class="number">2</span>, <span class="number">1000</span>]。</span><br><span class="line">cost[i] 将会是一个整型数据，范围为 [<span class="number">0</span>, <span class="number">999</span>] 。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、跟斐波那契是一样的动态规划题目，由于有爬一层跟爬两层的选择，所以只需要返回数组最后两个值中较小的那一个即可。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mix = <span class="built_in">min</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]) + cost[i];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = mix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 53 Top View of a Tree</title>
    <link href="/2021/11/01/Leetcode/91-day/day-53/"/>
    <url>/2021/11/01/Leetcode/91-day/day-53/</url>
    
    <content type="html"><![CDATA[<h1 id="Top-View-of-a-Tree"><a href="#Top-View-of-a-Tree" class="headerlink" title="Top View of a Tree"></a><strong><a href="https://binarysearch.com/problems/Top-View-of-a-Tree">Top View of a Tree</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree root,</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> the top view of the tree, sorted left-to-right.</span><br><span class="line"></span><br><span class="line">Constraints</span><br><span class="line"></span><br><span class="line">n ≤ <span class="number">100</span>,<span class="number">000</span> where n is the number of nodes in root</span><br><span class="line"></span><br><span class="line">Example <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">root = [<span class="number">1</span>, [<span class="number">2</span>, null, [<span class="number">4</span>, null, [<span class="number">5</span>, null, [<span class="number">6</span>, null, </span><br><span class="line">       [<span class="number">7</span>, null, null]]]]], [<span class="number">3</span>, null, null]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line"></span><br><span class="line">Note that directly above <span class="number">4</span> is <span class="number">1</span> <span class="keyword">and</span> directly above <span class="number">5</span> is <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">so these are <span class="keyword">not</span> part of the top view.</span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span></span><br><span class="line">Input</span><br><span class="line">root = [<span class="number">3</span>, [<span class="number">1</span>, [<span class="number">0</span>, null, null], [<span class="number">2</span>, null, null]], [<span class="number">4</span>, null, null]]</span><br><span class="line">Output</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题的意思为返回顶部的视角，即为自己左右孩子节点，覆盖自己左孩子节点的右孩子节点，自己右孩子的节点的左孩子节点看不见，即只要有相同的 y 值，同一层级只需要加入其中 x 值最大以及最小的那两个节点。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * class Tree &#123;</span></span><br><span class="line"><span class="comment"> *     public:</span></span><br><span class="line"><span class="comment"> *         int val;</span></span><br><span class="line"><span class="comment"> *         Tree *left;</span></span><br><span class="line"><span class="comment"> *         Tree *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Tree* root, <span class="type">int</span> x, <span class="type">int</span> y, map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(up.<span class="built_in">find</span>(x) == up.<span class="built_in">end</span>() || up[y].first &gt; h) up[x] = &#123;h, root -&gt; val&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root -&gt; left, x - <span class="number">1</span>, h + <span class="number">1</span>, up); </span><br><span class="line">    <span class="built_in">dfs</span>(root -&gt; right, x + <span class="number">1</span>, h + <span class="number">1</span>, up);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(Tree* root)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; up;</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>, <span class="number">0</span>, up);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : up) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 52 Shortest Cycle Containing Target Node</title>
    <link href="/2021/10/31/Leetcode/91-day/day-52/"/>
    <url>/2021/10/31/Leetcode/91-day/day-52/</url>
    
    <content type="html"><![CDATA[<h1 id="Shortest-Cycle-Containing-Target-Node"><a href="#Shortest-Cycle-Containing-Target-Node" class="headerlink" title="Shortest Cycle Containing Target Node"></a><strong><a href="https://binarysearch.com/problems/Shortest-Cycle-Containing-Target-Node">Shortest Cycle Containing Target Node</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">You are given a two-dimensional list of integers graph </span><br><span class="line"></span><br><span class="line">representing a directed graph as an adjacency list. </span><br><span class="line"></span><br><span class="line">You are also given an integer target.</span><br><span class="line"></span><br><span class="line">Return the length of a shortest cycle that contains target. </span><br><span class="line"></span><br><span class="line">If a solution does <span class="keyword">not</span> exist, <span class="keyword">return</span> <span class="number">-1.</span></span><br><span class="line"></span><br><span class="line">Constraints</span><br><span class="line"></span><br><span class="line">n, m ≤ <span class="number">250</span> where n <span class="keyword">and</span> m are the number of rows <span class="keyword">and</span> columns in graph</span><br><span class="line">Example <span class="number">1</span></span><br><span class="line">Input</span><br><span class="line">Visualize</span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">0</span></span><br><span class="line">Output</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Explanation</span><br><span class="line">The nodes <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">0</span> form a cycle</span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span></span><br><span class="line">Input</span><br><span class="line">Visualize</span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">4</span>],</span><br><span class="line">    [],</span><br><span class="line">    [<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">3</span></span><br><span class="line">Output</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、BFS，查看其中的非可视化发现图的存储方式为邻接表，所以本题的图的 BFS 套用模板即可解决问题；</li><li>2、扫描整个图，然后判断每个节点跟目标 t 的关系，有直接 return true，最后找不到返回 false;</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(t);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> node = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : g[node])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v == t) <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])  <span class="comment">//如果是未访问节点， 等价于 vis[v] == 0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n + e)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 51 1162. 地图分析</title>
    <link href="/2021/10/30/Leetcode/91-day/day-51/"/>
    <url>/2021/10/30/Leetcode/91-day/day-51/</url>
    
    <content type="html"><![CDATA[<h1 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a><strong><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">1162. 地图分析</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">你现在手里有一份大小为 N x N 的 网格 grid，</span><br><span class="line"></span><br><span class="line">上面的每个 单元格 都用 <span class="number">0</span> 和 <span class="number">1</span> 标记好了。其中 <span class="number">0</span> 代表海洋，<span class="number">1</span> 代表陆地，</span><br><span class="line"></span><br><span class="line">请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</span><br><span class="line"></span><br><span class="line">我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：</span><br><span class="line"></span><br><span class="line">(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</span><br><span class="line"></span><br><span class="line">如果网格上只有陆地或者海洋，请返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释： </span><br><span class="line">海洋单元格 (<span class="number">1</span>, <span class="number">1</span>) 和所有陆地单元格之间的距离都达到最大，最大距离为 <span class="number">2</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释： </span><br><span class="line">海洋单元格 (<span class="number">2</span>, <span class="number">2</span>) 和所有陆地单元格之间的距离都达到最大，最大距离为 <span class="number">4</span>。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= grid.length == grid[<span class="number">0</span>].length &lt;= <span class="number">100</span></span><br><span class="line">grid[i][j] 不是 <span class="number">0</span> 就是 <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、BFS板子题目，只需要加入上下左右四个方向的判断条件即可</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dis = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无陆地或者海洋则返回；</span></span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>() == <span class="number">0</span> || q.<span class="built_in">size</span>() == m * n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(s--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> k = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; d : dis)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="type">int</span> x = k.first + d[<span class="number">0</span>];</span><br><span class="line">                   <span class="type">int</span> y = k.second + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 如果搜索到的新坐标超出范围/陆地/已经遍历过，则不搜索了</span></span><br><span class="line">                    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//搜索后记为-1，表示不能再遇见</span></span><br><span class="line">                    grid[x][y] = <span class="number">-1</span>;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(m * n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 50 695. 岛屿的最大面积</title>
    <link href="/2021/10/29/Leetcode/91-day/day-50/"/>
    <url>/2021/10/29/Leetcode/91-day/day-50/</url>
    
    <content type="html"><![CDATA[<h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><strong><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">给你一个大小为 m x n 的二进制矩阵 grid 。</span><br><span class="line"></span><br><span class="line">岛屿 是由一些相邻的 <span class="number">1</span> (代表土地) 构成的组合，</span><br><span class="line"></span><br><span class="line">这里的「相邻」要求两个 <span class="number">1</span> 必须在 水平或者竖直的四个方向上 相邻。</span><br><span class="line"></span><br><span class="line">你可以假设 grid 的四个边缘都被 <span class="number">0</span>（代表水）包围着。</span><br><span class="line"></span><br><span class="line">岛屿的面积是岛上值为 <span class="number">1</span> 的单元格的数目。</span><br><span class="line"></span><br><span class="line">计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：答案不应该是 <span class="number">11</span> ，因为岛屿只能包含水平或垂直这四个方向上的 <span class="number">1</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == grid.length</span><br><span class="line">n == grid[i].length</span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">50</span></span><br><span class="line">grid[i][j] 为 <span class="number">0</span> 或 <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、dfs 常规解法，但是题目中 dfs 在 main 函数内递归，局部变量不能重名，重名会导致错误！</li><li>2、本题由于题目设置是岛屿并使用 0 或 1 表示，故可以不设置访问数组，一般 dfs 需要设置 bool 类型的访问数组来表示是否访问此单位。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) </span><br><span class="line">                    ans = <span class="built_in">max</span>(<span class="built_in">dfs</span>(grid, i, j), ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = grid.<span class="built_in">size</span>(), r = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= l || i &lt; <span class="number">0</span> || j &gt;= r || j &lt; <span class="number">0</span> || grid[i][j] == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(m * n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 49 52. N皇后 II</title>
    <link href="/2021/10/28/Leetcode/91-day/day-49/"/>
    <url>/2021/10/28/Leetcode/91-day/day-49/</url>
    
    <content type="html"><![CDATA[<h1 id="52-N-皇后-II"><a href="#52-N-皇后-II" class="headerlink" title="52. N 皇后 II"></a><strong><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N 皇后 II</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span><br><span class="line"></span><br><span class="line">给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，<span class="number">4</span> 皇后问题存在两个不同的解法。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">9</span></span><br><span class="line">皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、数据规模 1 - 9 直接打表方法，所以可以面向答案编程！</li><li>2、使用回溯法 + DFS，只要横竖斜三个方向不在一起即可，如果均在一起，则返回 false。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; res, <span class="type">int</span> col, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col == row) ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(res, i))</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="built_in">dfs</span>(res, col + <span class="number">1</span>, row);</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; res, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">abs</span>(res[i] - n) == res.<span class="built_in">size</span>() - i) || n == res[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* vector&lt;int&gt; res = &#123;1, 0, 0 ,2, 10, 4, 40, 92, 352&#125;;</span></span><br><span class="line"><span class="comment">        return res[n - 1]; */</span></span><br><span class="line">        <span class="built_in">dfs</span>(res, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n!)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 48 401. 二进制手表</title>
    <link href="/2021/10/27/Leetcode/91-day/day-48/"/>
    <url>/2021/10/27/Leetcode/91-day/day-48/</url>
    
    <content type="html"><![CDATA[<h1 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a><strong><a href="https://leetcode-cn.com/problems/binary-watch/">401. 二进制手表</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">二进制手表顶部有 <span class="number">4</span> 个 LED 代表 小时（<span class="number">0</span><span class="number">-11</span>），底部的 <span class="number">6</span> 个 LED 代表 分钟（<span class="number">0</span><span class="number">-59</span>）。</span><br><span class="line"></span><br><span class="line">每个 LED 代表一个 <span class="number">0</span> 或 <span class="number">1</span>，最低位在右侧。</span><br><span class="line"></span><br><span class="line">例如，下面的二进制手表读取 <span class="string">&quot;3:25&quot;</span> 。</span><br><span class="line"></span><br><span class="line">给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，</span><br><span class="line"></span><br><span class="line">返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。</span><br><span class="line"></span><br><span class="line">小时不会以零开头：</span><br><span class="line"></span><br><span class="line">例如，<span class="string">&quot;01:00&quot;</span> 是无效的时间，正确的写法应该是 <span class="string">&quot;1:00&quot;</span> 。</span><br><span class="line">分钟必须由两位数组成，可能会以零开头：</span><br><span class="line"></span><br><span class="line">例如，<span class="string">&quot;10:2&quot;</span> 是无效的时间，正确的写法应该是 <span class="string">&quot;10:02&quot;</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：turnedOn = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;0:01&quot;</span>,<span class="string">&quot;0:02&quot;</span>,<span class="string">&quot;0:04&quot;</span>,<span class="string">&quot;0:08&quot;</span>,<span class="string">&quot;0:16&quot;</span>,<span class="string">&quot;0:32&quot;</span>,<span class="string">&quot;1:00&quot;</span>,<span class="string">&quot;2:00&quot;</span>,<span class="string">&quot;4:00&quot;</span>,<span class="string">&quot;8:00&quot;</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：turnedOn = <span class="number">9</span></span><br><span class="line">输出：[]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= turnedOn &lt;= <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、使用打表的方法可能更好</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">count1</span>(i) + <span class="built_in">count1</span>(j) == turnedOn)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(i)+<span class="string">&quot;:&quot;</span>+</span><br><span class="line">                                  (j &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span>+<span class="built_in">to_string</span>(j) : <span class="built_in">to_string</span>(j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(1)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>traceback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 47 Number of Operations to Decrement Target to Zero</title>
    <link href="/2021/10/26/Leetcode/91-day/day-47/"/>
    <url>/2021/10/26/Leetcode/91-day/day-47/</url>
    
    <content type="html"><![CDATA[<h1 id="Number-of-Operations-to-Decrement-Target-to-Zero"><a href="#Number-of-Operations-to-Decrement-Target-to-Zero" class="headerlink" title="Number of Operations to Decrement Target to Zero"></a><strong><a href="https://binarysearch.com/problems/Number-of-Operations-to-Decrement-Target-to-Zero">Number of Operations to Decrement Target to Zero</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">You are given a list of positive integers nums <span class="keyword">and</span> an integer target.</span><br><span class="line"></span><br><span class="line">Consider an operation where we remove a number v from either the front </span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> the back of nums <span class="keyword">and</span> decrement target by v.</span><br><span class="line"></span><br><span class="line">Return the minimum number of operations required to decrement target to zero. </span><br><span class="line"></span><br><span class="line">If it<span class="string">&#x27;s not possible, return -1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Constraints</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">n ≤ 100,000 where n is the length of nums</span></span><br><span class="line"><span class="string">Example 1</span></span><br><span class="line"><span class="string">Input</span></span><br><span class="line"><span class="string">nums = [3, 1, 1, 2, 5, 1, 1]</span></span><br><span class="line"><span class="string">target = 7</span></span><br><span class="line"><span class="string">Output</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">Explanation</span></span><br><span class="line"><span class="string">We can remove 1, 1 and 5 from the back to decrement target to zero.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example 2</span></span><br><span class="line"><span class="string">Input</span></span><br><span class="line"><span class="string">nums = [2, 4]</span></span><br><span class="line"><span class="string">target = 7</span></span><br><span class="line"><span class="string">Output</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">Explanation</span></span><br><span class="line"><span class="string">There&#x27;</span>s no way to decrement target = <span class="number">7</span> to zero.</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、滑动窗口题目，数组遍历一次求和，刚好相等则不用减。</li><li>2、不相等则减去目标值，即为最少需要去除的值，使用双指针滑动，如果大于去除值，则左指针向前滑动，相等则对比之前操作的长度，记录其中最大的移动长度，即为最小的移动区间。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> n;</span><br><span class="line">sum -= target;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, total = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">    &#123;</span><br><span class="line">        total += nums[r];</span><br><span class="line">        <span class="keyword">while</span>(total &gt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            total -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = <span class="built_in">max</span>(pos, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos &gt; <span class="number">0</span> ? n - pos : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 46 76. 最小覆盖子串</title>
    <link href="/2021/10/25/Leetcode/91-day/day-46/"/>
    <url>/2021/10/25/Leetcode/91-day/day-46/</url>
    
    <content type="html"><![CDATA[<h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><strong><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 、一个字符串 t 。</span><br><span class="line"></span><br><span class="line">返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <span class="string">&quot;&quot;</span> 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span><br><span class="line">如果 s 中存在这样的子串，我们保证它是唯一的答案。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: t 中两个字符 <span class="string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length, t.length &lt;= <span class="number">105</span></span><br><span class="line">s 和 t 由英文字母组成</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你能设计一个在 <span class="built_in">o</span>(n) 时间内解决此问题的算法吗？</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题依旧使用滑动窗口解法，题目意思主要为，只要 t 中的对应字母的个数，与在 s 中截取 p 长度的那一部分的字母个数相同，求其中的最小区间即可！</li><li>2、与昨日题目一样，本题使用两个哈希表代替两个数组。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; wins, wint;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch: t) </span><br><span class="line">        &#123;</span><br><span class="line">            wint[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            wins[s[i]] ++ ;</span><br><span class="line">            <span class="keyword">if</span>(wins[s[i]] &lt;= wint[s[i]]) count++ ;</span><br><span class="line">            <span class="keyword">while</span>(wins[s[j]] &gt; wint[s[j]]) wins[s[j++]]--;</span><br><span class="line">            <span class="keyword">if</span>(count == m) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || i - j + <span class="number">1</span> &lt; res.<span class="built_in">size</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(j, i - j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_map</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 45 438. 找到字符串中所有字母异位词</title>
    <link href="/2021/10/24/Leetcode/91-day/day-45/"/>
    <url>/2021/10/24/Leetcode/91-day/day-45/</url>
    
    <content type="html"><![CDATA[<h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><strong><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，</span><br><span class="line"></span><br><span class="line">返回这些子串的起始索引。不考虑答案输出的顺序。</span><br><span class="line"></span><br><span class="line">异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;cbaebabacd&quot;</span>, p = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 <span class="number">0</span> 的子串是 <span class="string">&quot;cba&quot;</span>, 它是 <span class="string">&quot;abc&quot;</span> 的异位词。</span><br><span class="line">起始索引等于 <span class="number">6</span> 的子串是 <span class="string">&quot;bac&quot;</span>, 它是 <span class="string">&quot;abc&quot;</span> 的异位词。</span><br><span class="line"> 示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;abab&quot;</span>, p = <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 <span class="number">0</span> 的子串是 <span class="string">&quot;ab&quot;</span>, 它是 <span class="string">&quot;ab&quot;</span> 的异位词。</span><br><span class="line">起始索引等于 <span class="number">1</span> 的子串是 <span class="string">&quot;ba&quot;</span>, 它是 <span class="string">&quot;ab&quot;</span> 的异位词。</span><br><span class="line">起始索引等于 <span class="number">2</span> 的子串是 <span class="string">&quot;ab&quot;</span>, 它是 <span class="string">&quot;ab&quot;</span> 的异位词。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length, p.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line">s 和 p 仅包含小写字母</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、本题依旧使用滑动窗口解法，题目意思主要为，只要 p 中的对应字母的个数，与在 s 中截取  p 长度的那一部分的字母个数相同，即为字母异位词！</li><li>2、故只需要开辟三个数组即可！</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sin</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pin</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            pin[p[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            sin[s[r] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                sin[s[l] - <span class="string">&#x27;a&#x27;</span>]--; </span><br><span class="line">                l++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(pin == sin) ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 44 837. 新21点</title>
    <link href="/2021/10/23/Leetcode/91-day/day-44/"/>
    <url>/2021/10/23/Leetcode/91-day/day-44/</url>
    
    <content type="html"><![CDATA[<h1 id="837-新-21-点"><a href="#837-新-21-点" class="headerlink" title="837. 新 21 点"></a><strong><a href="https://leetcode-cn.com/problems/new-21-game/">837. 新 21 点</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">爱丽丝参与一个大致基于纸牌游戏 “<span class="number">21</span>点” 规则的游戏，描述如下：</span><br><span class="line"></span><br><span class="line">爱丽丝以 <span class="number">0</span> 分开始，并在她的得分少于 K 分时抽取数字。 </span><br><span class="line"></span><br><span class="line">抽取时，她从 [<span class="number">1</span>, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。</span><br><span class="line"></span><br><span class="line"> 每次抽取都是独立的，其结果具有相同的概率。</span><br><span class="line"></span><br><span class="line">当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：N = <span class="number">10</span>, K = <span class="number">1</span>, W = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1.00000</span></span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：N = <span class="number">6</span>, K = <span class="number">1</span>, W = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0.60000</span></span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W = <span class="number">10</span> 的 <span class="number">6</span> 种可能下，她的得分不超过 N = <span class="number">6</span> 分。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：N = <span class="number">21</span>, K = <span class="number">17</span>, W = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0.73278</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= K &lt;= N &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">1</span> &lt;= W &lt;= <span class="number">10000</span></span><br><span class="line">如果答案与正确答案的误差不超过 <span class="number">10</span>^<span class="number">-5</span>，则该答案将被视为正确答案通过。</span><br><span class="line">此问题的判断限制时间已经减少。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li><p>1、本题不止使用滑动窗口题目来减小数据计算的重复度，而且需要使用动态规划来解决问题的状态方程。</p></li><li><p>2、本题意思为，从 0 开始，每次手中的牌如果小于 x，则从[1, w]随机抽一张，概率互相独立，均为 1 &#x2F; w，令 dp[x] 表示从得分为 x 的情况开始游戏并且获胜的概率，目标是求 dp[0] 的值。本题目总给人一种条件概率求其中某一部分的全概率公式的感觉，前一次抽取的结果会影响到下一次的抽取结果以及结论，又跟马尔科夫链同出一辙，果断查看书籍，发现的确是如此，那么应用马尔可夫链的相关结论，可以得到状态转移方程<br>  $$<br>  dp\left[ x \right] &#x3D;\frac{\sum_{i&#x3D;1}^w{dp\left[ x,,+,,i \right]}}{w}<br>  $$</p></li><li><p>3、本题应属于困难的题目，思想方法难以理解，需要较强的概率论基础。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">new21Game</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> dp[k + w];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; k + w; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = i &lt;= n ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = ans / w;</span><br><span class="line">            ans = ans - dp[i + w] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n + k)</p></li><li><p>空间复杂度：O(n + k)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding window</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 43 1456. 定长子串中元音的最大数目</title>
    <link href="/2021/10/22/Leetcode/91-day/day-43/"/>
    <url>/2021/10/22/Leetcode/91-day/day-43/</url>
    
    <content type="html"><![CDATA[<h1 id="1456-定长子串中元音的最大数目"><a href="#1456-定长子串中元音的最大数目" class="headerlink" title="1456. 定长子串中元音的最大数目"></a><strong><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">1456. 定长子串中元音的最大数目</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">给你字符串 s 和整数 k 。</span><br><span class="line"></span><br><span class="line">请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</span><br><span class="line"></span><br><span class="line">英文中的 元音字母 为（a, e, i, o, u）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;abciiidef&quot;</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：子字符串 <span class="string">&quot;iii&quot;</span> 包含 <span class="number">3</span> 个元音字母。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;aeiou&quot;</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：任意长度为 <span class="number">2</span> 的子字符串都包含 <span class="number">2</span> 个元音字母。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;leetcode&quot;</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">&quot;lee&quot;</span>、<span class="string">&quot;eet&quot;</span> 和 <span class="string">&quot;ode&quot;</span> 都包含 <span class="number">2</span> 个元音字母。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;rhythms&quot;</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串 s 中不含任何元音字母。</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;tryhard&quot;</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line">s 由小写英文字母组成</span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= s.length</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、滑动窗口题目，设定窗口大小为 k，从左边一步一步遍历到右边，每遍历一步判断头跟尾部，待命还能分情况进行简化，但是时间复杂度基本不变</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvaild</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27;a&#x27;</span> || ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;i&#x27;</span> || ch == <span class="string">&#x27;o&#x27;</span> || ch == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="type">char</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvaild</span>(s[i])) count++; ans.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvaild</span>(ans.<span class="built_in">front</span>())) count--; ans.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvaild</span>(s[i])) count++; ans.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; count) tmp = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 42 778. 水位上升的泳池中游泳</title>
    <link href="/2021/10/21/Leetcode/91-day/day-42/"/>
    <url>/2021/10/21/Leetcode/91-day/day-42/</url>
    
    <content type="html"><![CDATA[<h1 id="778-水位上升的泳池中游泳"><a href="#778-水位上升的泳池中游泳" class="headerlink" title="778. 水位上升的泳池中游泳"></a><strong><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</span><br><span class="line"></span><br><span class="line">现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。</span><br><span class="line"></span><br><span class="line">你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。</span><br><span class="line"></span><br><span class="line">假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。</span><br><span class="line"></span><br><span class="line">当然，在你游泳的时候你必须待在坐标方格里面。</span><br><span class="line"></span><br><span class="line">你从坐标方格的左上平台 (<span class="number">0</span>，<span class="number">0</span>) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N<span class="number">-1</span>, N<span class="number">-1</span>)？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">时间为<span class="number">0</span>时，你位于坐标方格的位置为 (<span class="number">0</span>, <span class="number">0</span>)。</span><br><span class="line">此时你不能游向任意方向，</span><br><span class="line"></span><br><span class="line">因为四个相邻方向平台的高度都大于当前时间为 <span class="number">0</span> 时的水位。</span><br><span class="line"></span><br><span class="line">等时间到达 <span class="number">3</span> 时，你才可以游向平台 (<span class="number">1</span>, <span class="number">1</span>). 因为此时的水位是 <span class="number">3</span>，</span><br><span class="line"></span><br><span class="line">坐标方格中的平台没有比水位 <span class="number">3</span> 更高的，所以你可以游向坐标方格中的任意位置</span><br><span class="line">示例<span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">      [<span class="number">24</span>,<span class="number">23</span>,<span class="number">22</span>,<span class="number">21</span>,<span class="number">5</span>],</span><br><span class="line">      [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>],</span><br><span class="line">      [<span class="number">11</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">      [<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>]]</span><br><span class="line">输出: <span class="number">16</span></span><br><span class="line">解释:</span><br><span class="line"> <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">24</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span>  <span class="number">5</span></span><br><span class="line"><span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line"><span class="number">11</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br><span class="line"><span class="number">10</span>  <span class="number">9</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">最终的路线用加粗进行了标记。</span><br><span class="line">我们必须等到时间为 <span class="number">16</span>，此时才能保证平台 (<span class="number">0</span>, <span class="number">0</span>) 和 (<span class="number">4</span>, <span class="number">4</span>) 是连通的</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &lt;= N &lt;= <span class="number">50.</span></span><br><span class="line">grid[i][j] 是 [<span class="number">0</span>, ..., N * N - <span class="number">1</span>] 的排列。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、其实最想用并查集去做，但是考虑到实现方法为二分的方法，所以还是尝试使用二分查找+DFS遍历图的做法做，并查集毕竟可以判断图的连通情况。</li><li>2、二分法的目的为寻找一个合适的最短路径，DFS为尝试走到终点，题目中为从最左上到最右下，所以边界值应该是$n * n$，其中不能重复走走过的路，所以要设置一个 bool 类型的标记纪录。</li><li>3、dfs写起来其实简单，边界条件考虑清楚，只有一种情况能return true，其他都是false，有四个方向的可选择性。</li><li>4、本题比昨日前日的题目简单。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">swimInWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (n, <span class="literal">false</span>));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(grid, vis, n, mid, <span class="number">0</span>, <span class="number">0</span>)) r = mid;<span class="comment">//可达，偏大</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">//不可达，偏小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, </span></span></span><br><span class="line"><span class="params"><span class="function">            vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;vis, <span class="type">int</span> n, <span class="type">int</span> mid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//只有到终点才返回true；</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, vis, n, mid, i - <span class="number">1</span>, j) || </span><br><span class="line">                   <span class="built_in">dfs</span>(grid, vis, n, mid, i + <span class="number">1</span>, j) ||</span><br><span class="line">                   <span class="built_in">dfs</span>(grid, vis, n, mid, i, j - <span class="number">1</span>) || </span><br><span class="line">                   <span class="built_in">dfs</span>(grid, vis, n, mid, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O($n ^ 2 * logn$)</p></li><li><p>空间复杂度：O($n ^ 2$)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graph</tag>
      
      <tag>Binary Search</tag>
      
      <tag>UnionSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 41 822. Kth-Pair-Distance</title>
    <link href="/2021/10/20/Leetcode/91-day/day-41/"/>
    <url>/2021/10/20/Leetcode/91-day/day-41/</url>
    
    <content type="html"><![CDATA[<h1 id="822-Kth-Pair-Distance"><a href="#822-Kth-Pair-Distance" class="headerlink" title="822. Kth-Pair-Distance"></a><strong><a href="https://binarysearch.com/problems/Kth-Pair-Distance">822. Kth-Pair-Distance</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Given a list of integers nums <span class="keyword">and</span> an integer k,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> the k-th smallest <span class="built_in">abs</span>(x - y) <span class="keyword">for</span> every pair of <span class="built_in">elements</span> (x, y) in nums.</span><br><span class="line"> </span><br><span class="line">Note <span class="built_in">that</span> (x, y) <span class="built_in">and</span> (y, x) are considered the same pair.</span><br><span class="line"></span><br><span class="line">Constraints</span><br><span class="line"></span><br><span class="line">n ≤ <span class="number">100</span>,<span class="number">000</span> where n is the length of nums</span><br><span class="line">Example <span class="number">1</span></span><br><span class="line">Input</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">Output</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Explanation</span><br><span class="line">Here are all the pair distances:</span><br><span class="line"></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">1</span> - <span class="number">5</span>) = <span class="number">4</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">1</span> - <span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">1</span> - <span class="number">2</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">5</span> - <span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">5</span> - <span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">3</span> - <span class="number">2</span>) = <span class="number">1</span></span><br><span class="line">Sorted in ascending order we have [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、题目为求数组排序之后第 k 大的距离，首先排序数组，最大的距离即为数组头与尾值之差, 最小的距离当然为0，在此范围内去找寻一个合理的值即可。</li><li>2、使用二分法，每次取 mid &#x3D; l + (r - l) &#x2F; 2，可以减少查找的时间复杂度，不然使用计数的话，时间复杂度在O($n^2$)。</li><li>3、本题目也可以使用数学的思想去考虑，所有的距离对为一共有$n(n-1)$，所以只要大于mid距离的对数有$n(n-1)$ - k，即为不合理。（还是有些东西没想明白，先放着）</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvaild</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> dis, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>()</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= dis) j++;</span><br><span class="line">            count += j - i - <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= k;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k++;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvaild</span>(nums, mid, k)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 40 796. Minimum Light Radius</title>
    <link href="/2021/10/19/Leetcode/91-day/day-40/"/>
    <url>/2021/10/19/Leetcode/91-day/day-40/</url>
    
    <content type="html"><![CDATA[<h1 id="796-Minimum-Light-Radius"><a href="#796-Minimum-Light-Radius" class="headerlink" title="796. Minimum Light Radius"></a><strong><a href="https://binarysearch.com/problems/Minimum-Light-Radius">796. Minimum Light Radius</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">You are given a list of integers nums</span><br><span class="line"></span><br><span class="line">representing coordinates of houses on a <span class="number">1</span>-dimensional line. </span><br><span class="line"></span><br><span class="line">You have <span class="number">3</span> street lights that you can put anywhere on the coordinate line </span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> a light at coordinate x lights up houses in [x - r, x + r],</span><br><span class="line"></span><br><span class="line">inclusive. Return the smallest r required </span><br><span class="line"></span><br><span class="line">such that we can place the <span class="number">3</span> lights <span class="keyword">and</span> all the houses are lit up.</span><br><span class="line"></span><br><span class="line">Constraints</span><br><span class="line"></span><br><span class="line">n ≤ <span class="number">100</span>,<span class="number">000</span> where n is the length of nums</span><br><span class="line">Example <span class="number">1</span></span><br><span class="line">Input</span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">Output</span><br><span class="line"><span class="number">0.5</span></span><br><span class="line">Explanation</span><br><span class="line">If we place the lamps on <span class="number">3.5</span>, <span class="number">4.5</span> <span class="keyword">and</span> <span class="number">5.5</span> then with r = <span class="number">0.5</span> we can light up all <span class="number">4</span> houses.</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、有点数学问题的味道了，使用两个二分搜索来找到可能的最小半径。</li><li>2、一个判断三个值的范围能否全覆盖数组的长度</li><li>3、一个用来改变直径</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvaild</span><span class="params">(<span class="type">double</span> diameter, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">double</span> l = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), nums[l] + diameter) - nums.<span class="built_in">begin</span>();</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= <span class="number">3</span> ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">double</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> r = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> diameter = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvaild</span>(diameter, nums)) r = diameter;</span><br><span class="line">            <span class="keyword">else</span> l = diameter + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 39 762.Number Stream to Intervals</title>
    <link href="/2021/10/18/Leetcode/91-day/day-39/"/>
    <url>/2021/10/18/Leetcode/91-day/day-39/</url>
    
    <content type="html"><![CDATA[<h1 id="762-Number-Stream-to-Intervals"><a href="#762-Number-Stream-to-Intervals" class="headerlink" title="762.Number Stream to Intervals"></a><strong><a href="https://binarysearch.com/problems/Triple-Inversion">762.Number Stream to Intervals</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a list of integers nums, </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> the number of pairs i &lt; j such that nums[i] &gt; nums[j] * <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Constraints</span><br><span class="line"></span><br><span class="line">n ≤ <span class="number">100</span>,<span class="number">000</span> where n is the length of nums</span><br><span class="line">Example <span class="number">1</span></span><br><span class="line">Input</span><br><span class="line">nums = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">Output</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Explanation</span><br><span class="line">We have the <span class="built_in">pairs</span> (<span class="number">7</span>, <span class="number">1</span>) <span class="built_in">and</span> (<span class="number">7</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、构造逆序对，然后返回逆序对的数量，使用归并排序比二分法更加合适，找出每个子区间中一项大于当前 num * 3 的值</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> i, <span class="type">int</span> mid, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(j - i + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> l = i, r = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid &amp;&amp; r &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[cnt] = nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[cnt] = nums[r];</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid) ans[cnt++] = nums[l++];</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= j) ans[cnt++] = nums[r++];</span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) nums[i++] = ans[cnt++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        ans += <span class="built_in">mergeSort</span>(nums, l, mid);</span><br><span class="line">        ans += <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p = l;</span><br><span class="line">        <span class="type">int</span> q = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= mid &amp;&amp; q &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p] &gt; nums[q] * <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (mid - p + <span class="number">1</span>);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">merge</span>(nums, l, mid, r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mergeSort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 38 278. 第一个错误的版本</title>
    <link href="/2021/10/17/Leetcode/91-day/day-38/"/>
    <url>/2021/10/17/Leetcode/91-day/day-38/</url>
    
    <content type="html"><![CDATA[<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><strong><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。</span><br><span class="line"></span><br><span class="line">由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</span><br><span class="line"></span><br><span class="line">假设你有 n 个版本 [<span class="number">1</span>, <span class="number">2</span>, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。</span><br><span class="line"></span><br><span class="line">你可以通过调用 <span class="function"><span class="type">bool</span> <span class="title">isBadVersion</span><span class="params">(version)</span> 接口来判断版本号 version 是否在单元测试中出错。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">示例 1：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入：n </span>= <span class="number">5</span>, bad = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">调用 <span class="built_in">isBadVersion</span>(<span class="number">3</span>) -&gt; <span class="literal">false</span> </span><br><span class="line">调用 <span class="built_in">isBadVersion</span>(<span class="number">5</span>) -&gt; <span class="literal">true</span> </span><br><span class="line">调用 <span class="built_in">isBadVersion</span>(<span class="number">4</span>) -&gt; <span class="literal">true</span></span><br><span class="line">所以，<span class="number">4</span> 是第一个错误的版本。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span>, bad = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= bad &lt;= n &lt;= <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、这里要注意，当API接口返回true时，不一定是找到了目标位置，还需要继续向前查找，直到找到第一个有问题的目标。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">      <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid)) r = mid;</span><br><span class="line">          <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(logn)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 37 69. Sqrt(x)</title>
    <link href="/2021/10/16/Leetcode/91-day/day-37/"/>
    <url>/2021/10/16/Leetcode/91-day/day-37/</url>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a><strong><a href="https://leetcode-cn.com/problems/sqrtx/">69. Sqrt(x)</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span><br><span class="line"></span><br><span class="line">由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span><br><span class="line"></span><br><span class="line">注意：不允许使用任何内置指数函数和算符，例如 <span class="built_in">pow</span>(x, <span class="number">0.5</span>) 或者 x ** <span class="number">0.5</span> 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">8</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">8</span> 的算术平方根是 <span class="number">2.82842</span>..., 由于返回类型是整数，小数部分将被舍去。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= x &lt;= <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、二分法，还有一个叫做牛顿迭代法跟红蓝法，没研究，后面研究研究</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt;= x /mid) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(logn)</p></li><li><p>空间复杂度：O(1)</p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 36 912. 排序数组</title>
    <link href="/2021/10/15/Leetcode/91-day/day-36/"/>
    <url>/2021/10/15/Leetcode/91-day/day-36/</url>
    
    <content type="html"><![CDATA[<h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><strong><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，请你将该数组升序排列。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">50000</span></span><br><span class="line"><span class="number">-50000</span> &lt;= nums[i] &lt;= <span class="number">50000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、最简单的是调用库函数，但这样的写法显然没有任何意义，所以此处复现所有的排序算法，刚好也能练习以防止考研过程中出现相应的问题。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sort(nums.begin(), nums.end());</span></span><br><span class="line">        <span class="comment">//return nums;</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//冒泡排序 超时</span></span><br><span class="line">        <span class="comment">/* for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            bool flag = false;</span></span><br><span class="line"><span class="comment">            for(int j = n - 2; j &gt;= i; j--)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                if(nums[j] &gt; nums[j + 1])</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    swap(nums[j], nums[j + 1]);</span></span><br><span class="line"><span class="comment">                    flag = true;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(flag == false)break;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入排序 超时</span></span><br><span class="line">        <span class="comment">/* for(int i = 0; i &lt; n - 1; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int min = i;</span></span><br><span class="line"><span class="comment">            for(int j = i + 1; j &lt; n; j++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                if(nums[min] &gt; nums[j]) min = j;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(min != i) swap(nums[i], nums[min]);</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//快排 失败</span></span><br><span class="line">        <span class="comment">/* dfs(0, n - 1, nums); */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//堆排序</span></span><br><span class="line">        <span class="comment">/* for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int pos = i;</span></span><br><span class="line"><span class="comment">            int mid = (pos - 1)/2;</span></span><br><span class="line"><span class="comment">            while(nums[pos] &gt; nums[mid])</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                swap(nums[pos], nums[mid]);</span></span><br><span class="line"><span class="comment">                pos = mid;</span></span><br><span class="line"><span class="comment">                mid = (pos - 1) / 2;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for(int j = n - 1; j &gt;= 0; j--)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            swap(nums[0], nums[j]);</span></span><br><span class="line"><span class="comment">            heapsort(nums,0,j);</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计数排序</span></span><br><span class="line">        <span class="type">int</span> minn = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxn = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(maxn - minn + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i - minn]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; ans.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ans[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j++] = i + minn;</span><br><span class="line">                ans[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void dfs(int start, int end, vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">        if(start &gt; end) return;</span></span><br><span class="line"><span class="comment">        int i = start, j = end;</span></span><br><span class="line"><span class="comment">        while(i &lt; j)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            while(nums[j] &gt;= nums[start] &amp;&amp; i &lt; j) j--;</span></span><br><span class="line"><span class="comment">            while(nums[i] &lt;= nums[start] &amp;&amp; i &lt; j) i++;</span></span><br><span class="line"><span class="comment">            if(i &lt; j) swap(nums[i], nums[j]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        swap(nums[start], nums[i]);</span></span><br><span class="line"><span class="comment">        dfs(start, i - 1, nums);</span></span><br><span class="line"><span class="comment">        dfs(i + 1, end, nums);</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*  void heapsort(vector&lt;int&gt;&amp; nums, int pos, int n)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int l = pos * 2 + 1, r = pos * 2 + 2;</span></span><br><span class="line"><span class="comment">        while(l &lt; n)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int big = pos;</span></span><br><span class="line"><span class="comment">            if(l &lt; n &amp;&amp; nums[l] &gt; nums[big]) big = l;</span></span><br><span class="line"><span class="comment">            if(r &lt; n &amp;&amp; nums[r] &gt; nums[big]) big = r;</span></span><br><span class="line"><span class="comment">            if(big == pos) break;</span></span><br><span class="line"><span class="comment">            swap(nums[pos], nums[big]);</span></span><br><span class="line"><span class="comment">            pos = big;</span></span><br><span class="line"><span class="comment">            l = pos * 2 + 1, r = pos * 2 + 2;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn) 堆排序</p><p>​ O(n) 计数排序</p></li><li><p>空间复杂度：O(1) 堆排序</p><p>​ O(n) 基数排序</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos 8.2 中 Git 安装</title>
    <link href="/2021/10/15/middleware/git/"/>
    <url>/2021/10/15/middleware/git/</url>
    
    <content type="html"><![CDATA[<h2 id="一、安装依赖包"><a href="#一、安装依赖包" class="headerlink" title="一、安装依赖包"></a>一、安装依赖包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统为 centos8.2 版本，可能会出现系统版本不兼容等问题！</span><br><span class="line">sudo yum -y install make autoconf automake cmake perl-CPAN libcurl-devel libtool gcc gcc-c++ glibc-headers zlib-devel git-lfs telnet ctags lrzsz jq expat-devel openssl-devel</span><br></pre></td></tr></table></figure><h2 id="二、安装新版git包"><a href="#二、安装新版git包" class="headerlink" title="二、安装新版git包"></a>二、安装新版git包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.30.2.tar.gz</span><br><span class="line">tar -xvzf git-2.30.2.tar.gz</span><br><span class="line">cd git-2.30.2/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">git --version          # 输出 git 版本号，说明安装成功</span><br><span class="line">git version 2.30.2</span><br></pre></td></tr></table></figure><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h2 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> git config --global user.name <span class="string">&quot;chaggle&quot;</span>  用户名改成自己的</span><br><span class="line"> git config --global user.email <span class="string">&quot;chaggle@foxmail.com&quot;</span> 邮箱改成自己的</span><br><span class="line"> git config --global credential.helper store </span><br><span class="line"> git config --global core.longpaths <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在 Git 中，我们会把非 ASCII 字符叫做 Unusual 字符。这类字符在 Git 输出到终端的时候默认是用 8 进制转义字符输出的（以防乱码），但现在的终端多数都支持直接显示非 ASCII 字符，所以我们可以关闭掉这个特性</span></span><br><span class="line">git config --global core.quotepath off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 github.com 太慢，可以通过国内 GitHub 镜像网站来访问</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://gitclone.com/&quot;</span>.insteadOf <span class="string">&quot;https://&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GitHub 限制最大只能克隆 100M 的单个文件，为了能够克隆大于 100M 的文件，我们还需要安装 Git Large File Storage</span></span><br><span class="line">git lfs install --skip-repo</span><br></pre></td></tr></table></figure><h2 id="四、Github-代理配置"><a href="#四、Github-代理配置" class="headerlink" title="四、Github 代理配置"></a>四、Github 代理配置</h2><p>这里博主为了稳定性考虑，只推荐 <a href="https://gitclone.com/">https://gitclone.com</a> 网站，其余的代理都容易失效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原地址</span></span><br><span class="line">git clone https://github.com/kubernetes/kubernetes.git</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line">git clone https://gitclone.com/github.com/kubernetes/kubernetes.git</span><br></pre></td></tr></table></figure><p>但是提交git仓储时候，需要将代理地址进行还原，否则就会上传到代理地址的 git 地址！</p><h2 id="五、关于-HTTPS-与-SSH-git-clone-稳定性问题"><a href="#五、关于-HTTPS-与-SSH-git-clone-稳定性问题" class="headerlink" title="五、关于 HTTPS 与 SSH git clone 稳定性问题"></a>五、关于 HTTPS 与 SSH git clone 稳定性问题</h2><p>一般建议网络环境友好的情况下，使用 HTTPS 协议，配置简单，而网络环境差的情况下使用 SSH 协议，因为 SSH 建立的传输链接不容易丢失。</p>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 35 1737. 满足三条件之一需改变的最少字符数</title>
    <link href="/2021/10/14/Leetcode/91-day/day-35/"/>
    <url>/2021/10/14/Leetcode/91-day/day-35/</url>
    
    <content type="html"><![CDATA[<h1 id="1737-满足三条件之一需改变的最少字符数"><a href="#1737-满足三条件之一需改变的最少字符数" class="headerlink" title="1737. 满足三条件之一需改变的最少字符数"></a><strong><a href="https://leetcode-cn.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/">1737. 满足三条件之一需改变的最少字符数</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给你两个字符串 a 和 b ，二者均由小写字母组成。一步操作中，</span><br><span class="line"></span><br><span class="line">你可以将 a 或 b 中的 任一字符 改变为 任一小写字母 。</span><br><span class="line"></span><br><span class="line">操作的最终目标是满足下列三个条件 之一 ：</span><br><span class="line"></span><br><span class="line">a 中的 每个字母 在字母表中 严格小于 b 中的 每个字母 。</span><br><span class="line">b 中的 每个字母 在字母表中 严格小于 a 中的 每个字母 。</span><br><span class="line">a 和 b 都 由 同一个 字母组成。</span><br><span class="line">返回达成目标所需的 最少 操作数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：a = <span class="string">&quot;aba&quot;</span>, b = <span class="string">&quot;caa&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：满足每个条件的最佳方案分别是：</span><br><span class="line"><span class="number">1</span>) 将 b 变为 <span class="string">&quot;ccc&quot;</span>，<span class="number">2</span> 次操作，满足 a 中的每个字母都小于 b 中的每个字母；</span><br><span class="line"><span class="number">2</span>) 将 a 变为 <span class="string">&quot;bbb&quot;</span> 并将 b 变为 <span class="string">&quot;aaa&quot;</span>，<span class="number">3</span> 次操作，满足 b 中的每个字母都小于 a 中的每个字母；</span><br><span class="line"><span class="number">3</span>) 将 a 变为 <span class="string">&quot;aaa&quot;</span> 并将 b 变为 <span class="string">&quot;aaa&quot;</span>，<span class="number">2</span> 次操作，满足 a 和 b 由同一个字母组成。</span><br><span class="line">最佳的方案只需要 <span class="number">2</span> 次操作（满足条件 <span class="number">1</span> 或者条件 <span class="number">3</span>）。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：a = <span class="string">&quot;dabadd&quot;</span>, b = <span class="string">&quot;cda&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：满足条件 <span class="number">1</span> 的最佳方案是将 b 变为 <span class="string">&quot;eee&quot;</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= a.length, b.length &lt;= <span class="number">105</span></span><br><span class="line">a 和 b 只由小写字母组成</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、前缀和以及计数的思想</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCharacters</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>(), m = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> r[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : a) </span><br><span class="line">        &#123;</span><br><span class="line">            l[x - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : b) </span><br><span class="line">        &#123;</span><br><span class="line">            r[x - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ls = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rs = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = n + m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            ls += l[i];</span><br><span class="line">            rs += r[i];</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">min</span>(<span class="built_in">min</span>(n + m - l[i] - r[i], n - ls + rs), m - rs + ls));</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, n + m - l[<span class="number">25</span>] - r[<span class="number">25</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prefix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 34 1904. 你完成的完整对局数</title>
    <link href="/2021/10/13/Leetcode/91-day/day-34/"/>
    <url>/2021/10/13/Leetcode/91-day/day-34/</url>
    
    <content type="html"><![CDATA[<h1 id="1904-你完成的完整对局数"><a href="#1904-你完成的完整对局数" class="headerlink" title="1904. 你完成的完整对局数"></a><strong><a href="https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played/">1904. 你完成的完整对局数</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">一款新的在线电子游戏在近期发布，</span><br><span class="line"></span><br><span class="line">在该电子游戏中，以刻钟为周期规划若干时长为 <span class="number">15</span> 分钟的游戏对局。</span><br><span class="line"></span><br><span class="line">这意味着，在 HH:<span class="number">00</span>、HH:<span class="number">15</span>、HH:<span class="number">30</span> 和 HH:<span class="number">45</span> </span><br><span class="line"></span><br><span class="line">将会开始一个新的对局，其中 HH 用一个从 <span class="number">00</span> 到 <span class="number">23</span> 的整数表示。</span><br><span class="line"></span><br><span class="line">游戏中使用 <span class="number">24</span> 小时制的时钟，所以一天中最早的时间是 <span class="number">00</span>:<span class="number">00</span> ，最晚的时间是 <span class="number">23</span>:<span class="number">59</span> 。</span><br><span class="line"></span><br><span class="line">给你两个字符串 startTime 和 finishTime ，均符合 <span class="string">&quot;HH:MM&quot;</span> 格式，</span><br><span class="line"></span><br><span class="line">分别表示你进入和退出游戏的确切时间，请计算在整个游戏会话期间，你完成的完整对局的对局数 。</span><br><span class="line"></span><br><span class="line">例如，如果 startTime = <span class="string">&quot;05:20&quot;</span> 且 finishTime = <span class="string">&quot;05:59&quot;</span>，</span><br><span class="line"></span><br><span class="line">这意味着你仅仅完成从 <span class="number">05</span>:<span class="number">30</span> 到 <span class="number">05</span>:<span class="number">45</span> 这一个完整对局。</span><br><span class="line"></span><br><span class="line">而你没有完成从 <span class="number">05</span>:<span class="number">15</span> 到 <span class="number">05</span>:<span class="number">30</span> 的完整对局，因为你是在对局开始后进入的游戏；</span><br><span class="line"></span><br><span class="line">同时，你也没有完成从 <span class="number">05</span>:<span class="number">45</span> 到 <span class="number">06</span>:<span class="number">00</span> 的完整对局，因为你是在对局结束前退出的游戏。</span><br><span class="line"></span><br><span class="line">如果 finishTime 早于 startTime ，这表示你玩了个通宵</span><br><span class="line"></span><br><span class="line">假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，</span><br><span class="line"></span><br><span class="line">请计算并返回你完成的 完整对局的对局数 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：startTime = <span class="string">&quot;12:01&quot;</span>, finishTime = <span class="string">&quot;12:44&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你完成了从 <span class="number">12</span>:<span class="number">15</span> 到 <span class="number">12</span>:<span class="number">30</span> 的一个完整对局。</span><br><span class="line">你没有完成从 <span class="number">12</span>:<span class="number">00</span> 到 <span class="number">12</span>:<span class="number">15</span> 的完整对局，</span><br><span class="line"></span><br><span class="line">因为你是在对局开始后的 <span class="number">12</span>:<span class="number">01</span> 进入的游戏。</span><br><span class="line"></span><br><span class="line">你没有完成从 <span class="number">12</span>:<span class="number">30</span> 到 <span class="number">12</span>:<span class="number">45</span> 的完整对局，</span><br><span class="line"></span><br><span class="line">因为你是在对局结束前的 <span class="number">12</span>:<span class="number">44</span> 退出的游戏。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：startTime = <span class="string">&quot;20:00&quot;</span>, finishTime = <span class="string">&quot;06:00&quot;</span></span><br><span class="line">输出：<span class="number">40</span></span><br><span class="line">解释：</span><br><span class="line">你完成了从 <span class="number">20</span>:<span class="number">00</span> 到 <span class="number">00</span>:<span class="number">00</span> 的 <span class="number">16</span> 个完整的对局，</span><br><span class="line">以及从 <span class="number">00</span>:<span class="number">00</span> 到 <span class="number">06</span>:<span class="number">00</span> 的 <span class="number">24</span> 个完整的对局。</span><br><span class="line"><span class="number">16</span> + <span class="number">24</span> = <span class="number">40</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：startTime = <span class="string">&quot;00:00&quot;</span>, finishTime = <span class="string">&quot;23:59&quot;</span></span><br><span class="line">输出：<span class="number">95</span></span><br><span class="line">解释：除最后一个小时你只完成了 <span class="number">3</span> 个完整对局外，</span><br><span class="line"></span><br><span class="line">其余每个小时均完成了 <span class="number">4</span> 场完整对局。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">startTime 和 finishTime 的格式为 HH:MM</span><br><span class="line"><span class="number">00</span> &lt;= HH &lt;= <span class="number">23</span></span><br><span class="line"><span class="number">00</span> &lt;= MM &lt;= <span class="number">59</span></span><br><span class="line">startTime 和 finishTime 不相等</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、模拟题目，题目多读几遍，就会了</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfRounds</span><span class="params">(string startTime, string finishTime)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> h1 = <span class="built_in">stoi</span>(startTime.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> m1 = <span class="built_in">stoi</span>(startTime.<span class="built_in">substr</span>(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> h2 = <span class="built_in">stoi</span>(finishTime.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> m2 = <span class="built_in">stoi</span>(finishTime.<span class="built_in">substr</span>(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a1 = h1 * <span class="number">60</span> + m1;</span><br><span class="line">        <span class="type">int</span> a2 = h2 * <span class="number">60</span> + m2;</span><br><span class="line">        <span class="keyword">if</span> (a1 &gt; a2)</span><br><span class="line">            a2 += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">ceil</span>(<span class="built_in">double</span>(a1) / <span class="number">15</span>);</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">floor</span>(<span class="built_in">double</span>(a2) / <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, b - a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(1)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>imitate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 33 1834. 单线程 CPU</title>
    <link href="/2021/10/12/Leetcode/91-day/day-33/"/>
    <url>/2021/10/12/Leetcode/91-day/day-33/</url>
    
    <content type="html"><![CDATA[<h1 id="1834-单线程-CPU"><a href="#1834-单线程-CPU" class="headerlink" title="1834. 单线程 CPU"></a><strong><a href="https://leetcode-cn.com/problems/single-threaded-cpu/">1834. 单线程 CPU</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">给你一个二维数组 tasks ，用于表示 n 项从 <span class="number">0</span> 到 n - <span class="number">1</span> 编号的任务。</span><br><span class="line"></span><br><span class="line">其中 tasks[i] = [enqueueTimei, processingTimei] </span><br><span class="line"></span><br><span class="line">意味着第 i 项任务将会于 enqueueTimei 时进入任务队列</span><br><span class="line"></span><br><span class="line">需要 processingTimei 的时长完成执行。</span><br><span class="line"></span><br><span class="line">现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</span><br><span class="line"></span><br><span class="line">如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。</span><br><span class="line"></span><br><span class="line">如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。</span><br><span class="line"></span><br><span class="line">如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</span><br><span class="line">一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。</span><br><span class="line">CPU 可以在完成一项任务后，立即开始执行一项新任务。</span><br><span class="line">返回 CPU 处理任务的顺序。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：tasks = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = <span class="number">1</span> ，任务 <span class="number">0</span> 进入任务队列，可执行任务项 = &#123;<span class="number">0</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">1</span> ，空闲状态的 CPU 开始执行任务 <span class="number">0</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">2</span> ，任务 <span class="number">1</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">3</span> ，任务 <span class="number">2</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">3</span> ，CPU 完成任务 <span class="number">0</span> 并开始执行队列中用时最短的任务 <span class="number">2</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">4</span> ，任务 <span class="number">3</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">- time = <span class="number">5</span> ，CPU 完成任务 <span class="number">2</span> 并开始执行队列中用时最短的任务 <span class="number">3</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">6</span> ，CPU 完成任务 <span class="number">3</span> 并开始执行任务 <span class="number">1</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">10</span> ，CPU 完成任务 <span class="number">1</span> 并进入空闲状态</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：tasks = [[<span class="number">7</span>,<span class="number">10</span>],[<span class="number">7</span>,<span class="number">12</span>],[<span class="number">7</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = <span class="number">7</span> ，所有任务同时进入任务队列，可执行任务项  = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">7</span> ，空闲状态的 CPU 开始执行任务 <span class="number">4</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">- time = <span class="number">9</span> ，CPU 完成任务 <span class="number">4</span> 并开始执行任务 <span class="number">3</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">- time = <span class="number">13</span> ，CPU 完成任务 <span class="number">3</span> 并开始执行任务 <span class="number">2</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">18</span> ，CPU 完成任务 <span class="number">2</span> 并开始执行任务 <span class="number">0</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">28</span> ，CPU 完成任务 <span class="number">0</span> 并开始执行任务 <span class="number">1</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">40</span> ，CPU 完成任务 <span class="number">1</span> 并进入空闲状态</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">tasks.length == n</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">1</span> &lt;= enqueueTimei, processingTimei &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、设计题目，模拟一个cpu而已</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//task index序列号 start为进入队列时间 times为完成时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> times;</span><br><span class="line">    <span class="built_in">task</span>(<span class="type">int</span> index, <span class="type">int</span> start, <span class="type">int</span> times) : <span class="built_in">index</span>(index), <span class="built_in">start</span>(start), <span class="built_in">times</span>(times) &#123;&#125;</span><br><span class="line">    <span class="built_in">task</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;tasks)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">auto</span> cmptimes = [](task a, task b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.times == b.times) <span class="keyword">return</span> a.index &gt; b.index;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a.times &gt; b.times;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cmpstart = [](task a, task b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.start &gt; b.start;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;task, vector&lt;task&gt;, <span class="keyword">decltype</span>(cmptimes)&gt; <span class="built_in">qtimes</span>(cmptimes);</span><br><span class="line">        priority_queue&lt;task, vector&lt;task&gt;, <span class="keyword">decltype</span>(cmpstart)&gt; <span class="built_in">qstart</span>(cmpstart);</span><br><span class="line">        <span class="type">int</span> n = tasks.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            qstart.<span class="built_in">push</span>(&#123;i, tasks[i][<span class="number">0</span>], tasks[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> now = qstart.<span class="built_in">top</span>().start;</span><br><span class="line">        <span class="keyword">while</span>(qstart.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">while</span> (qstart.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; qstart.<span class="built_in">top</span>().start &lt;= now)</span><br><span class="line">            &#123;</span><br><span class="line">                qtimes.<span class="built_in">push</span>(qstart.<span class="built_in">top</span>());</span><br><span class="line">                qstart.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (qtimes.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                task x = qtimes.<span class="built_in">top</span>();</span><br><span class="line">                qtimes.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(x.index);</span><br><span class="line">                now += x.times;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                now = qstart.<span class="built_in">top</span>().start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (qtimes.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            task x = qtimes.<span class="built_in">top</span>();</span><br><span class="line">            qtimes.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x.index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>priority_queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 32 657. 机器人能否返回原点</title>
    <link href="/2021/10/11/Leetcode/91-day/day-32/"/>
    <url>/2021/10/11/Leetcode/91-day/day-32/</url>
    
    <content type="html"><![CDATA[<h1 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657. 机器人能否返回原点"></a><strong><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">657. 机器人能否返回原点</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在二维平面上，有一个机器人从原点 (<span class="number">0</span>, <span class="number">0</span>) 开始。</span><br><span class="line"></span><br><span class="line">给出它的移动顺序，判断这个机器人在完成移动后是否在 (<span class="number">0</span>, <span class="number">0</span>) 处结束。</span><br><span class="line"></span><br><span class="line">移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。</span><br><span class="line"></span><br><span class="line">机器人的有效动作有 R（右），L（左），U（上）和 D（下）。</span><br><span class="line"></span><br><span class="line">如果机器人在完成所有动作后返回原点，则返回 <span class="literal">true</span>。否则，返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line">注意：机器人“面朝”的方向无关紧要。</span><br><span class="line"></span><br><span class="line">“R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;UD&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释：机器人向上移动一次，然后向下移动一次。</span><br><span class="line"></span><br><span class="line">所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 <span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;LL&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。</span><br><span class="line"></span><br><span class="line">我们返回 <span class="literal">false</span>，因为它在移动结束时没有返回原点。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、模拟题，简单解法</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeCircle</span><span class="params">(string m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span> : s[<span class="number">0</span>]++;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : s[<span class="number">0</span>]--;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : s[<span class="number">1</span>]++;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span> : s[<span class="number">1</span>]--;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; s[<span class="number">1</span>] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)，遍历</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 31 1203. 项目管理</title>
    <link href="/2021/10/10/Leetcode/91-day/day-31/"/>
    <url>/2021/10/10/Leetcode/91-day/day-31/</url>
    
    <content type="html"><![CDATA[<h1 id="1203-项目管理"><a href="#1203-项目管理" class="headerlink" title="1203. 项目管理"></a><strong><a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/">1203. 项目管理</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。</span><br><span class="line"></span><br><span class="line">group[i] 表示第 i 个项目所属的小组，如果第 i 个项目不属于任何小组，则 group[i] 等于 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。</span><br><span class="line"></span><br><span class="line">请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</span><br><span class="line"></span><br><span class="line">同一小组的项目，排序后在列表中彼此相邻。</span><br><span class="line">项目之间存在一定的依赖关系，</span><br><span class="line"></span><br><span class="line">我们用一个列表 beforeItems 来表示，</span><br><span class="line"></span><br><span class="line">其中 beforeItems[i] 表示在进行第 i 个项目前应该完成的所有项目。</span><br><span class="line"></span><br><span class="line">如果存在多个解决方案，只需要返回其中任意一个即可。</span><br><span class="line"></span><br><span class="line">如果没有合适的解决方案，就请返回一个 空列表 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span>, m = <span class="number">2</span>, group = [<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>],</span><br><span class="line">beforeItems = [[],[<span class="number">6</span>],[<span class="number">5</span>],[<span class="number">6</span>],[<span class="number">3</span>,<span class="number">6</span>],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">n = <span class="number">8</span>, m = <span class="number">2</span>, group = [<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>], </span><br><span class="line">beforeItems = [[],[<span class="number">6</span>],[<span class="number">5</span>],[<span class="number">6</span>],[<span class="number">3</span>],[],[<span class="number">4</span>],[]]</span><br><span class="line"></span><br><span class="line">输出：[]</span><br><span class="line">解释：与示例 <span class="number">1</span> 大致相同，但是在排序后的列表中，<span class="number">4</span> 必须放在 <span class="number">6</span> 的前面。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= m &lt;= n &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line">group.length == beforeItems.length == n</span><br><span class="line"><span class="number">-1</span> &lt;= group[i] &lt;= m - <span class="number">1</span></span><br><span class="line"><span class="number">0</span> &lt;= beforeItems[i].length &lt;= n - <span class="number">1</span></span><br><span class="line"><span class="number">0</span> &lt;= beforeItems[i][j] &lt;= n - <span class="number">1</span></span><br><span class="line">i != beforeItems[i][j]</span><br><span class="line">beforeItems[i] 不含重复元素</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、拓扑排序类问题，今日问题较难，使用单拓扑排序可能不太行，所以尝试使用双拓扑排序的思路！由于这几天生病，只能 CV 一下，过几天后再来补一道解析！</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortItems</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> n, <span class="type">int</span> m, </span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; group,</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; beforeItems)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans, blank;</span><br><span class="line">        <span class="comment">//如果某个项目不属于当前任何小组，</span></span><br><span class="line">        <span class="comment">//新建一个小组，并且把它分给这个小组，为了避免冲突，新的小组编号从m开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; group.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span>(group[i] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            group[i] = m++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别保存组间依赖关系、项目之间的依赖关系、各个小组负责的项目</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; topoGroup[m], topoItem[n], groupItem[m];</span><br><span class="line">        <span class="comment">//分别保存小组和项目在图中的入度</span></span><br><span class="line">        <span class="type">int</span> groupDgr[m], itemDgr[n];</span><br><span class="line">        <span class="comment">//避免添加多余的有向边，依赖关系只需要一条有向边就可以表示</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">        <span class="built_in">memset</span>(groupDgr, <span class="number">0</span>, <span class="keyword">sizeof</span> groupDgr);</span><br><span class="line">        <span class="built_in">memset</span>(itemDgr, <span class="number">0</span> ,<span class="keyword">sizeof</span> itemDgr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; beforeItems.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将项目添加到对应的组内</span></span><br><span class="line">            groupItem[group[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; beforeItems[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//hashval用于判断是否有重复的邮箱边出现</span></span><br><span class="line">                <span class="type">int</span> u = beforeItems[i][j], hashval = group[u] * m + group[i];</span><br><span class="line">                topoItem[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">                itemDgr[i]++;</span><br><span class="line">                <span class="comment">//自己不能依赖自己</span></span><br><span class="line">                <span class="keyword">if</span>(group[i] == group[u] || vis.<span class="built_in">find</span>(hashval) != vis.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                vis.<span class="built_in">insert</span>(hashval);</span><br><span class="line">                topoGroup[group[u]].<span class="built_in">push_back</span>(group[i]);</span><br><span class="line">                groupDgr[group[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//groupOrder保存了组的顺序</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; groupOrder;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span>(groupDgr[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            groupOrder.<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; topoGroup[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = topoGroup[u][i];</span><br><span class="line">                groupDgr[v]--;</span><br><span class="line">                <span class="keyword">if</span>(groupDgr[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断组内项目是否满足拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; groupOrder.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = groupOrder[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; groupItem[t].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u = groupItem[t][j];</span><br><span class="line">                <span class="keyword">if</span>(itemDgr[u] == <span class="number">0</span>) q.<span class="built_in">push</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                cnt++;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(u);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; topoItem[u].<span class="built_in">size</span>(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> v = topoItem[u][j];</span><br><span class="line">                    itemDgr[v]--;</span><br><span class="line">                    <span class="keyword">if</span>(itemDgr[v] == <span class="number">0</span> &amp;&amp; group[v] == t) q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt != groupItem[t].<span class="built_in">size</span>()) <span class="keyword">return</span> blank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果组间关系不能满足拓扑排序，必定有项目不能加入ans内</span></span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() != n) <span class="keyword">return</span> blank;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n + m)</p></li><li><p>空间复杂度：O(n + m)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 30 886. 可能的二分法</title>
    <link href="/2021/10/09/Leetcode/91-day/day-30/"/>
    <url>/2021/10/09/Leetcode/91-day/day-30/</url>
    
    <content type="html"><![CDATA[<h1 id="886-可能的二分法"><a href="#886-可能的二分法" class="headerlink" title="886. 可能的二分法"></a><strong><a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给定一组 N 人（编号为 <span class="number">1</span>, <span class="number">2</span>, ..., N）， 我们想把每个人分进任意大小的两组。</span><br><span class="line"></span><br><span class="line">每个人都可能不喜欢其他人，那么他们不应该属于同一组。</span><br><span class="line"></span><br><span class="line">形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。</span><br><span class="line"></span><br><span class="line">当可以用这种方法将所有人分进两组时，返回 <span class="literal">true</span>；否则返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：N = <span class="number">4</span>, dislikes = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：group1 [<span class="number">1</span>,<span class="number">4</span>], group2 [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：N = <span class="number">3</span>, dislikes = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：N = <span class="number">5</span>, dislikes = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= N &lt;= <span class="number">2000</span></span><br><span class="line"><span class="number">0</span> &lt;= dislikes.length &lt;= <span class="number">10000</span></span><br><span class="line">dislikes[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">1</span> &lt;= dislikes[i][j] &lt;= N</span><br><span class="line">dislikes[i][<span class="number">0</span>] &lt; dislikes[i][<span class="number">1</span>]</span><br><span class="line">对于 dislikes[i] == dislikes[j] 不存在 i != j</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、经典并查集</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFound</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; F;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnionFound</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        F = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            F[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == F[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> F[x] = <span class="built_in">Find</span>(F[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">Find</span>(x);</span><br><span class="line">        y = <span class="built_in">Find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != y) F[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;dislikes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt; &gt; mp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dislikes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mp[dislikes[i][<span class="number">0</span>] - <span class="number">1</span>].<span class="built_in">push_back</span>(dislikes[i][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            mp[dislikes[i][<span class="number">1</span>] - <span class="number">1</span>].<span class="built_in">push_back</span>(dislikes[i][<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">UnionFound <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> vec = mp[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uf.<span class="built_in">Find</span>(i) == uf.<span class="built_in">Find</span>(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                uf.<span class="built_in">Union</span>(vec[<span class="number">0</span>], c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16. 最接近的三数之和</title>
    <link href="/2021/10/08/Leetcode/16/"/>
    <url>/2021/10/08/Leetcode/16/</url>
    
    <content type="html"><![CDATA[<h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><strong><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums 和 一个目标值 target。</span><br><span class="line"></span><br><span class="line">请你从 nums 中选出三个整数，使它们的和与 target 最接近。</span><br><span class="line"></span><br><span class="line">返回这三个数的和。</span><br><span class="line"></span><br><span class="line">假定每组输入只存在恰好一个解。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-4</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：与 target 最接近的和是 <span class="number">2</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>) 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> &lt;= nums.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-104</span> &lt;= target &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><p>1、本题跟两数之和，三数之和都是一样的双指针解法，<br>2、首先是先对数组进行排序，然后确定第一个点，之后开始双指针遍历数组前后每一个值，由于是找最接近的数，所以如果相等，直接返回值即可。<br>3、如果三数之和 sum 大于目标值，则让右端点 r–，反之让左端点 l++；如果在 i &gt; 0 的情况下 nums[i] 跟 nums[i-1] 的值相等，那么之后遍历返回的三数之和情况也相等，所以在只返回唯一合适的值的时候可以使用 continue 直接跳过本轮循环进行优化。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    min := math.MaxInt32</span><br><span class="line"></span><br><span class="line">    update := <span class="function"><span class="keyword">func</span> <span class="params">(sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> abs(min - target) &gt; abs(sum - target) &#123;</span><br><span class="line">            min = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++ &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l, r := i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            sum := nums[i] + nums[l] + nums[r]</span><br><span class="line"></span><br><span class="line">            update(sum)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">                <span class="keyword">return</span> sum</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">                r--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        x = -x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n^2)</p></li><li><p>空间复杂度：O(nlogn)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>187. 重复的DNA序列</title>
    <link href="/2021/10/08/Leetcode/187/"/>
    <url>/2021/10/08/Leetcode/187/</url>
    
    <content type="html"><![CDATA[<h1 id="187-重复的-DNA-序列"><a href="#187-重复的-DNA-序列" class="headerlink" title="187. 重复的 DNA 序列"></a><strong><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的 DNA 序列</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">所有 DNA 都由一系列缩写为 <span class="string">&#x27;A&#x27;</span>，<span class="string">&#x27;C&#x27;</span>，<span class="string">&#x27;G&#x27;</span> 和 <span class="string">&#x27;T&#x27;</span> 的核苷酸组成，例如：<span class="string">&quot;ACGAATTCCG&quot;</span>。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</span><br><span class="line"></span><br><span class="line">编写一个函数来找出所有目标子串，目标子串的长度为 <span class="number">10</span>，且在 DNA 字符串 s 中出现次数超过一次。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;AAAAACCCCC&quot;</span>,<span class="string">&quot;CCCCCAAAAA&quot;</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;AAAAAAAAAAAAA&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;AAAAAAAAAA&quot;</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">105</span></span><br><span class="line">s[i] 为 <span class="string">&#x27;A&#x27;</span>、<span class="string">&#x27;C&#x27;</span>、<span class="string">&#x27;G&#x27;</span> 或 <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><p>1、滑动窗口，以 10 为值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">9</span>; j &lt; n; j++, i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[s.<span class="built_in">substr</span>(i,<span class="number">10</span>)] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, <span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            st[s.<span class="built_in">substr</span>(i, <span class="number">10</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n*C)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Day 29 997. 找到小镇的法官</title>
    <link href="/2021/10/08/Leetcode/91-day/day-29/"/>
    <url>/2021/10/08/Leetcode/91-day/day-29/</url>
    
    <content type="html"><![CDATA[<h1 id="997-找到小镇的法官"><a href="#997-找到小镇的法官" class="headerlink" title="997. 找到小镇的法官"></a><strong><a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">在一个小镇里，按从 <span class="number">1</span> 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。</span><br><span class="line"></span><br><span class="line">如果小镇的法官真的存在，那么：</span><br><span class="line"></span><br><span class="line">小镇的法官不相信任何人。</span><br><span class="line">每个人（除了小镇法官外）都信任小镇的法官。</span><br><span class="line">只有一个人同时满足条件 <span class="number">1</span> 和条件 <span class="number">2</span> 。</span><br><span class="line">给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。</span><br><span class="line"></span><br><span class="line">如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">2</span>, trust = [[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span>, trust = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span>, trust = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span>, trust = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">4</span>, trust = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= trust.length &lt;= <span class="number">104</span></span><br><span class="line">trust[i].length == <span class="number">2</span></span><br><span class="line">trust[i] 互不相同</span><br><span class="line">trust[i][<span class="number">0</span>] != trust[i][<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span> &lt;= trust[i][<span class="number">0</span>], trust[i][<span class="number">1</span>] &lt;= n</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、简单图论类问题，其他人相信自己，所以其他人在图中指向自己，而自己不指向任何人，即出度为0，入度为 n - 1;</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findJudge</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">out</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> len = trust.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            in[trust[i][<span class="number">1</span>]]++; <span class="comment">//入度</span></span><br><span class="line">            out[trust[i][<span class="number">0</span>]]++; <span class="comment">//出度</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == n - <span class="number">1</span> &amp;&amp; out[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>434. 字符串中的单词数</title>
    <link href="/2021/10/07/Leetcode/434/"/>
    <url>/2021/10/07/Leetcode/434/</url>
    
    <content type="html"><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a><strong><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. 字符串中的单词数</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</span><br><span class="line"></span><br><span class="line">请注意，你可以假定字符串里不包括任何不可打印的字符。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;Hello, my name is John&quot;</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 这里的单词是指连续的不是空格的字符，所以 <span class="string">&quot;Hello,&quot;</span> 算作 <span class="number">1</span> 个单词。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1\简单题目，字符前不是空格，后为空格即可视为 1 个字符；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSegments</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[n - <span class="number">1</span>]==<span class="string">&#x27; &#x27;</span> ? ans : ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 28 239. 滑动窗口最大值</title>
    <link href="/2021/10/07/Leetcode/91-day/day-28/"/>
    <url>/2021/10/07/Leetcode/91-day/day-28/</url>
    
    <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><strong><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。</span><br><span class="line"></span><br><span class="line">你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line"></span><br><span class="line">返回滑动窗口中的最大值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-1</span>], k = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">11</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">11</span>]</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">-2</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= nums.length</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、滑动窗口题目,最多算个中等题目，可用双端队列解决问题，也可以维护一个 size &#x3D; k 的最大堆，其中使用双端队列的时间复杂度为 O(n)，而使用最大堆的时间复杂度为 O(nlogn)</li><li>2、双端队列中维护的只是数组 nums 中的数组下标，便于</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果队头的元素值满足 i - k 的长度时候，即窗口需要向后滑动，将队头的元素踢除！</span></span><br><span class="line">            <span class="keyword">if</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() == i - k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">//保证从大到小，如果前面数小则需要依次剔除，直至满足要求</span></span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(k)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC 与 GDB 的学习</title>
    <link href="/2021/10/06/middleware/gcc/"/>
    <url>/2021/10/06/middleware/gcc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>gcc 是 GUN Compiler Collection的缩写，可以支持多种语言编译，比如 C, C++, Java, pascal 等</p></blockquote><h2 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h2><ul><li><p>预处理（pre-processing）E：插入头文件，替换宏</p></li><li><p>编译（Compiling）S：编译成汇编</p></li><li><p>汇编（Assembling） c：编译成目标文件</p></li><li><p>链接 （Linking）：链接到库中，变成可执行文件</p></li></ul><blockquote><p>gcc -E hello.c -o hello.i</p><p>gcc -S hello.i –o hello.s</p><p>gcc –c hello.s –o hello.o</p><p>gcc hello.s –o hello 链接，生成可执行文件</p><p>.&#x2F;hello 运行</p></blockquote><p>也可以一次性完成:</p><blockquote><p>gcc hello.c –o hello</p></blockquote><p>但一般情况下生成.o文件比较好，可以重定位文件，让别人使用</p><p>gcc常用选项</p><blockquote><p>选项名 作用<br>o  生成目标<br>c  取消链接步骤，编译源码并最后生成目标文件<br>E  只运行C预编译器（头文件，宏等展开）<br>S  生成汇编语言文件后停止编译（.s文件）<br>Wall  打开编译告警（所有）<br>g  嵌入调试信息，方便gdb调试<br>llib  链接 lib 库 （这里是小写 L ） 相当于 C++ #pragma comment(lib, “xxx.lib”)<br>Idir  增加 include 目录 (这里是大写 i ) 头文件路径<br>LDir  增加 lib 目录 （编译静态库和动态库）</p></blockquote><p>gdb调试实例<br>下面以一个有错误的例子程序来介绍gdb的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*bugging.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buff [<span class="number">256</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* <span class="built_in">string</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Please input a string: &quot;</span>);</span><br><span class="line">    gets (<span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\nYour string is: %s\n&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个程序是接受用户的输入，然后将用户的输入打印出来。该程序使用了一个未经过初始化的字符串地址 string，因此，编译并运行之后，将出现 &quot;Segment Fault&quot;错误：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o bugging -g  bugging.c</span><br><span class="line">$ ./bugging</span><br><span class="line"></span><br><span class="line"><span class="comment"># Please input a string: asdf</span></span><br><span class="line"><span class="comment"># Segmentation fault (core dumped)</span></span><br><span class="line"><span class="comment"># 为了查找该程序中出现的问题，我们利用 gdb，并按如下的步骤进行：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [1] 运行 “gdb bugging” ，加载 bugging 可执行文件；</span></span><br><span class="line"><span class="variable">$gdb</span> bugging </span><br><span class="line">    </span><br><span class="line"><span class="comment">#[2] 执行装入的 bugging 命令；</span></span><br><span class="line">(gdb) run</span><br><span class="line">    </span><br><span class="line"><span class="comment">#[3] 使用 where 命令查看程序出错的地方；</span></span><br><span class="line">(gdb) <span class="built_in">where</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#[4] 利用 list 命令查看调用 gets 函数附近的代码；</span></span><br><span class="line">(gdb) list</span><br><span class="line">    </span><br><span class="line"><span class="comment">#[5] 在 gdb 中，我们在第 11 行处设置断点，看看是否是在第11行出错；</span></span><br><span class="line">(gdb) <span class="built_in">break</span> 11</span><br><span class="line">    </span><br><span class="line"><span class="comment">#[6] 程序重新运行到第 11 行处停止，这时程序正常，然后执行单步命令next；</span></span><br><span class="line">(gdb) next</span><br><span class="line">    </span><br><span class="line"><span class="comment">#[7] 程序确实出错，能够导致 gets 函数出错的因素就是变量 string。重新执行测试程，用 print 命令查看 string 的值；</span></span><br><span class="line">(gdb) run</span><br><span class="line">(gdb) <span class="built_in">print</span> string</span><br><span class="line">(gdb) <span class="variable">$1</span>=0x0</span><br><span class="line">    </span><br><span class="line"><span class="comment">#[8] 问题在于string指向的是一个无效指针，修改程序，在10行和11行之间增加一条语句 “string=buff; ”，重新编译程序，然后继续运行，将看到正确的程序运行结果。</span></span><br></pre></td></tr></table></figure><blockquote><p>用gdb查看源代码可以用list命令，但是这个不够灵活。可以使用”layout src”命令，或者按Ctrl-X再按A，就会出现一个窗口可以查看源代码。也可以用使用-tui参数，这样进入gdb里面后就能直接打开代码查看窗口。其他代码窗口相关命令：</p><p>info win 显示窗口的大小<br>layout next 切换到下一个布局模式<br>layout prev 切换到上一个布局模式<br>layout src 只显示源代码<br>layout asm 只显示汇编代码<br>layout split 显示源代码和汇编代码<br>layout regs 增加寄存器内容显示<br>focus cmd&#x2F;src&#x2F;asm&#x2F;regs&#x2F;next&#x2F;prev 切换当前窗口<br>refresh 刷新所有窗口<br>tui reg next 显示下一组寄存器<br>tui reg system 显示系统寄存器<br>update 更新源代码窗口和当前执行点<br>winheight name +&#x2F;- line 调整name窗口的高度<br>tabset nchar 设置tab为nchar个字符</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>middleware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>414. 第三大的数</title>
    <link href="/2021/10/06/Leetcode/414/"/>
    <url>/2021/10/06/Leetcode/414/</url>
    
    <content type="html"><![CDATA[<h1 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><strong><a href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第三大的数是 <span class="number">1</span> 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：第三大的数不存在, 所以返回最大的数 <span class="number">2</span> 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。</span><br><span class="line">此例中存在两个值为 <span class="number">2</span> 的数，它们都排第二。在所有不同数字中排第三大的数为 <span class="number">1</span> 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-231</span> &lt;= nums[i] &lt;= <span class="number">231</span> - <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你能设计一个时间复杂度 <span class="built_in">O</span>(n) 的解决方案吗？</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>set存储唯一值，然后维护一个最多为三的set容器即可，虽然时间会慢一点，但是理解相当简单，当然也能手撕一个最大堆，由于时间关系，考研完后（明年1月1开搞）！到时候会回来更新内容</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">insert</span> (i);</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; <span class="number">3</span>) st.<span class="built_in">erase</span>(st.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>() == <span class="number">3</span>) <span class="keyword">return</span> *st.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> *st.<span class="built_in">rbegin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 27 35. 搜索插入位置</title>
    <link href="/2021/10/06/Leetcode/91-day/day-27/"/>
    <url>/2021/10/06/Leetcode/91-day/day-27/</url>
    
    <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><strong><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。</span><br><span class="line"></span><br><span class="line">如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span><br><span class="line"></span><br><span class="line">请必须使用时间复杂度为 <span class="built_in">O</span>(log n) 的算法。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">5</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">7</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">nums 为无重复元素的升序排列数组</span><br><span class="line"><span class="number">-104</span> &lt;= target &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、修改二分法模板的题目，</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == mid + <span class="number">1</span> ? l : mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(logn)</p></li><li><p>空间复杂度：O(1)</p><p>  ​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>284. 顶端迭代器</title>
    <link href="/2021/10/05/Leetcode/284/"/>
    <url>/2021/10/05/Leetcode/284/</url>
    
    <content type="html"><![CDATA[<h1 id="284-顶端迭代器"><a href="#284-顶端迭代器" class="headerlink" title="284. 顶端迭代器"></a><strong><a href="https://leetcode-cn.com/problems/peeking-iterator/">284. 顶端迭代器</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">请你设计一个迭代器，除了支持 hasNext 和 next 操作外，还支持 peek 操作。</span><br><span class="line"></span><br><span class="line">实现 PeekingIterator 类：</span><br><span class="line"></span><br><span class="line"><span class="built_in">PeekingIterator</span>(<span class="type">int</span>[] nums) 使用指定整数数组 nums 初始化迭代器。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> 返回数组中的下一个元素，并将指针移动到下个元素处。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> 如果数组中存在下一个元素，返回 <span class="literal">true</span> ；否则，返回 <span class="literal">false</span> 。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> 返回数组中的下一个元素，但 不 移动指针。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入：</span></span><br><span class="line"><span class="function">[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span></span><br><span class="line"><span class="function">[[[1, 2, 3]], [], [], [], [], []]</span></span><br><span class="line"><span class="function">输出：</span></span><br><span class="line"><span class="function">[null, 1, 2, 2, 3, <span class="literal">false</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">解释：</span></span><br><span class="line"><span class="function">PeekingIterator peekingIterator </span>= <span class="keyword">new</span> <span class="built_in">PeekingIterator</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [1,2,3]</span></span><br><span class="line">peekingIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 1 ，指针移动到下一个元素 [1,2,3]</span></span><br><span class="line">peekingIterator.<span class="built_in">peek</span>();    <span class="comment">// 返回 2 ，指针未发生移动 [1,2,3]</span></span><br><span class="line">peekingIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 2 ，指针移动到下一个元素 [1,2,3]</span></span><br><span class="line">peekingIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 3 ，指针移动到下一个元素 [1,2,3]</span></span><br><span class="line">peekingIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 False</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line">对 next 和 peek 的调用均有效</span><br><span class="line">next、hasNext 和 peek 最多调用  <span class="number">1000</span> 次</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>简单迭代器，主要考察迭代器的理解知识，常规的迭代器的「访问」只支持两种操作</li><li>hasNext() 操作：如果存在下一元素，返回 True，否则返回 False。实现上，就是判断游标是否到达结尾位置；</li><li>next() 操作：返回下一元素（当不存在下一元素时，返回 null）。实现上，就是返回游标指向的元素，并让游标后移。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment"> * **DO NOT** modify the interface for Iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  class Iterator &#123;</span></span><br><span class="line"><span class="comment"> *  struct Data;</span></span><br><span class="line"><span class="comment"> *   Data* data;</span></span><br><span class="line"><span class="comment"> *  public:</span></span><br><span class="line"><span class="comment"> *  Iterator(const vector&lt;int&gt;&amp; nums);</span></span><br><span class="line"><span class="comment"> *   Iterator(const Iterator&amp; iter);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment"> *  int next();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  // Returns true if the iteration has more elements.</span></span><br><span class="line"><span class="comment"> *  bool hasNext() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _next;</span><br><span class="line">    <span class="type">bool</span> _hasNext;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">     <span class="comment">// Initialize any member here.</span></span><br><span class="line">     <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">     <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">     _hasNext = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(_hasNext) _next = Iterator::<span class="built_in">next</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _next;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line"> <span class="comment">// Override them if needed.</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> dummy = _next;</span><br><span class="line">        _hasNext = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(_hasNext) _next = Iterator::<span class="built_in">next</span>();</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> _hasNext;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p><p>  ​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 26 26. 删除有序数组中的重复项</title>
    <link href="/2021/10/05/Leetcode/91-day/day-26/"/>
    <url>/2021/10/05/Leetcode/91-day/day-26/</url>
    
    <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><strong><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">给你一个有序数组 nums ，请你原地删除重复出现的元素，</span><br><span class="line"></span><br><span class="line">使每个元素只出现一次，返回删除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 <span class="built_in">O</span>(<span class="number">1</span>) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class="line"></span><br><span class="line">请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:</span><br><span class="line"></span><br><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span>, nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span> 。</span><br><span class="line"></span><br><span class="line">不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">nums 已按升序排列</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、简单题目，只需要使用双指针的解法即可，遇到跟 nums[l] 不相等的值就将 nums[r] 的值赋给 nums[l + 1] 即可。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] != nums[l])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++l] = nums[r];</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p><p>  ​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>482. 密钥格式化</title>
    <link href="/2021/10/04/Leetcode/482/"/>
    <url>/2021/10/04/Leetcode/482/</url>
    
    <content type="html"><![CDATA[<h1 id="482-密钥格式化"><a href="#482-密钥格式化" class="headerlink" title="482. 密钥格式化"></a><strong><a href="https://leetcode-cn.com/problems/license-key-formatting/">482. 密钥格式化</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">有一个密钥字符串 S ，只包含字母，数字以及 <span class="string">&#x27;-&#x27;</span>（破折号）。其中， N 个 <span class="string">&#x27;-&#x27;</span> 将字符串分成了 N<span class="number">+1</span> 组。</span><br><span class="line"></span><br><span class="line">给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 <span class="number">1</span> 个字符。两个分组之间需要用 <span class="string">&#x27;-&#x27;</span>（破折号）隔开，并且将所有的小写字母转换为大写字母。</span><br><span class="line"></span><br><span class="line">给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：S = <span class="string">&quot;5F3Z-2e-9-w&quot;</span>, K = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;5F3Z-2E9W&quot;</span></span><br><span class="line">解释：字符串 S 被分成了两个部分，每部分 <span class="number">4</span> 个字符；</span><br><span class="line">     注意，两个额外的破折号需要删掉。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：S = <span class="string">&quot;2-5g-3-J&quot;</span>, K = <span class="number">2</span></span><br><span class="line">输出：<span class="string">&quot;2-5G-3J&quot;</span></span><br><span class="line">解释：字符串 S 被分成了 <span class="number">3</span> 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 <span class="number">2</span> 个字符。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">S 的长度可能很长，请按需分配大小。K 为正整数。</span><br><span class="line">S 只包含字母数字（a-z，A-Z，<span class="number">0</span><span class="number">-9</span>）以及破折号<span class="string">&#x27;-&#x27;</span></span><br><span class="line">S 非空</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、简单题目，但是细节处理要处理好，也耽误自己接近半小时的时间</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">licenseKeyFormatting</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; i : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;z&#x27;</span>)  res += i - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n = res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> per = n / k;    <span class="comment">//能分均分几组</span></span><br><span class="line">        <span class="type">int</span> begin = n % k;  <span class="comment">//第一组有多少个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(begin == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i = i + k)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += res.<span class="built_in">substr</span>(i, k);</span><br><span class="line">                ans += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ans += res.<span class="built_in">substr</span>(<span class="number">0</span>, begin);</span><br><span class="line">            ans += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = begin; i &lt; n; i = i + k)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += res.<span class="built_in">substr</span>(i, k);</span><br><span class="line">                ans += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">/*  for(auto it = s.begin(); it != s.end(); it++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(*it == &#x27;-&#x27;)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                s.erase(it);</span></span><br><span class="line"><span class="comment">                it--;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else if(islower(*it)) //判断是否为小写字母</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                *it = toupper(*it);//将小写字母转换为大写字母</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int n = s.size();</span></span><br><span class="line"><span class="comment">        int begin = n % k;</span></span><br><span class="line"><span class="comment">        string ans = s.substr(0, begin);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i = begin; i &lt; n; i += k)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(i != 0) ans += &quot;-&quot;;</span></span><br><span class="line"><span class="comment">            ans += s.substr(i, k);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p><p>  ​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 25 876. 链表的中间结点</title>
    <link href="/2021/10/04/Leetcode/91-day/day-25/"/>
    <url>/2021/10/04/Leetcode/91-day/day-25/</url>
    
    <content type="html"><![CDATA[<h1 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><strong><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个头结点为 head 的非空单链表，返回链表的中间结点。</span><br><span class="line"></span><br><span class="line">如果有两个中间结点，则返回第二个中间结点。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">3</span> (序列化形式：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">返回的结点值为 <span class="number">3</span> 。 (测评系统对该结点序列化表述是 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = <span class="number">3</span>, ans.next.val = <span class="number">4</span>, ans.next.next.val = <span class="number">5</span>, 以及 ans.next.next.next = <span class="literal">NULL</span>.</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">4</span> (序列化形式：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">由于该列表有两个中间结点，值分别为 <span class="number">3</span> 和 <span class="number">4</span>，我们返回第二个结点。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">给定链表的结点数介于 <span class="number">1</span> 和 <span class="number">100</span> 之间。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、简单题目，开始思路为求其长度，奇数折半，偶数折半减一，优化后直接快慢指针即可。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* if(head -&gt; next == nullptr) return head;</span></span><br><span class="line"><span class="comment">        int len = 1;</span></span><br><span class="line"><span class="comment">        ListNode* fast = head;</span></span><br><span class="line"><span class="comment">        while(fast)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            fast = fast -&gt; next;</span></span><br><span class="line"><span class="comment">            len++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(len % 2 != 0) len /= 2;</span></span><br><span class="line"><span class="comment">        else len = len / 2 - 1;</span></span><br><span class="line"><span class="comment">        ListNode* slow = head;</span></span><br><span class="line"><span class="comment">        while(len)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            slow = slow -&gt; next;</span></span><br><span class="line"><span class="comment">            len--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return slow; */</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p><p>  ​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 24 924. 删除子列表以使总和可被 K 整除</title>
    <link href="/2021/10/03/Leetcode/91-day/day-24/"/>
    <url>/2021/10/03/Leetcode/91-day/day-24/</url>
    
    <content type="html"><![CDATA[<h1 id="924-删除子列表以使总和可被-K-整除"><a href="#924-删除子列表以使总和可被-K-整除" class="headerlink" title="924. 删除子列表以使总和可被 K 整除"></a><strong><a href="https://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K">924. 删除子列表以使总和可被 K 整除</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">You are given a list of positive integers nums </span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> a positive integer k. </span><br><span class="line"></span><br><span class="line"><span class="function">Return the length of the shortest <span class="title">sublist</span> <span class="params">(can be empty sublist )</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">you can <span class="keyword">delete</span> such that the resulting list&#x27;s sum is divisible by k.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> You cannot <span class="keyword">delete</span> the entire list. </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">If it&#x27;s <span class="keyword">not</span> possible, <span class="keyword">return</span> -1.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Constraints</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1 ≤ n ≤ 100,000 where n is the length of nums</span></span><br><span class="line"><span class="function">Example 1</span></span><br><span class="line"><span class="function">Input</span></span><br><span class="line"><span class="function">nums </span>= [<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">k = <span class="number">7</span></span><br><span class="line">Output</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Explanation</span><br><span class="line">We can remove the sublist [<span class="number">6</span>, <span class="number">4</span>] to get [<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>] </span><br><span class="line"></span><br><span class="line">which sums to <span class="number">14</span> <span class="keyword">and</span> is divisible by <span class="number">7.</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、数学中的同余定理，以及前缀和的思路！</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) </span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum % k;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; up;</span><br><span class="line">        up[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="type">int</span> re = pre % k;</span><br><span class="line">            up[re] = i;</span><br><span class="line">            <span class="type">int</span> x = pre - sum;</span><br><span class="line">            <span class="type">int</span> m = ((x % k) + k) % k;</span><br><span class="line">            <span class="keyword">if</span> (up.<span class="built_in">count</span>(m)) ans = <span class="built_in">min</span>(ans, i - up[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == nums.<span class="built_in">size</span>() ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 23 30. 串联所有单词的子串</title>
    <link href="/2021/10/02/Leetcode/91-day/day-23/"/>
    <url>/2021/10/02/Leetcode/91-day/day-23/</url>
    
    <content type="html"><![CDATA[<h1 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><strong><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一些 长度相同 的单词 words 。</span><br><span class="line"></span><br><span class="line">找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</span><br><span class="line"></span><br><span class="line">注意子串要与 words 中的单词完全匹配，</span><br><span class="line"></span><br><span class="line">中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;barfoothefoobarman&quot;</span>, words = [<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">解释：</span><br><span class="line">从索引 <span class="number">0</span> 和 <span class="number">9</span> 开始的子串分别是 <span class="string">&quot;barfoo&quot;</span> 和 <span class="string">&quot;foobar&quot;</span> 。</span><br><span class="line">输出的顺序不重要, [<span class="number">9</span>,<span class="number">0</span>] 也是有效答案。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;wordgoodgoodgoodbestword&quot;</span>, words = [<span class="string">&quot;word&quot;</span>,<span class="string">&quot;good&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;word&quot;</span>]</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;barfoofoobarthefoobarman&quot;</span>, words = [<span class="string">&quot;bar&quot;</span>,<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;the&quot;</span>]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">104</span></span><br><span class="line">s 由小写英文字母组成</span><br><span class="line"><span class="number">1</span> &lt;= words.length &lt;= <span class="number">5000</span></span><br><span class="line"><span class="number">1</span> &lt;= words[i].length &lt;= <span class="number">30</span></span><br><span class="line">words[i] 由小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><ul><li>1、困难题目，开局思考半小时，发现应该可以使用滑动窗口的解法</li><li>2、具体思想为使用两个 unordered_map，一个 up 来记录总的 words 里单词和对应的数量，另一个 ump 用来记录遍历的滑动窗口内的 words 中的单词和对应的数量。</li><li>3、遍历是增加一个单词长度，按照 ws 去移动窗口，对于每次档次遍历，维持窗口 l &#x3D; r</li><li>4、若单词在 ump 里不存在，重置窗口并清空 ump；</li><li>5、单词在 ump 里存在，有两种清空，单词出现的次数超出 ump 中的那一个单词的次数，所以需要将左边界增大，即右移 l，如果 cnt 都满足即等于 ns，则插入 l 作为当前的答案值</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || words.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span> ws = words[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//words中的word的长度，为统一长度</span></span><br><span class="line">        <span class="type">int</span> ns = words.<span class="built_in">size</span>();<span class="comment">//words中的word数量</span></span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; up; <span class="comment">//保存words中的word</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; w : words)</span><br><span class="line">        &#123;</span><br><span class="line">            up[w]++;<span class="comment">//记录每一个单词出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ws; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = i; <span class="comment">//从左开始</span></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//下文ump存放的单词总数！</span></span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; ump;</span><br><span class="line">            <span class="keyword">while</span>(r + ws &lt;= n)<span class="comment">//右边长度加每个单词长度要小于s的全长</span></span><br><span class="line">            &#123;</span><br><span class="line">                string res = s.<span class="built_in">substr</span>(r, ws); <span class="comment">//在右边界加入一个单词</span></span><br><span class="line">                r += ws;<span class="comment">//扩展右边界</span></span><br><span class="line">                <span class="keyword">if</span>(up.<span class="built_in">find</span>(res) != up.<span class="built_in">end</span>()) <span class="comment">//查看res在up中的位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ump[res]++;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">while</span>(ump[res] &gt; up[res])<span class="comment">// 需要检查数量是否超过，超过则要右移left</span></span><br><span class="line">                    &#123; <span class="comment">//来缩小窗口</span></span><br><span class="line">                        string tmp = s.<span class="built_in">substr</span>(l, ws);</span><br><span class="line">                        l += ws;</span><br><span class="line">                        cnt--;</span><br><span class="line">                        ump[tmp]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == ns) ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//未出现，舍弃此单词。清空</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l = r;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    ump.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：整体复杂度为 O(ns * ws)</p></li><li><p>空间复杂度：O(ns * ws)，可能有一些问题，有空再来思考</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 22 3. 无重复字符的最长子串</title>
    <link href="/2021/10/01/Leetcode/91-day/day-22/"/>
    <url>/2021/10/01/Leetcode/91-day/day-22/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><strong><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">5</span> * <span class="number">104</span></span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、本题是很经典的滑动窗口的题目，建立unordered_set集合，确认集合中没有重复元素，其中调用 unordered_set的find()方法，此方法返回一个迭代器，指向和参数哈希值匹配的元素，如果没有匹配的元素，会返回这个容器的结束迭代器。</li><li>2、本题只需要一直移入str，当str不满足题目意思时候，移除左边的元素，直到满足题目要求为止，便可以得到答案。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> str = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ans.<span class="built_in">find</span>(s[i]) != ans.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">erase</span>(s[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            str = <span class="built_in">max</span>(str, i - l + <span class="number">1</span>);</span><br><span class="line">            ans.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O($n$)</p></li><li><p>空间复杂度：O($n$)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>属于二战的一些个人的思考</title>
    <link href="/2021/10/01/summary/think/"/>
    <url>/2021/10/01/summary/think/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天想写一下二战考研的一些想法，因为自己的大学基础走的并不扎实，好好的自己个人的综合素质被自己用的叫做一塌糊涂，自己本科时候做的项目与竞赛没得一个能拿的出手的，自己大学也就做出了一个重要的决定，就是自己能在大一的时候转了专业。</p></blockquote><p>自己可惜在大学的时候没能多想一些，多行动一些，这样自己也能够学得更多，学的更加扎实一些。</p><p>如下：</p><blockquote><p>做任何选择都要做到”退可以守，进可以攻。”</p><p>本科理应先把基础打好，学得扎实一点，这样是最稳妥也最安全的，基础是经过千万人的检验，稳定可靠的东西，变化也最慢， 比如说算法和数据结构，操作系统编译原理，</p><p> 比如说高等数学和线性代数。</p><p>市面上那些花花闪闪的东西都根植于此，万变不离其宗。学通之后，市面上的很多看起来很高的行业壁垒也会不复存在，要退一步找到不那么前沿但需求旺盛的方向也相对方便。</p><p>如果这个基础上，能够足够牛，先试试水钻研某个 AI 的特定方向，技术文章看得多一点，挖得深一点，走得比别人快一点，知道的就比别人多，选择就比别人宽广，而且以后再做出来的选择也会更贴近自己的情况。现在网上各种资源那么多，好好学习提高，总不会是一件坏事。这和在哪个学校无关，在哪个专业也无关。</p><p>到这时候再回头看当时的计划，可能就会哑然失笑，因为远远有更多更好的选择在那里，只是当时坐井观天，以为世界就那么大。</p><p>作者：田渊栋<br>链接：<a href="https://www.zhihu.com/question/410286656/answer/1368251825">https://www.zhihu.com/question/410286656/answer/1368251825</a><br>来源：知乎</p></blockquote><p><img src="/images/somedays/1.png" alt="image1"></p><p>非常肯定这个大佬的说法。</p><p>所以自己在一战二战的过程中的收获也让自己走到了如今这个位置，数据结构与算法编程能力的提升，数学思维的提升，以及对语言的应用能力，英语阅读的能力。</p><p>虽然距离自己理想的状态差距还很大，但是逃离了学校，逃脱了一直陷在泥潭里面的室友，自己沉下心，还是能做很多很多的事情：早睡早起，坚持运动，学习技能，都是考研过程中所带给自己的。</p><p>想起儒家学说中，出于语出《礼记·中庸》的慎独自律精神，不仅只是要求自己的道德标杆，在现在这个社会，更体现在自律的习惯之上。</p>]]></content>
    
    
    <categories>
      
      <category>summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 21 447. 回旋镖的数量</title>
    <link href="/2021/09/30/Leetcode/91-day/day-21/"/>
    <url>/2021/09/30/Leetcode/91-day/day-21/</url>
    
    <content type="html"><![CDATA[<h1 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="447. 回旋镖的数量"></a><strong><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。</span><br><span class="line"></span><br><span class="line">回旋镖 是由点 (i, j, k) 表示的元组 ，</span><br><span class="line"></span><br><span class="line">其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。</span><br><span class="line"></span><br><span class="line">返回平面上所有回旋镖的数量。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：两个回旋镖为 [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]] 和 [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line">    </span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == points.length</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">500</span></span><br><span class="line">points[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">-104</span> &lt;= xi, yi &lt;= <span class="number">104</span></span><br><span class="line">所有点都 互不相同</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、本题的问题翻译成人话就是求二维平面上所给出的点组成等腰三角形的两条腰边三个顶点，返回其总数。</li><li>2、使用unordered_map进行处理，然后确定i为三元组第一位的回旋镖个数前，先计算出i和其余点的距离，并以 {距离 : 个数} 进行存储，最后分别对所有的距离进行累加计数。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; up;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> x = p[i][<span class="number">0</span>] - p[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = p[i][<span class="number">1</span>] - p[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> d = x * x + y *y;</span><br><span class="line">                ++up[d];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [d, cnt] : up)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += cnt * (cnt - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O($n^2$)</p></li><li><p>空间复杂度：O($n$)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 20 347. 前 K 个高频元素</title>
    <link href="/2021/09/29/Leetcode/91-day/day-20/"/>
    <url>/2021/09/29/Leetcode/91-day/day-20/</url>
    
    <content type="html"><![CDATA[<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><strong><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个整数 k ，</span><br><span class="line"></span><br><span class="line">请你返回其中出现频率前 k 高的元素。</span><br><span class="line"></span><br><span class="line">你可以按 任意顺序 返回答案。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">105</span></span><br><span class="line">k 的取值范围是 [<span class="number">1</span>, 数组中不相同的元素的个数]</span><br><span class="line">题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你所设计算法的时间复杂度 必须 优于 <span class="built_in">O</span>(n log n) ，其中 n 是数组大小。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、典型的大顶堆问题，可以建立一个无序的unordered_map保存键值对，而后在建立一个priority_queue，因为C++中priority_queue默认是大顶堆的建立，故将unordered_map中的序列对{k,v}序列改为{v,k}即可保存在priority_queue中。然后输出前n个键值对的v值即可。</li><li>2、进阶版可以手写一个堆替换priority_queue，等以后有时间再来补坑。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; up;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) up[i]++;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = up.<span class="built_in">begin</span>(); it != up.<span class="built_in">end</span>(); it++) </span><br><span class="line">        &#123;</span><br><span class="line">            p.<span class="built_in">push</span>(&#123;it -&gt; second, it -&gt; first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(n--) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(p.<span class="built_in">top</span>().second);</span><br><span class="line">            p.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>priority_queue</tag>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 19 1. 两数之和</title>
    <link href="/2021/09/28/Leetcode/91-day/day-19/"/>
    <url>/2021/09/28/Leetcode/91-day/day-19/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><strong><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，</span><br><span class="line"></span><br><span class="line">请你在该数组中找出 和为目标值 target 的那两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-109</span> &lt;= nums[i] &lt;= <span class="number">109</span></span><br><span class="line"><span class="number">-109</span> &lt;= target &lt;= <span class="number">109</span></span><br><span class="line">只会存在一个有效答案</span><br><span class="line">进阶：你可以想出一个时间复杂度小于 <span class="built_in">O</span>(n2) 的算法吗？</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、暴力解没什么好说的，主要是回忆一下unordered_map的相关使用方法，具体可以看本博客去年的总结。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = umap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != umap.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it -&gt; second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)，仅需一次遍历即可</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day 18 987. 二叉树的垂序遍历</title>
    <link href="/2021/09/27/Leetcode/91-day/day-18/"/>
    <url>/2021/09/27/Leetcode/91-day/day-18/</url>
    
    <content type="html"><![CDATA[<h1 id="987-二叉树的垂序遍历"><a href="#987-二叉树的垂序遍历" class="headerlink" title="987. 二叉树的垂序遍历"></a><strong><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">给你二叉树的根结点 root ，</span><br><span class="line"></span><br><span class="line">请你设计算法计算二叉树的 垂序遍历 序列。</span><br><span class="line"></span><br><span class="line">对位于 (row, col) 的每个结点而言，</span><br><span class="line"></span><br><span class="line">其左右子结点分别位于 (row + <span class="number">1</span>, col - <span class="number">1</span>) 和 (row + <span class="number">1</span>, col + <span class="number">1</span>) 。</span><br><span class="line"></span><br><span class="line">树的根结点位于 (<span class="number">0</span>, <span class="number">0</span>) 。</span><br><span class="line"></span><br><span class="line">二叉树的垂序遍历从最左边的列开始直到最右边的列结束，</span><br><span class="line"></span><br><span class="line">按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。</span><br><span class="line"></span><br><span class="line">如果同行同列上有多个结点，则按结点的值从小到大进行排序。</span><br><span class="line"></span><br><span class="line">返回二叉树的 垂序遍历 序列。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">9</span>],[<span class="number">3</span>,<span class="number">15</span>],[<span class="number">20</span>],[<span class="number">7</span>]]</span><br><span class="line">解释：</span><br><span class="line">列 <span class="number">-1</span> ：只有结点 <span class="number">9</span> 在此列中。</span><br><span class="line">列  <span class="number">0</span> ：只有结点 <span class="number">3</span> 和 <span class="number">15</span> 在此列中，按从上到下顺序。</span><br><span class="line">列  <span class="number">1</span> ：只有结点 <span class="number">20</span> 在此列中。</span><br><span class="line">列  <span class="number">2</span> ：只有结点 <span class="number">7</span> 在此列中。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">4</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">解释：</span><br><span class="line">列 <span class="number">-2</span> ：只有结点 <span class="number">4</span> 在此列中。</span><br><span class="line">列 <span class="number">-1</span> ：只有结点 <span class="number">2</span> 在此列中。</span><br><span class="line">列  <span class="number">0</span> ：结点 <span class="number">1</span> 、<span class="number">5</span> 和 <span class="number">6</span> 都在此列中。</span><br><span class="line">          <span class="number">1</span> 在上面，所以它出现在前面。</span><br><span class="line">          <span class="number">5</span> 和 <span class="number">6</span> 位置都是 (<span class="number">2</span>, <span class="number">0</span>) ，所以按值从小到大排序，<span class="number">5</span> 在 <span class="number">6</span> 的前面。</span><br><span class="line">列  <span class="number">1</span> ：只有结点 <span class="number">3</span> 在此列中。</span><br><span class="line">列  <span class="number">2</span> ：只有结点 <span class="number">7</span> 在此列中。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">4</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>],[<span class="number">7</span>]]</span><br><span class="line">解释：</span><br><span class="line">这个示例实际上与示例 <span class="number">2</span> 完全相同，只是结点 <span class="number">5</span> 和 <span class="number">6</span> 在树中的位置发生了交换。</span><br><span class="line">因为 <span class="number">5</span> 和 <span class="number">6</span> 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中结点数目总数在范围 [<span class="number">1</span>, <span class="number">1000</span>] 内</span><br><span class="line"><span class="number">0</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、本质上还是 DFS 与 BFS 题目，此题目只是解决问题的方式要麻烦一点，所以花费时间较长，本质上应该属于中等题类，算不上难度的题目</li><li>2、DFS 采用哈希表加优先队列，其中由于 c++的 priority_queue 的实现为大根堆，此题目属于小根堆的实现，所以使用 multiset(小根堆)实现。</li><li>3、BFS 留待考研后再写，现在每日思考一个小时时间题目时间太多了。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;<span class="type">int</span>, multiset&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; maps;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> x, <span class="type">int</span> y, maps &amp;mp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        mp[y].<span class="built_in">insert</span>(&#123;x, root-&gt;val&#125;);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left ) <span class="built_in">dfs</span>(root -&gt; left, x + <span class="number">1</span>, y - <span class="number">1</span>, mp);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; right) <span class="built_in">dfs</span>(root -&gt; right, x + <span class="number">1</span>, y + <span class="number">1</span>, mp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        maps mp;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, <span class="number">0</span>, mp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; [k, v] : mp)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vs;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; p : v) vs.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n*logn)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>multiset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-17 297. 二叉树的序列化与反序列化</title>
    <link href="/2021/09/26/Leetcode/91-day/day-17/"/>
    <url>/2021/09/26/Leetcode/91-day/day-17/</url>
    
    <content type="html"><![CDATA[<h1 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><strong><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">序列化是将一个数据结构或者对象转换为连续的比特位的操作，</span><br><span class="line"></span><br><span class="line">进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，</span><br><span class="line"></span><br><span class="line">采取相反方式重构得到原数据。</span><br><span class="line"></span><br><span class="line">请设计一个算法来实现二叉树的序列化与反序列化。</span><br><span class="line"></span><br><span class="line">这里不限定你的序列 / 反序列化算法执行逻辑，</span><br><span class="line"></span><br><span class="line">你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</span><br><span class="line"></span><br><span class="line">提示: 输入输出格式与 LeetCode 目前使用的方式一致，</span><br><span class="line"></span><br><span class="line">详情请参阅 LeetCode 序列化二叉树的格式。</span><br><span class="line"></span><br><span class="line">你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中结点数在范围 [<span class="number">0</span>, <span class="number">104</span>] 内</span><br><span class="line"><span class="number">-1000</span> &lt;= Node.val &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、本质上还是 DFS 与 BFS 题目，但是此题目难度较大，所以花费时间较长。</li><li>2、dfs 有两种形式前序 dfs，后面还有后序 dfs，后序遍历因为时间限制，暂时不去写，而中序由于无法确定根节点，所以无法形成递归形式</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* void predfs(TreeNode* root, string&amp; data)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(root == nullptr) data += &quot;null,&quot;;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            data += to_string(root -&gt; val) + &quot;,&quot;;</span></span><br><span class="line"><span class="comment">            predfs(root -&gt; left, data);</span></span><br><span class="line"><span class="comment">            predfs(root -&gt; right, data);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    string serialize(TreeNode* root)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        string data;</span></span><br><span class="line"><span class="comment">        predfs(root, data);</span></span><br><span class="line"><span class="comment">        return data;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeNode* rdfs(list&lt;string&gt;&amp; str)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (str.front() == &quot;null&quot;)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            str.erase(str.begin());</span></span><br><span class="line"><span class="comment">            return nullptr;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        TreeNode* root = new TreeNode(stoi(str.front()));</span></span><br><span class="line"><span class="comment">        str.erase(str.begin());</span></span><br><span class="line"><span class="comment">        root -&gt; left = rdfs(str);</span></span><br><span class="line"><span class="comment">        root -&gt; right = rdfs(str);</span></span><br><span class="line"><span class="comment">        return root;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeNode* deserialize(string data)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        list&lt;string&gt; str;</span></span><br><span class="line"><span class="comment">        string s;</span></span><br><span class="line"><span class="comment">        for (auto&amp; ch : data)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if (ch == &#x27;,&#x27;)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                str.push_back(s);</span></span><br><span class="line"><span class="comment">                s.clear();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else s.push_back(ch);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (s.empty() != 0)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            str.push_back(s);</span></span><br><span class="line"><span class="comment">            s.clear();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return rdfs(str);</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        queue&lt;TreeNode* &gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) ans += <span class="string">&quot;null,&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        vector&lt;TreeNode* &gt; ans;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(k &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp;</span><br><span class="line">            <span class="keyword">while</span>(data[k] != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp += data[k];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">&quot;null&quot;</span>) ans.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> ans.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(tmp)));</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans[i] -&gt; left = ans[pos++];</span><br><span class="line">            ans[i] -&gt; right = ans[pos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-16 513. 找树左下角的值</title>
    <link href="/2021/09/25/Leetcode/91-day/day-16/"/>
    <url>/2021/09/25/Leetcode/91-day/day-16/</url>
    
    <content type="html"><![CDATA[<h1 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><strong><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</span><br><span class="line"></span><br><span class="line">假设二叉树中至少有一个节点。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,null,<span class="number">5</span>,<span class="number">6</span>,null,null,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">二叉树的节点个数的范围是 [<span class="number">1</span>,<span class="number">104</span>]</span><br><span class="line"><span class="number">-231</span> &lt;= Node.val &lt;= <span class="number">231</span> - <span class="number">1</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、DFS 与 BFS 题目，DFS 变式多，BFS 单一，更简单。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* int findBottomLeftValue(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">        queue&lt;TreeNode* &gt; q;</span></span><br><span class="line"><span class="comment">        if(root != NULL) q.push(root);</span></span><br><span class="line"><span class="comment">        int result = 0;</span></span><br><span class="line"><span class="comment">        while (!q.empty())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int n = q.size();</span></span><br><span class="line"><span class="comment">            for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                TreeNode* node = q.front();</span></span><br><span class="line"><span class="comment">                q.pop();</span></span><br><span class="line"><span class="comment">                if(i == 0) result = node-&gt;val;</span></span><br><span class="line"><span class="comment">                if(node -&gt; left != nullptr) q.push(node -&gt; left);</span></span><br><span class="line"><span class="comment">                if(node -&gt; right != nullptr) q.push(node -&gt; right);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result; */</span></span><br><span class="line">        <span class="type">int</span> len = INT_MIN;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> deep)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(deep &gt; len)</span><br><span class="line">                    &#123;</span><br><span class="line">                        len = deep;</span><br><span class="line">                        value = root -&gt; val;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">dfs</span>(root -&gt; left, deep + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">dfs</span>(root -&gt; right, deep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-15 129. 求根节点到叶节点数字之和</title>
    <link href="/2021/09/24/Leetcode/91-day/day-15/"/>
    <url>/2021/09/24/Leetcode/91-day/day-15/</url>
    
    <content type="html"><![CDATA[<h1 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><strong><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树的根节点 root ，树中每个节点都存放有一个 <span class="number">0</span> 到 <span class="number">9</span> 之间的数字。</span><br><span class="line">每条从根节点到叶节点的路径都代表一个数字：</span><br><span class="line"></span><br><span class="line">例如，从根节点到叶节点的路径 <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> 表示数字 <span class="number">123</span> 。</span><br><span class="line">计算从根节点到叶节点生成的 所有数字之和 。</span><br><span class="line"></span><br><span class="line">叶节点 是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1026</span></span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026</span></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中节点的数目在范围 [<span class="number">1</span>, <span class="number">1000</span>] 内</span><br><span class="line"><span class="number">0</span> &lt;= Node.val &lt;= <span class="number">9</span></span><br><span class="line">树的深度不超过 <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、DFS 与 BFS 题目，DFS 变式多，BFS 单一，更简单。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* return dfs(root, 0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int dfs(TreeNode* root, int pre)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(root == nullptr) return 0;</span></span><br><span class="line"><span class="comment">        int sum = 10 * pre + root -&gt; val;</span></span><br><span class="line"><span class="comment">        if(root -&gt; left == nullptr &amp;&amp; root -&gt; right == nullptr) return sum;</span></span><br><span class="line"><span class="comment">        else return dfs(root -&gt; left, sum) + dfs(root -&gt; right, sum); */</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode* &gt;q1;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(root);</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(root -&gt; val);</span><br><span class="line">        <span class="keyword">while</span>(q<span class="number">1.</span><span class="built_in">empty</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* n = q<span class="number">1.f</span>ront();</span><br><span class="line">            <span class="type">int</span> num = q<span class="number">2.f</span>ront();</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* l = n -&gt; left;</span><br><span class="line">            TreeNode* r = n -&gt; right;</span><br><span class="line">            <span class="keyword">if</span>(l == <span class="literal">nullptr</span> &amp;&amp; r == <span class="literal">nullptr</span>)</span><br><span class="line">                sum += num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l != <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q<span class="number">1.</span><span class="built_in">push</span>(l);</span><br><span class="line">                    q<span class="number">2.</span><span class="built_in">push</span>(num * <span class="number">10</span> + l -&gt; val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(r != <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q<span class="number">1.</span><span class="built_in">push</span>(r);</span><br><span class="line">                    q<span class="number">2.</span><span class="built_in">push</span>(num * <span class="number">10</span> + r -&gt; val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-14 100. 相同的树</title>
    <link href="/2021/09/23/Leetcode/91-day/day-14/"/>
    <url>/2021/09/23/Leetcode/91-day/day-14/</url>
    
    <content type="html"><![CDATA[<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><strong><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span><br><span class="line"></span><br><span class="line">如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], q = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>], q = [<span class="number">1</span>,null,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], q = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">两棵树上的节点数目都在范围 [<span class="number">0</span>, <span class="number">100</span>] 内</span><br><span class="line"><span class="number">-104</span> &lt;= Node.val &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、简单题，与昨日一模一样，可以使用递归解决问题，也可以进行层序遍历，熟悉一下 BFS 的模板。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* if (p == nullptr &amp;&amp; q == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125; else if (p == nullptr || q == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125; else if (p-&gt;val != q-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue &lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(p);</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(q);</span><br><span class="line">        <span class="keyword">while</span> (q<span class="number">1.</span><span class="built_in">empty</span>() == <span class="number">0</span> &amp;&amp; q<span class="number">2.</span><span class="built_in">empty</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n1 = q<span class="number">1.f</span>ront();</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> n2 = q<span class="number">2.f</span>ront();</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (n1 -&gt; val != n2 -&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">auto</span> l1 = n1 -&gt; left, r1 = n1 -&gt; right, l2 = n2 -&gt; left, r2 = n2 -&gt; right;</span><br><span class="line">            <span class="keyword">if</span> ((l1 == <span class="literal">nullptr</span>) ^ (l2 == <span class="literal">nullptr</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> ((r1 == <span class="literal">nullptr</span>) ^ (r2 == <span class="literal">nullptr</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>) q<span class="number">1.</span><span class="built_in">push</span>(l1);</span><br><span class="line">            <span class="keyword">if</span> (r1 != <span class="literal">nullptr</span>) q<span class="number">1.</span><span class="built_in">push</span>(r1);</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>) q<span class="number">2.</span><span class="built_in">push</span>(l2);</span><br><span class="line">            <span class="keyword">if</span> (r2 != <span class="literal">nullptr</span>) q<span class="number">2.</span><span class="built_in">push</span>(r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; q<span class="number">2.</span><span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(min(n, m))</p></li><li><p>空间复杂度：O(min(n, m))，递归调用栈，栈使用的空间即为二叉树的高度、层序遍历为 O(n)，存放所有的节点数;</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-13 104. 二叉树的最大深度</title>
    <link href="/2021/09/22/Leetcode/91-day/day-13/"/>
    <url>/2021/09/22/Leetcode/91-day/day-13/</url>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，找出其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、简单题，可以使用递归解决问题，也可以进行层序遍历，熟悉一下 BFS 的模板。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* if (root == nullptr) return 0;</span></span><br><span class="line"><span class="comment">        int l, r;</span></span><br><span class="line"><span class="comment">        l = maxDepth(root -&gt; left);</span></span><br><span class="line"><span class="comment">        r = maxDepth(root -&gt; right);</span></span><br><span class="line"><span class="comment">        return一些 max(l, r) + 1; */</span></span><br><span class="line">        <span class="comment">//以下为BFS</span></span><br><span class="line">        queue&lt;TreeNode* &gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            tmp++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* res = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(res -&gt; left != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(res -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(res -&gt; right != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(res -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)，因为要遍历所有节点，层序遍历时间复杂度也是 O(n);</p></li><li><p>空间复杂度：O(height)，递归调用栈，栈使用的空间即为二叉树的高度、层序遍历为 O(n)，存放所有的节点数;</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-12 146. LRU 缓存机制</title>
    <link href="/2021/09/21/Leetcode/91-day/day-12/"/>
    <url>/2021/09/21/Leetcode/91-day/day-12/</url>
    
    <content type="html"><![CDATA[<h1 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><strong><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">运用你所掌握的数据结构，设计和实现一个  <span class="built_in">LRU</span> (最近最少使用) 缓存机制 。</span><br><span class="line">实现 LRUCache 类：</span><br><span class="line"></span><br><span class="line"><span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> 如果关键字已经存在，则变更其数据值；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果关键字不存在，则插入该组「关键字-值」。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">进阶：你是否可以在 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span> 时间复杂度内完成这两种操作？</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入</span></span><br><span class="line"><span class="function">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span></span><br><span class="line"><span class="function">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span></span><br><span class="line"><span class="function">输出</span></span><br><span class="line"><span class="function">[null, null, null, 1, null, -1, null, -1, 3, 4]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">解释</span></span><br><span class="line"><span class="function">LRUCache lRUCache </span>= <span class="keyword">new</span> <span class="built_in">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">lRUCache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 缓存是 &#123;1=1&#125;</span></span><br><span class="line">lRUCache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line">lRUCache.<span class="built_in">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">lRUCache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="built_in">get</span>(<span class="number">2</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line">lRUCache.<span class="built_in">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">lRUCache.<span class="built_in">get</span>(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">lRUCache.<span class="built_in">get</span>(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= capacity &lt;= <span class="number">3000</span></span><br><span class="line"><span class="number">0</span> &lt;= key &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">0</span> &lt;= value &lt;= <span class="number">105</span></span><br><span class="line">最多调用 <span class="number">2</span> * <span class="number">105</span> 次 get 和 put</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、补昨天的相应解答，本题需要自己实现一个LRU缓存机制，通过操作系统的相应学习，以及题目所给条件，代码相应实现应该是属于一个哈希表加相应的双链表进行实现，其中双链表需要实现移除、插入、修改等操作，实现起来比较有难度，而哈希表可以使用STL库中的unordered_map函数进行相应的实现！</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> key, value;</span><br><span class="line">        Node* left ,*right;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> _key,<span class="type">int</span> _value) &#123;</span><br><span class="line">            <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *l, *r;      <span class="comment">//双链表的最左和最右节点，不存贮值。</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt;hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p -&gt; right -&gt; left = p - left;</span><br><span class="line">        p -&gt; left -&gt; right = p -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p -&gt; right = l -&gt; right;</span><br><span class="line">        p -&gt; left = l;</span><br><span class="line">        l -&gt; right -&gt; left = p;</span><br><span class="line">        l -&gt; right = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) </span><br><span class="line">    &#123;</span><br><span class="line">        n = capacity;</span><br><span class="line">        l = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        r = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        l -&gt; right = r;</span><br><span class="line">        r -&gt; left = l;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">count</span>(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//不存在关键字key </span></span><br><span class="line">        <span class="keyword">auto</span> p = hash[key];</span><br><span class="line">        <span class="built_in">remove</span>(p);</span><br><span class="line">        <span class="built_in">insert</span>(p);                              <span class="comment">//将当前节点放在双链表的第一位</span></span><br><span class="line">        <span class="keyword">return</span> p -&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">count</span>(key))                   <span class="comment">//如果key存在，则修改对应的value</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = hash[key];</span><br><span class="line">            p -&gt; value = value;</span><br><span class="line">            <span class="built_in">remove</span>(p);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">size</span>() == n)              <span class="comment">//如果缓存已满，则删除双链表最右侧的节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span>  p = r -&gt; left;</span><br><span class="line">                <span class="built_in">remove</span>(p);</span><br><span class="line">                hash.<span class="built_in">erase</span>(p -&gt; key);         <span class="comment">//更新哈希表</span></span><br><span class="line">                <span class="keyword">delete</span> p;                     <span class="comment">//释放内存，c++注意内存管理</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);    <span class="comment">//否则，插入(key, value)</span></span><br><span class="line">            hash[key] = p;</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(1)，都是常数级复杂度;</p></li><li><p>空间复杂度：O(capacity + 1);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linklist</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-11 142. 环形链表 II</title>
    <link href="/2021/09/20/Leetcode/91-day/day-11/"/>
    <url>/2021/09/20/Leetcode/91-day/day-11/</url>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line"></span><br><span class="line">为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 <span class="number">0</span> 开始）。</span><br><span class="line"></span><br><span class="line">如果 pos 是 <span class="number">-1</span>，则在该链表中没有环。</span><br><span class="line"></span><br><span class="line">注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</span><br><span class="line"></span><br><span class="line">说明：不允许修改给定的链表。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你是否可以使用 <span class="built_in">O</span>(<span class="number">1</span>) 空间解决此题？</span><br><span class="line"> </span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：返回索引为 <span class="number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点的数目范围在范围 [<span class="number">0</span>, <span class="number">104</span>] 内</span><br><span class="line"><span class="number">-105</span> &lt;= Node.val &lt;= <span class="number">105</span></span><br><span class="line">pos 的值为 <span class="number">-1</span> 或者链表中的一个有效索引</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、经典双指针问题，同时与昨日题目一样，也可以使用哈希表解法，同理哈希表也是效果不佳的实现办法，空间复杂度较高。</li><li>2、双指针完整证明解析如官方题解所示，在此不在赘述。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = head;</span><br><span class="line">                <span class="keyword">while</span>(tmp != slow)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = tmp -&gt; next;</span><br><span class="line">                    slow = slow -&gt; next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* if(head == NULL || head -&gt; next == nullptr) return NULL;</span></span><br><span class="line"><span class="comment">        unordered_set&lt;ListNode* &gt; m;</span></span><br><span class="line"><span class="comment">        ListNode* fast = head;</span></span><br><span class="line"><span class="comment">        while(fast -&gt; next != nullptr)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(m.count(fast) != 0) return fast;</span></span><br><span class="line"><span class="comment">            m.insert(fast);</span></span><br><span class="line"><span class="comment">            fast = fast -&gt; next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return nullptr; */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)、哈希表为 O(n);</p></li><li><p>空间复杂度：O(1)、哈希表为 O(n);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-10 160. 相交链表</title>
    <link href="/2021/09/19/Leetcode/91-day/day-10/"/>
    <url>/2021/09/19/Leetcode/91-day/day-10/</url>
    
    <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><strong><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">给你两个单链表的头节点 headA 和 headB ，</span><br><span class="line"></span><br><span class="line">请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</span><br><span class="line"></span><br><span class="line">图示两个链表在节点 c1 开始相交：</span><br><span class="line"></span><br><span class="line">题目数据 保证 整个链式结构中不存在环。</span><br><span class="line"></span><br><span class="line">注意，函数返回结果后，链表必须 保持其原始结构 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at <span class="string">&#x27;8&#x27;</span></span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。</span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：intersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Intersected at <span class="string">&#x27;2&#x27;</span></span><br><span class="line">解释：相交节点的值为 <span class="number">2</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。</span><br><span class="line">在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">listA 中节点数目为 m</span><br><span class="line">listB 中节点数目为 n</span><br><span class="line"><span class="number">0</span> &lt;= m, n &lt;= <span class="number">3</span> * <span class="number">104</span></span><br><span class="line"><span class="number">1</span> &lt;= Node.val &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">0</span> &lt;= skipA &lt;= m</span><br><span class="line"><span class="number">0</span> &lt;= skipB &lt;= n</span><br><span class="line">如果 listA 和 listB 没有交点，intersectVal 为 <span class="number">0</span></span><br><span class="line">如果 listA 和 listB 有交点，intersectVal == listA[skipA + <span class="number">1</span>] == listB[skipB + <span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你能否设计一个时间复杂度 <span class="built_in">O</span>(n) 、仅用 <span class="built_in">O</span>(<span class="number">1</span>) 内存的解决方案？</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、经典双指针问题，如果A、B中有一个为空，则无交点。</li><li>2、如果相交则不用证明其正确信，不相交则相互遍历到最终的结果都为nullptr，经过 m + n次。</li><li>3、哈希表好理解一些，当计数count函数出现q时候，即可返回相交节点值，否则返回nullptr</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* if(headA == nullptr || headB == nullptr) return nullptr;</span></span><br><span class="line"><span class="comment">        ListNode* p = headA;</span></span><br><span class="line"><span class="comment">        ListNode* q = headB;</span></span><br><span class="line"><span class="comment">        while(p != q)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p = p == nullptr ? headB : p -&gt; next; </span></span><br><span class="line"><span class="comment">            q = q == nullptr ? headA : q -&gt; next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return p; */</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_set&lt;ListNode* &gt; vis;</span><br><span class="line">        ListNode* p = headA;</span><br><span class="line">        ListNode* q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vis.<span class="built_in">insert</span>(p);</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis.<span class="built_in">count</span>(q)) <span class="keyword">return</span> q;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)、哈希表也是O(n);</p></li><li><p>空间复杂度：O(1)、哈希表为O(n);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-09 109. 有序链表转换二叉搜索树</title>
    <link href="/2021/09/18/Leetcode/91-day/day-09/"/>
    <url>/2021/09/18/Leetcode/91-day/day-09/</url>
    
    <content type="html"><![CDATA[<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><strong><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><br><span class="line"></span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定的有序链表： [<span class="number">-10</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="number">0</span>, <span class="number">-3</span>, <span class="number">9</span>, <span class="number">-10</span>, null, <span class="number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="number">-3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="number">-10</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、本题相当于将链表转化为一个二叉搜索树(Binary Search Tree : BST)</li><li>2、基于中序遍历恢复二叉搜索树，即可从任意节点出发，以节点左边的升序序列作为左子树，右边升序序列为右子树，即可得到二叉搜索树，本题要建立一个高度平衡的二叉搜索树，那么左右高度差至多为 1，故从链表的中点开始建立二叉搜索树最好。</li><li>3、本题也可以用 BFS 建树，DFS 填节点值，但这样空间复杂度较高，时间复杂度跟递归链表差不多的情况下，确实不是特别优秀的解法，不过也可以用来熟悉一下 DFS 与 BFS。</li></ul><h3 id="代码块。"><a href="#代码块。" class="headerlink" title="代码块。"></a>代码块。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : </span></span><br><span class="line"><span class="comment">        val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; next == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(head -&gt; val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast -&gt; next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        len = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* p = slow;</span><br><span class="line">        <span class="keyword">while</span>(len--)</span><br><span class="line">        &#123;</span><br><span class="line">            p = slow;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(slow -&gt; val);</span><br><span class="line">        root -&gt; left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        root -&gt; right = <span class="built_in">sortedListToBST</span>(slow -&gt; next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(log n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-08 24. 两两交换链表中的节点</title>
    <link href="/2021/09/17/Leetcode/91-day/day-08/"/>
    <url>/2021/09/17/Leetcode/91-day/day-08/</url>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line"></span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点的数目在范围 [<span class="number">0</span>, <span class="number">100</span>] 内</span><br><span class="line"><span class="number">0</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、最简单的思路自然是递归的思路</li><li>2、而递归调用的也是栈的实现方法，所以自然也能想到栈的相应的做法。</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">stack&lt;ListNode* &gt; stk;</span><br><span class="line">ListNode* p = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">ListNode* pos = head;</span><br><span class="line">        head = p;</span><br><span class="line"><span class="keyword">while</span>(pos != <span class="literal">nullptr</span> &amp;&amp; pos -&gt; next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">stk.<span class="built_in">push</span>(pos);</span><br><span class="line">stk.<span class="built_in">push</span>(pos -&gt; next);</span><br><span class="line">pos = pos -&gt; next -&gt; next;</span><br><span class="line">p -&gt; next = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">p -&gt; next = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos != <span class="literal">nullptr</span>) p -&gt; next = pos;</span><br><span class="line">    <span class="keyword">else</span> p -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> head -&gt; next;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (head == nullptr || head-&gt;next == nullptr) return head;</span></span><br><span class="line"><span class="comment">        ListNode* p = head -&gt; next;</span></span><br><span class="line"><span class="comment">        head -&gt; next = swapPairs(p -&gt; next);</span></span><br><span class="line"><span class="comment">        p -&gt; next = head;</span></span><br><span class="line"><span class="comment">        return p;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(n)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-07 61. 旋转链表</title>
    <link href="/2021/09/16/Leetcode/91-day/day-07/"/>
    <url>/2021/09/16/Leetcode/91-day/day-07/</url>
    
    <content type="html"><![CDATA[<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><strong><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点的数目在范围 [<span class="number">0</span>, <span class="number">500</span>] 内</span><br><span class="line"><span class="number">-100</span> &lt;= Node.val &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">2</span> * <span class="number">109</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、搞清楚 len - 1 - k % len 后是尾节点即可弄明白此题目</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast -&gt; next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        fast -&gt; next = head;</span><br><span class="line">        k = len - <span class="number">1</span> - k % len; <span class="comment">//此处注意移动k步后的末尾节点,鄙人在此卡了接近半小时</span></span><br><span class="line">        <span class="keyword">if</span>(k == len) <span class="keyword">return</span> head;<span class="comment">//最后想明白了len - 1是链表尾节点，k % len为剩余步数</span></span><br><span class="line">        <span class="keyword">while</span>(k)     <span class="comment">//len - 1 - k % n为尾节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow -&gt; next;</span><br><span class="line">        slow -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n),遍历两次链表</p></li><li><p>空间复杂度：O(1)，常数级</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linklist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-06 768. 最多能完成排序的块 II</title>
    <link href="/2021/09/15/Leetcode/91-day/day-06/"/>
    <url>/2021/09/15/Leetcode/91-day/day-06/</url>
    
    <content type="html"><![CDATA[<h1 id="768-最多能完成排序的块-II"><a href="#768-最多能完成排序的块-II" class="headerlink" title="768. 最多能完成排序的块 II"></a><strong><a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">这个问题和“最多能完成排序的块”相似，</span><br><span class="line"></span><br><span class="line">但给定数组中的元素可以重复，输入数组最大长度为<span class="number">2000</span>，其中的元素最大为<span class="number">10</span>^<span class="number">8</span>。</span><br><span class="line"></span><br><span class="line">arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，</span><br><span class="line"></span><br><span class="line">并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</span><br><span class="line"></span><br><span class="line">我们最多能将数组分成多少块？</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释:</span><br><span class="line">将数组分成<span class="number">2</span>块或者更多块，都无法得到所需的结果。</span><br><span class="line">例如，分成 [<span class="number">5</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 的结果是 [<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]，这不是有序的数组。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释:</span><br><span class="line">我们可以把它分成两块，例如 [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]。</span><br><span class="line">然而，分成 [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>], [<span class="number">4</span>], [<span class="number">4</span>] 可以得到最多的块数。</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">arr的长度在[<span class="number">1</span>, <span class="number">2000</span>]之间。</span><br><span class="line">arr[i]的大小在[<span class="number">0</span>, <span class="number">10</span>**<span class="number">8</span>]之间。</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、分块排序，组合之后与原数组进行升序排序要相同</li><li>2、所以可以采用动态规划的思想，前一个块的最大值要小于下一个块的最小值，这样分块排序合并之后也会与原数组升序排序一致。</li><li>3、</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxChunksToSorted</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 虽然能通过但是时间复杂度太高，两者比较与清空操作要花费较多的时间开销</span></span><br><span class="line"><span class="comment">           解法并不优秀。</span></span><br><span class="line"><span class="comment">        int n = arr.size();</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; nums(arr);</span></span><br><span class="line"><span class="comment">        sort(nums.begin(), nums.end());</span></span><br><span class="line"><span class="comment">        unordered_map&lt;int, int&gt; h1, h2;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            ++h1[arr[i]];</span></span><br><span class="line"><span class="comment">            ++h2[nums[i]];</span></span><br><span class="line"><span class="comment">            if(h1 == h2)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                ans++;</span></span><br><span class="line"><span class="comment">                h1.clear();</span></span><br><span class="line"><span class="comment">                h2.clear();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;*/</span></span><br><span class="line">        <span class="comment">//此解法就极大缩短了时间，只需要寻找左边最大值小于右边最小值的区域即可</span></span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n, <span class="number">10</span>^<span class="number">8</span>)</span></span>;</span><br><span class="line">        l[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        r[n - <span class="number">1</span>] = arr[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//动态规划</span></span><br><span class="line">            l[i] = <span class="built_in">max</span>(l[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">            r[n - <span class="number">1</span> - i] = <span class="built_in">min</span>(r[n - i], arr[n - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = l[i] &lt;= r[i + <span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            res += ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(2n)，两个数组开辟 2n 的空间;</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-05 232. 用栈实现队列</title>
    <link href="/2021/09/14/Leetcode/91-day/day-05/"/>
    <url>/2021/09/14/Leetcode/91-day/day-05/</url>
    
    <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><strong><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">请你仅使用两个栈实现先入先出队列。</span><br><span class="line"></span><br><span class="line">队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</span><br><span class="line"></span><br><span class="line">实现 MyQueue 类：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> 将元素 x 推到队列的末尾</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> 从队列的开头移除并返回元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> 返回队列开头的元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">boolean <span class="title">empty</span><span class="params">()</span> 如果队列为空，返回 <span class="literal">true</span> ；否则，返回 <span class="literal">false</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">说明：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">你只能使用标准的栈操作</span></span><br><span class="line"><span class="function">就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">你所使用的语言也许不支持栈。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">进阶：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">你能否实现每个操作均摊时间复杂度为 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span> 的队列？</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">换句话说，执行 n 个操作的总时间复杂度为 <span class="title">O</span><span class="params">(n)</span> ，即使其中一个操作可能花费较长时间。</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入：</span></span><br><span class="line"><span class="function">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span></span><br><span class="line"><span class="function">[[], [1], [2], [], [], []]</span></span><br><span class="line"><span class="function">输出：</span></span><br><span class="line"><span class="function">[null, null, null, 1, 1, <span class="literal">false</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">解释：</span></span><br><span class="line"><span class="function">MyQueue myQueue </span>= <span class="keyword">new</span> <span class="built_in">MyQueue</span>();</span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.<span class="built_in">peek</span>(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.<span class="built_in">pop</span>(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.<span class="built_in">empty</span>(); <span class="comment">// return false</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= x &lt;= <span class="number">9</span></span><br><span class="line">最多调用 <span class="number">100</span> 次 push、pop、peek 和 empty</span><br><span class="line">假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、如题所给，创建两个栈，其中 s1 为入栈，s2 为出栈</li><li>2、由于栈是动态实现的，不存在上溢问题，所以入栈只需要将 x 保存至 s1 中即可</li><li>3、在 pop()、与 peek()函数中，是相同的逻辑，只是一个需要删除，一个不需要删除</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">2.</span><span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; s<span class="number">1.</span><span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s<span class="number">2.</span><span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s<span class="number">1.</span><span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">                s<span class="number">2.</span><span class="built_in">push</span>(s<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">                s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> temp = s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">2.</span><span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; s<span class="number">1.</span><span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s<span class="number">2.</span><span class="built_in">size</span>() != <span class="number">0</span>) <span class="keyword">return</span> s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s<span class="number">1.</span><span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">                s<span class="number">2.</span><span class="built_in">push</span>(s<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">                s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; s<span class="number">2.</span><span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O(1)，除了调用 pop()与 peek()初次需要较长的时间之外，其余都只需要 O(1)的复杂度。P(击败 100%应该是 O(1)吧)</p></li><li><p>空间复杂度：O(n)，两个栈一共存放输入 n 个数据规模，故应为 O(n);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-04 394. 字符串解码</title>
    <link href="/2021/09/13/Leetcode/91-day/day-04/"/>
    <url>/2021/09/13/Leetcode/91-day/day-04/</url>
    
    <content type="html"><![CDATA[<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><strong><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">给定一个经过编码的字符串，返回它解码后的字符串。</span><br><span class="line"></span><br><span class="line">编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。</span><br><span class="line"></span><br><span class="line">注意 k 保证为正整数。</span><br><span class="line"></span><br><span class="line">你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</span><br><span class="line"></span><br><span class="line">此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k 。</span><br><span class="line"></span><br><span class="line">例如不会出现像 <span class="number">3</span>a 或 <span class="number">2</span>[<span class="number">4</span>] 的输入。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;3[a]2[bc]&quot;</span></span><br><span class="line">输出：<span class="string">&quot;aaabcbc&quot;</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;3[a2[c]]&quot;</span></span><br><span class="line">输出：<span class="string">&quot;accaccacc&quot;</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;2[abc]3[cd]ef&quot;</span></span><br><span class="line">输出：<span class="string">&quot;abcabccdcdcdef&quot;</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;abc3[cd]xyz&quot;</span></span><br><span class="line">输出：<span class="string">&quot;abccdcdcdxyz&quot;</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、创建一个 stack<string> res 的辅助栈以及最终的返回值 string 类型的 res 初始化为空；</li><li>2、[ 之前的数字可能不止一位，所以要设置一个 sum 表示其之前数字的总和。</li><li>3、字符串题有大小写的区别，所以要注意大小写</li><li>4、看代码注释举例。</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; pos;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            <span class="comment">//if(s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)</span></span><br><span class="line">                sum = sum * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s))</span><br><span class="line">                <span class="comment">//if((s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;= &#x27;z&#x27;)||(s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;))</span></span><br><span class="line">                res += s[i]; <span class="comment">//注意大小写，之前第一次提交发现大小写也存在区分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(sum);</span><br><span class="line">                sum = <span class="number">0</span>;    <span class="comment">//重置 0</span></span><br><span class="line">                pos.<span class="built_in">push</span>(res);</span><br><span class="line">                res = <span class="string">&quot;&quot;</span>;   <span class="comment">//重置为空字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;]&#x27;</span>)   <span class="comment">//此处举例3[a2[c]];</span></span><br><span class="line">            &#123;       <span class="comment">//出现[后将3放入nums中，sum重置，res仍为&quot;&quot;</span></span><br><span class="line">                sum = nums.<span class="built_in">top</span>();  <span class="comment">//而后再出现[，此时sum=2;res=&quot;a&quot;,存入pos</span></span><br><span class="line">                nums.<span class="built_in">pop</span>();    <span class="comment">//第一次出现], 此时sum = nums.top() == 2</span></span><br><span class="line">                <span class="keyword">while</span>(sum)    <span class="comment">//pos.top = a, res = &#x27;c&#x27;,输出为res = &quot;acc&quot;</span></span><br><span class="line">                &#123;      <span class="comment">//第二次出现],sum = nums.top() == 3;</span></span><br><span class="line">                    pos.<span class="built_in">top</span>() += res;  <span class="comment">//pos.top = &quot;&quot; 第一次存入的res, res =&quot;acc&quot;,</span></span><br><span class="line">                    sum--;    <span class="comment">//画图更好理解，sum经历变化后的值最终始终为0</span></span><br><span class="line">                &#125;</span><br><span class="line">                res = pos.<span class="built_in">top</span>();</span><br><span class="line">                pos.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：一次遍历 O(s.size), 其中的 while 循环应该是常数级;</p></li><li><p>空间复杂度：O(s.size);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-03 1381. 设计一个支持增量操作的栈</title>
    <link href="/2021/09/12/Leetcode/91-day/day-03/"/>
    <url>/2021/09/12/Leetcode/91-day/day-03/</url>
    
    <content type="html"><![CDATA[<h1 id="1381-设计一个支持增量操作的栈"><a href="#1381-设计一个支持增量操作的栈" class="headerlink" title="1381. 设计一个支持增量操作的栈"></a><strong><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/">1381. 设计一个支持增量操作的栈</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">请你设计一个支持下述操作的栈。</span><br><span class="line"></span><br><span class="line">实现自定义栈类 CustomStack ：</span><br><span class="line"></span><br><span class="line"><span class="built_in">CustomStack</span>(<span class="type">int</span> maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量</span><br><span class="line"></span><br><span class="line">栈在增长到 maxSize 之后则不支持 push 操作。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span>：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span>：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> val)</span>：栈底的 k 个元素的值都增加 val</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">输入：</span></span><br><span class="line"><span class="function">[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,</span></span><br><span class="line"><span class="function">&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,</span></span><br><span class="line"><span class="function">&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span></span><br><span class="line"><span class="function">[[3],[1],[2],[2],[3],[4],[5,100],[2,100],[],[],[],[]]</span></span><br><span class="line"><span class="function">输出：</span></span><br><span class="line"><span class="function">[null,null,null,null,null,null,null,null,2，103,202,201]</span></span><br><span class="line"><span class="function">解释：</span></span><br><span class="line"><span class="function">CustomStack customStack </span>= <span class="keyword">new</span> <span class="built_in">CustomStack</span>(<span class="number">3</span>); <span class="comment">// 栈是空的 []</span></span><br><span class="line">customStack.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 栈变为 [1]</span></span><br><span class="line">customStack.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 栈变为 [1, 2]</span></span><br><span class="line">customStack.<span class="built_in">pop</span>(); <span class="comment">// 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]</span></span><br><span class="line">customStack.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 栈变为 [1, 2]</span></span><br><span class="line">customStack.<span class="built_in">push</span>(<span class="number">3</span>); <span class="comment">// 栈变为 [1, 2, 3]</span></span><br><span class="line">customStack.<span class="built_in">push</span>(<span class="number">4</span>); <span class="comment">// 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4</span></span><br><span class="line">customStack.<span class="built_in">increment</span>(<span class="number">5</span>, <span class="number">100</span>); <span class="comment">// 栈变为 [101, 102, 103]</span></span><br><span class="line">customStack.<span class="built_in">increment</span>(<span class="number">2</span>, <span class="number">100</span>); <span class="comment">// 栈变为 [201, 202, 103]</span></span><br><span class="line">customStack.<span class="built_in">pop</span>(); <span class="comment">// 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]</span></span><br><span class="line">customStack.<span class="built_in">pop</span>(); <span class="comment">// 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]</span></span><br><span class="line">customStack.<span class="built_in">pop</span>(); <span class="comment">// 返回 201 --&gt; 返回栈顶值 201，栈变为 []</span></span><br><span class="line">customStack.<span class="built_in">pop</span>(); <span class="comment">// 返回 -1 --&gt; 栈为空，返回 -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= maxSize &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">1</span> &lt;= x &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= val &lt;= <span class="number">100</span></span><br><span class="line">每种方法 increment，push 以及 pop 分别最多调用 <span class="number">1000</span> 次</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、创建一个动态数组 data，可以使用 c++中的 resize 函数重置数组容量，但反复动态扩容反而增大了时间的消耗。</li><li>2、push、pop 都是经典的栈写法；</li><li>3、increment 数通过一个数组遍历即可。</li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CustomStack</span>(<span class="type">int</span> maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(maxSize);</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top != data.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            data[++top] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> minx = <span class="built_in">min</span>(k, top + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">    stack []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(maxSize <span class="type">int</span>)</span></span> CustomStack &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomStack &#123;</span><br><span class="line">        stack : <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="built_in">cap</span> : maxSize,</span><br><span class="line">        top : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CustomStack)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.top &lt; this.<span class="built_in">cap</span> &#123;</span><br><span class="line">        this.stack = <span class="built_in">append</span>(this.stack, x)</span><br><span class="line">        this.top++</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CustomStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.top == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x := this.stack[this.top - <span class="number">1</span>]</span><br><span class="line">    this.stack = this.stack[:this.top - <span class="number">1</span>]</span><br><span class="line">    this.top--</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CustomStack)</span></span> Increment(k <span class="type">int</span>, val <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> k &gt; this.top &#123;</span><br><span class="line">        k = this.top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        this.stack[i] += val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(maxSize);</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * obj.Increment(k,val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：push、pop 均为 $O(1)$，而 increment 为 $O(minx)$，go 中为 $O(K)$。</p></li><li><p>空间复杂度：由创建的动态数组 data 的长度决定，即为 $O(maxSize)$。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-02 821. 字符的最短距离</title>
    <link href="/2021/09/11/Leetcode/91-day/day-02/"/>
    <url>/2021/09/11/Leetcode/91-day/day-02/</url>
    
    <content type="html"><![CDATA[<h1 id="821-字符的最短距离"><a href="#821-字符的最短距离" class="headerlink" title="821. 字符的最短距离"></a><strong><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821. 字符的最短距离</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 S 和一个字符 C</span><br><span class="line"></span><br><span class="line">返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;loveleetcode&quot;</span>, c = <span class="string">&quot;e&quot;</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">解释：字符 <span class="string">&#x27;e&#x27;</span> 出现在下标 <span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 和 <span class="number">11</span> 处（下标从 <span class="number">0</span> 开始计数）</span><br><span class="line"></span><br><span class="line">距下标 <span class="number">0</span> 最近的 <span class="string">&#x27;e&#x27;</span> 出现在下标 <span class="number">3</span> ，所以距离为 <span class="built_in">abs</span>(<span class="number">0</span> - <span class="number">3</span>) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">距下标 <span class="number">1</span> 最近的 <span class="string">&#x27;e&#x27;</span> 出现在下标 <span class="number">3</span> ，所以距离为 <span class="built_in">abs</span>(<span class="number">1</span> - <span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">对于下标 <span class="number">4</span> 来说，出现在下标 <span class="number">3</span> 和下标 <span class="number">5</span> 处的 <span class="string">&#x27;e&#x27;</span> 都离它最近。</span><br><span class="line"></span><br><span class="line">但距离是一样的 <span class="built_in">abs</span>(<span class="number">4</span> - <span class="number">3</span>) == <span class="built_in">abs</span>(<span class="number">4</span> - <span class="number">5</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">距下标 <span class="number">8</span> 最近的 <span class="string">&#x27;e&#x27;</span> 出现在下标 <span class="number">6</span> ，所以距离为 <span class="built_in">abs</span>(<span class="number">8</span> - <span class="number">6</span>) = <span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;aaab&quot;</span>, c = <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、建立一个 vector 存储遍历字符串后等于输入字符 c 的位置 position 下标</li><li>2、对于每一个位置，将其减去数组中的值，返回其 abs（绝对值），并返回其中最小的值。</li><li>3、min(abs(i - pos[j]), abs(i - pos[j + 1]))中会出现数组长度为一的特殊的情况，所以此处在今晚会进一步进行优化。</li></ul><h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(string s, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == c) pos.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; pos.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = <span class="built_in">min</span>(<span class="built_in">abs</span>(i - pos[j]), <span class="built_in">abs</span>(i - pos[j + <span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">if</span>(ans[i] &gt; tmp) ans[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[i] = <span class="built_in">abs</span>(i - pos[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestToChar</span><span class="params">(s <span class="type">string</span>, c <span class="type">byte</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    pos := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == c &#123;</span><br><span class="line">            pos = <span class="built_in">append</span>(pos, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != c &#123;</span><br><span class="line">            ans[i] = min(pos, i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(num []<span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    min := <span class="number">10000</span> <span class="comment">//因为最长为10000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> min &gt; abs(n - num[i]) &#123;</span><br><span class="line">            min = abs(n - num[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度：O($n*k$)，n 是 s 的长度，k 是字符 c 在字符串中出现的次数，k &lt;&#x3D; n。</p></li><li><p>空间复杂度：O(k)，k 为字符 c 出现的次数，这是记录字符 c 出现下标的辅助数组消耗的空间。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day-01 989. 数组形式的整数加法</title>
    <link href="/2021/09/10/Leetcode/91-day/day-01/"/>
    <url>/2021/09/10/Leetcode/91-day/day-01/</url>
    
    <content type="html"><![CDATA[<h1 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989. 数组形式的整数加法"></a><strong><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/">989. 数组形式的整数加法</a></strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。</span><br><span class="line"></span><br><span class="line">例如，如果 X = <span class="number">1231</span>，那么其数组形式为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]。</span><br><span class="line"></span><br><span class="line">给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>], K = <span class="number">34</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：<span class="number">1200</span> + <span class="number">34</span> = <span class="number">1234</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：A = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>], K = <span class="number">181</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">解释：<span class="number">274</span> + <span class="number">181</span> = <span class="number">455</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：A = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>], K = <span class="number">806</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：<span class="number">215</span> + <span class="number">806</span> = <span class="number">1021</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：A = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], K = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：<span class="number">9999999999</span> + <span class="number">1</span> = <span class="number">10000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= A.length &lt;= <span class="number">10000</span></span><br><span class="line"><span class="number">0</span> &lt;= A[i] &lt;= <span class="number">9</span></span><br><span class="line"><span class="number">0</span> &lt;= K &lt;= <span class="number">10000</span></span><br><span class="line">如果 A.length &gt; <span class="number">1</span>，那么 A[<span class="number">0</span>] != <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li>1、建立一个 res 的动态数组，以位数的形式来存储最后的结果值；</li><li>2、从后往前与 k 相加，然后对相加得到的值对 10 进行求余数；</li><li>3、如果 k 的位数大于 nums 数组所给的位数时候，必然导致 k 在循环内除以 10 后余留的值大于 0。</li><li>4、此时需要扩展数组，由于是动态数组，直接改写类似循环中 k &#x3D; sum &#x2F; 10，此处为 k &#x2F;&#x3D; 10，直到 k 为 0 为止。</li><li>4、最后逆序数组即可输出。</li></ul><h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[i] + k;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum % <span class="number">10</span>);</span><br><span class="line">            k = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(k % <span class="number">10</span>);</span><br><span class="line">            k /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addToArrayForm</span><span class="params">(num []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(num)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        v := num[i] + k;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, v % <span class="number">10</span>)</span><br><span class="line">        k = v / <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, k % <span class="number">10</span>)</span><br><span class="line">        k = k / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reverse(ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(num []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(num) - <span class="number">1</span>; i &lt;= j; &#123;</span><br><span class="line">        num[i], num[j] = num[j], num[i]</span><br><span class="line">        i++</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>空间复杂度：申请了一个常数级数组，故空间为 O(1)</li><li>时间复杂度：$O(max(n, \log k))$，其中 n 为数组的长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>91-day-algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unordered_map 的使用</title>
    <link href="/2021/01/08/cpp/unordered_map/"/>
    <url>/2021/01/08/cpp/unordered_map/</url>
    
    <content type="html"><![CDATA[<h2 id="本文主要写法参考C-STL函数库"><a href="#本文主要写法参考C-STL函数库" class="headerlink" title="本文主要写法参考C++ STL函数库"></a>本文主要写法参考<a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map">C++ STL函数库</a></h2><h1 id="std-unordered-map-C-11"><a href="#std-unordered-map-C-11" class="headerlink" title="std::unordered_map(C++11)"></a>std::unordered_map(C++11)</h1><blockquote><p>  unordered_map是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。</p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><blockquote><ol><li>关联性：通过key去检索value，而不是通过绝对地址（和顺序容器不同）</li><li>无序性：使用hash表存储，内部无序</li><li>Map : 每个值对应一个键值</li><li>键唯一性：不存在两个元素的键一样</li><li>动态内存管理：使用内存管理模型来动态管理所需要的内存空间</li></ol></blockquote><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                    <span class="comment">// unordered_map::key_type</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                      <span class="comment">// unordered_map::mapped_type</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Hash</span> = hash&lt;Key&gt;,                       <span class="comment">// unordered_map::hasher</span></span><br><span class="line">           <span class="keyword">class</span> Pred = equal_to&lt;Key&gt;,                   <span class="comment">// unordered_map::key_equal</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// unordered_map::allocator_type</span></span><br><span class="line">           &gt; <span class="keyword">class</span> unordered_map;</span><br></pre></td></tr></table></figure><p>一般只使用模板前2个参数&lt;KEY, T&gt; 即unordered_map&lt;const Key, T&gt; map;</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;Key, T&gt;::iterator it;</span><br><span class="line">(*it).first;             <span class="comment">// the key value (of type Key)</span></span><br><span class="line">(*it).second;            <span class="comment">// the mapped value (of type T)</span></span><br><span class="line">(*it);                   <span class="comment">// the &quot;element value&quot; (of type pair&lt;const Key,T&gt;) </span></span><br><span class="line">   </span><br><span class="line">it -&gt; first;  key       <span class="comment">// 它的键值分别是迭代器的first和second属性。</span></span><br><span class="line">it -&gt; second; T              </span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>  unordered_map的构造方式有几种：<br>  - 构造空的容器<br>  - 复制构造<br>  - 范围构造<br>  - 用数组构造</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> unordered_map&lt;string, string&gt; stringmap;</span><br><span class="line"></span><br><span class="line"><span class="function">stringmap <span class="title">merge</span><span class="params">(stringmap a, stringmap b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">stringmap <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    temp.<span class="built_in">insert</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringmap first;                                                <span class="comment">// 空</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">stringmap <span class="title">second</span><span class="params">(&#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;red&quot;</span>&#125;, &#123;<span class="string">&quot;lemon&quot;</span>, <span class="string">&quot;yellow&quot;</span>&#125;&#125;)</span></span>;      <span class="comment">// 用数组初始</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">stringmap <span class="title">third</span><span class="params">(&#123;&#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;, &#123;<span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;red&quot;</span>&#125;&#125;)</span></span>; <span class="comment">// 用数组初始</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">stringmap <span class="title">fourth</span><span class="params">(second)</span></span>;                                       <span class="comment">// 复制初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">stringmap <span class="title">fifth</span><span class="params">(merge(third, fourth))</span></span>;                          <span class="comment">// 移动初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">stringmap <span class="title">sixth</span><span class="params">(fifth.begin(), fifth.end())</span></span>;                    <span class="comment">// 范围初始化</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sixth contains:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : sixth)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; x.second;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sixth contains: apple:red lemon:yellow orange:orange strawberry:red</span><br></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><blockquote><p>  返回unordered_map的大小</p></blockquote><h4 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h4><blockquote><p>  为空返回true</p><p>  不为空返回false，和用size() &#x3D;&#x3D; 0判断一样。</p></blockquote><h4 id="find"><a href="#find" class="headerlink" title="find();"></a>find();</h4><blockquote><p>  查找key所在的元素。</p><p>  找到：返回元素的迭代器。通过迭代器的second属性获取值</p><p>  没找到：返回unordered_map::end</p></blockquote><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><blockquote><p>复制插入(复制一个已有的pair的内容)<br>数组插入（直接插入一个二维数组）<br>范围插入（复制一个起始迭代器和终止迭代器中间的内容）<br>数组访问模式插入(和数组的[]操作很相似)</p></blockquote><p>具体的例子可以看后面示例代码。</p><h4 id="at"><a href="#at" class="headerlink" title="at();"></a>at();</h4><blockquote><p>  查找key所对应的值<br>  如果存在：返回key对应的值，可以直接修改，和[]操作一样。<br>  如果不存在：抛出 out_of_range 异常.</p></blockquote><h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><blockquote><p>  通过位置（迭代器）</p><p>  通过key </p><p>  通过范围（两个迭代器</p></blockquote><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><blockquote><p>  清空unordered_map</p></blockquote><h4 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h4><blockquote><p>void swap(unordered_map&amp; ump);</p><p>交换两个unordered_map(整个交换两个map中的所有元素）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(unordered_map&lt;string, <span class="type">double</span>&gt; myrecipe, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : myrecipe)</span><br><span class="line">        cout &lt;&lt; x.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;string, <span class="type">double</span>&gt; myrecipe, mypantry = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;milk&quot;</span>, <span class="number">2.0</span>&#125;,                                                      </span><br><span class="line">        &#123;<span class="string">&quot;flour&quot;</span>, <span class="number">1.5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">pair&lt;string, <span class="type">double</span>&gt; <span class="title">myshopping</span><span class="params">(<span class="string">&quot;baking powder&quot;</span>, <span class="number">0.3</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">insert</span>(myshopping);                             <span class="comment">// 复制插入</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>&lt;string, <span class="type">double</span>&gt;(<span class="string">&quot;eggs&quot;</span>, <span class="number">6.0</span>)); <span class="comment">// 移动插入</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">insert</span>(mypantry.<span class="built_in">begin</span>(), mypantry.<span class="built_in">end</span>());       <span class="comment">// 范围插入</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">insert</span>(&#123;&#123;<span class="string">&quot;sugar&quot;</span>, <span class="number">0.8</span>&#125;, &#123;<span class="string">&quot;salt&quot;</span>, <span class="number">0.1</span>&#125;&#125;);        <span class="comment">// 初始化数组插入</span></span><br><span class="line">    </span><br><span class="line">    myrecipe[<span class="string">&quot;coffee&quot;</span>] = <span class="number">10.0</span>;                               <span class="comment">// 数组形式插入</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">display</span>(myrecipe, <span class="string">&quot;myrecipe contains:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************查找*****************/</span></span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;string, <span class="type">double</span>&gt;::const_iterator got = myrecipe.<span class="built_in">find</span>(<span class="string">&quot;coffee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got == myrecipe.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not found&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;found &quot;</span> &lt;&lt; got-&gt;first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; got-&gt;second &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****************修改*****************/</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">at</span>(<span class="string">&quot;coffee&quot;</span>) = <span class="number">9.0</span>;</span><br><span class="line">    </span><br><span class="line">    myrecipe[<span class="string">&quot;milk&quot;</span>] = <span class="number">3.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">display</span>(myrecipe, <span class="string">&quot;After modify myrecipe contains:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************擦除*****************/</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">erase</span>(myrecipe.<span class="built_in">begin</span>()); <span class="comment">//通过位置</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">erase</span>(<span class="string">&quot;milk&quot;</span>);           <span class="comment">//通过key</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">display</span>(myrecipe, <span class="string">&quot;After erase myrecipe contains:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************交换*****************/</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">swap</span>(mypantry);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">display</span>(myrecipe, <span class="string">&quot;After swap with mypantry, myrecipe contains:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************清空*****************/</span></span><br><span class="line">    </span><br><span class="line">    myrecipe.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">display</span>(myrecipe, <span class="string">&quot;After clear, myrecipe contains:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">myrecipe contains:</span><br><span class="line">salt: 0.1</span><br><span class="line">milk: 2</span><br><span class="line">flour: 1.5</span><br><span class="line">coffee: 10</span><br><span class="line">eggs: 6</span><br><span class="line">sugar: 0.8</span><br><span class="line">baking powder: 0.3</span><br><span class="line"></span><br><span class="line">found coffee is 10</span><br><span class="line"></span><br><span class="line">After modify myrecipe contains:</span><br><span class="line">salt: 0.1</span><br><span class="line">milk: 3</span><br><span class="line">flour: 1.5</span><br><span class="line">coffee: 9</span><br><span class="line">eggs: 6</span><br><span class="line">sugar: 0.8</span><br><span class="line">baking powder: 0.3</span><br><span class="line"></span><br><span class="line">After erase myrecipe contains:</span><br><span class="line">flour: 1.5</span><br><span class="line">coffee: 9</span><br><span class="line">eggs: 6</span><br><span class="line">sugar: 0.8</span><br><span class="line">baking powder: 0.3</span><br><span class="line"></span><br><span class="line">After swap with mypantry, myrecipe contains:</span><br><span class="line">flour: 1.5</span><br><span class="line">milk: 2</span><br><span class="line"></span><br><span class="line">After clear, myrecipe contains:</span><br></pre></td></tr></table></figure><h4 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h4><blockquote><p>begin() : 返回开始的迭代器</p><p>begin(int n) : 返回n号bucket的第一个迭代器</p></blockquote><h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><blockquote><p>  end(): 返回结束位置的迭代器</p><p>  end(int n) : 返回n号bucket的最后一个迭代器</p></blockquote><h4 id="bucket"><a href="#bucket" class="headerlink" title="bucket()"></a>bucket()</h4><blockquote><p>  返回通过哈希计算key所在的bucket</p><p>  此处仅使用哈希计算确定bucket，不保证key一定存在bucket中！</p></blockquote><h4 id="bucket-count"><a href="#bucket-count" class="headerlink" title="bucket_count()"></a>bucket_count()</h4><blockquote><p>  返回bucket的总数</p></blockquote><h4 id="bucket-size"><a href="#bucket-size" class="headerlink" title="bucket_size()"></a>bucket_size()</h4><blockquote><p>返回第i个bucket的大小</p><p>此位置的桶子里的元素数量，但是函数并不会判断n是否在count范围内）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;string, string&gt; mymap =</span><br><span class="line">    &#123;</span><br><span class="line">            &#123;<span class="string">&quot;house&quot;</span>, <span class="string">&quot;maison&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pomme&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;tree&quot;</span>, <span class="string">&quot;arbre&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;book&quot;</span>, <span class="string">&quot;livre&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;door&quot;</span>, <span class="string">&quot;porte&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;grapefruit&quot;</span>, <span class="string">&quot;pamplemousse&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/************begin和end迭代器***************/</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mymap contains:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it-&gt;second;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/************bucket操作***************/</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> n = mymap.<span class="built_in">bucket_count</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mymap has &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; buckets.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bucket #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;&#x27;s size:&quot;</span> </span><br><span class="line">             &lt;&lt; mymap.<span class="built_in">bucket_size</span>(i) &lt;&lt; <span class="string">&quot; contains: &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mymap.<span class="built_in">begin</span>(i); it != mymap.<span class="built_in">end</span>(i); ++it)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nkey:&#x27;apple&#x27; is in bucket #&quot;</span> &lt;&lt; mymap.<span class="built_in">bucket</span>(<span class="string">&quot;apple&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nkey:&#x27;computer&#x27; is in bucket #&quot;</span> &lt;&lt; mymap.<span class="built_in">bucket</span>(<span class="string">&quot;computer&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mymap contains: door:porte grapefruit:pamplemousse tree:arbre apple:pomme book:livre house:maison</span><br><span class="line">mymap has 7 buckets.</span><br><span class="line">bucket #0&#x27;s size:2 contains: [book:livre] [house:maison]</span><br><span class="line">bucket #1&#x27;s size:0 contains:</span><br><span class="line">bucket #2&#x27;s size:0 contains:</span><br><span class="line">bucket #3&#x27;s size:2 contains: [grapefruit:pamplemousse] [tree:arbre]</span><br><span class="line">bucket #4&#x27;s size:0 contains:</span><br><span class="line">bucket #5&#x27;s size:1 contains: [apple:pomme]</span><br><span class="line">bucket #6&#x27;s size:1 contains: [door:porte]</span><br><span class="line"></span><br><span class="line">key:&#x27;apple&#x27; is in bucket #5</span><br><span class="line"></span><br><span class="line">key:&#x27;computer&#x27; is in bucket #6</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>unordered_map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unordered_set 的使用方法</title>
    <link href="/2021/01/07/cpp/unordered_set/"/>
    <url>/2021/01/07/cpp/unordered_set/</url>
    
    <content type="html"><![CDATA[<h2 id="本文主要写法参考C-STL-函数库"><a href="#本文主要写法参考C-STL-函数库" class="headerlink" title="本文主要写法参考C++ STL 函数库"></a>本文主要写法参考<a href="http://www.cplusplus.com/reference/unordered_set/unordered_set/">C++ STL 函数库</a></h2><h1 id="std-unordered-set-C-11"><a href="#std-unordered-set-C-11" class="headerlink" title="std::unordered_set(C++11)"></a>std::unordered_set(C++11)</h1><blockquote><p>unordered_set 是一种关联容器，set 和 map 内部实现是基于 RedBlackTree，unordered_set 和 unordered_map 是基于 Hashtable。红黑树有序，而哈希表无序。</p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><ol><li>不再以键值对的形式存储数据，而是直接存储数据的值(只有一个值!)</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改</li><li>不会对内部存储的数据进行排序</li></ol></blockquote><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                        <span class="comment">// unordered_set::key_type/value_type</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Hash</span> = hash&lt;Key&gt;,           <span class="comment">// unordered_set::hasher</span></span><br><span class="line">           <span class="keyword">class</span> Pred = equal_to&lt;Key&gt;,       <span class="comment">// unordered_set::key_equal</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;Key&gt;      <span class="comment">// unordered_set::allocator_type</span></span><br><span class="line">           &gt; <span class="keyword">class</span> unordered_set;</span><br><span class="line"><span class="comment">//一般定义使用</span></span><br><span class="line">unordered_set&lt;T&gt; ans;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回头迭代器 begin()</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator it_begin = ans.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回尾迭代器 end()</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator it_end = ans.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const头迭代器 cbegin()</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::const_iterator const_it_begin = ans.<span class="built_in">cbegin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const尾迭代器 cend()</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::const_iterator const_it_end = ans.<span class="built_in">cend</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//槽迭代器</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::local_iterator local_iter_begin = ans.<span class="built_in">begin</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::local_iterator local_iter_end = ans.<span class="built_in">end</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="一般操作"><a href="#一般操作" class="headerlink" title="一般操作"></a>一般操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找函数 find() 通过给定主键查找元素</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;::iterator find_iter = ans.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//value出现的次数 count() 返回匹配给定主键的元素的个数</span></span><br><span class="line">ans.<span class="built_in">count</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素在哪个区域equal_range() 返回值匹配给定搜索值的元素组成的范围</span></span><br><span class="line">pair&lt;unordered_set&lt;<span class="type">int</span>&gt;::iterator, unordered_set&lt;<span class="type">int</span>&gt;::iterator&gt;</span><br><span class="line">       pair_equal_range = ans.<span class="built_in">equal_range</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数 emplace()</span></span><br><span class="line">ans.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数 emplace_hint() 使用迭代器</span></span><br><span class="line">ans.<span class="built_in">emplace_hint</span>(ite_begin, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数 insert()</span></span><br><span class="line">ans.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 erase()</span></span><br><span class="line">ans.<span class="built_in">erase</span>(<span class="number">1</span>);<span class="comment">//1.迭代器 value 区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空 clear()</span></span><br><span class="line">ans.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换 swap()，括号内可接另外一个unordered_set</span></span><br><span class="line">ans.<span class="built_in">swap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line">ans.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素个数 size()</span></span><br><span class="line">ans.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最大存储量 max_size()</span></span><br><span class="line">ans.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//篮子操作 篮子个数 bucket_count() 返回槽（Bucket）数</span></span><br><span class="line">ans.<span class="built_in">bucket_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//篮子最大数量 max_bucket_count() 返回最大槽数</span></span><br><span class="line">ans.<span class="built_in">max_bucket_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//篮子个数 bucket_size() 返回槽大小</span></span><br><span class="line">ans.<span class="built_in">bucket_size</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回篮子 bucket() 返回元素所在槽的序号</span></span><br><span class="line">ans.<span class="built_in">bucket</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//load_factor 返回载入因子，即一个元素槽（Bucket）的最大元素数</span></span><br><span class="line">ans.<span class="built_in">load_factor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//max_load_factor 返回或设置最大载入因子</span></span><br><span class="line">ans.<span class="built_in">max_load_factor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//rehash 设置槽数</span></span><br><span class="line">ans.<span class="built_in">rehash</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reserve请求改变容器容量</span></span><br><span class="line">ans.<span class="built_in">reserve</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash_function() 返回与hash_func相同功能的函数指针</span></span><br><span class="line"><span class="keyword">auto</span> hash_func_test = ans.<span class="built_in">hash_function</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//key_eq() 返回比较key值得函数指针</span></span><br><span class="line"><span class="keyword">auto</span> key_eq_test = ans.<span class="built_in">key_eq</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本上以上就是全部使用的方法</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>unordered_set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP Map container 学习</title>
    <link href="/2020/10/11/cpp/Map/"/>
    <url>/2020/10/11/cpp/Map/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要写法参考<a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map">C++ STL函数库</a></p></blockquote><h2 id="map简介"><a href="#map简介" class="headerlink" title="map简介"></a>map简介</h2><p>map是STL（中文标准模板库）的一个关联容器。</p><blockquote><ol><li>可以将任何基本类型映射到任何基本类型。如int array[100]事实上就是定义了一个int型到int型的映射。</li><li>map提供一对一的数据处理，key-value键值对，其类型可以自己定义，第一个称为关键字，第二个为关键字的值</li><li>map内部是自动排序的</li></ol></blockquote><h2 id="map的用法"><a href="#map的用法" class="headerlink" title="map的用法"></a>map的用法</h2><p>必须引入包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><p>map的定义</p><p>map&lt;type1name, type2name&gt; maps;&#x2F;&#x2F;第一个是键的类型，第二个是值的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; maps;</span><br></pre></td></tr></table></figure><p><strong>map容器内元素的访问</strong></p><blockquote><p>  通过下标进行访问</p><p>  maps[‘c’] &#x3D; 5;</p><p>  通过迭代器进行访问</p></blockquote><p>map可以使用it -&gt; first来访问键，使用it -&gt; second访问值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">   maps[<span class="string">&#x27;a&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">   maps[<span class="string">&#x27;b&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">   maps[<span class="string">&#x27;c&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line">   <span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it=mp.<span class="built_in">begin</span>(); it!=mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;it -&gt; first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;it -&gt; second&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map的常用用法</strong></p><ul><li>maps.insert() 插入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个map对象</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用insert函数插入pair</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">11</span>, <span class="string">&quot;kk&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用insert函数插入value_type数据</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">22</span>, <span class="string">&quot;pp&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用数组方式插入</span></span><br><span class="line">m[<span class="number">12</span>] = <span class="string">&quot;dd&quot;</span>;</span><br><span class="line">m[<span class="number">34</span>] = <span class="string">&quot;ff&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>maps.find()  查找一个元素</li><li>maps.clear() 清空</li><li>maps.erase() 删除一个元素</li><li>maps.size()  长度</li><li>maps.begin() 返回指向map头部的迭代器</li><li>maps.end()   返回指向map末尾的迭代器</li><li>maps.rbegin()返回指向map尾部的逆向迭代器</li><li>maps.rend()  返回指向map头部的逆向迭代器</li><li>maps.empty()判断其是否为空</li><li>maps.swap()交换两个map</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it=maps.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器刪除</span></span><br><span class="line">it = maps.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">maps.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键字删除</span></span><br><span class="line"><span class="type">int</span> n = maps.<span class="built_in">erase</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//如果刪除了返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class="line">maps.<span class="built_in">erase</span>(maps.<span class="built_in">begin</span>(), maps.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//等同于maps.clear()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = maps.<span class="built_in">size</span>();获取到map中映射的次数</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = maps.<span class="built_in">begin</span>(); it != maps.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout&lt;&lt; it-&gt; first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;itr -&gt; second&lt;&lt;endl;<span class="comment">//输出key 和value值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反向迭代</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::reverse_iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = maps.<span class="built_in">rbegin</span>(); it != maps.<span class="built_in">rend</span>(); it++)</span><br><span class="line">    cout&lt;&lt;it -&gt; first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;it -&gt; second&lt;&lt;endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go GET 代理</title>
    <link href="/2020/04/26/go/basic/go-get/"/>
    <url>/2020/04/26/go/basic/go-get/</url>
    
    <content type="html"><![CDATA[<p>windows 下在安装 github 的东西时，一般来说建议使用修改 git 配置，使用代理连接 github。</p><p><strong>即为打开</strong><code>C:\Users\Lenovo</code><strong>修改<code>.gitconfg</code>文件，加上如下图所示的相关配置</strong><br><img src="https://img-blog.csdnimg.cn/20200426173436588.png"></p><p><strong>如果是 sock5 连结，把<code>http:</code>改为<code>sock5:</code>即可，127.0.0.1 为本地环路，7890 是端口号，端口号以你的代理工具使用的端口号为准</strong></p><p><code>go get -u -v github.com/gin-gonic/gin</code> 使用代理的情况下都能下载，唯一一个包无法下载为<code>google.golang.org/protobuf</code>不仅仅只是网址找不到的原因，更多的是在<code>https://github.com/golang/protobuf</code>下没有这个包</p><p><strong>所以那么上面问题又要怎么去解决呢？</strong></p><p>搜索 google 最后发现，这个包使用另外一个 github 的仓库，地址为如下 <code>https://github.com/protocolbuffers/protobuf-go</code>,我们使用 go get 去下载它</p><p><code>go get -v -u github.com/protocolbuffers/protobuf-go</code></p><p>当然，这个源文件是下载在<code>gopath</code>里面的，为了使用方便，我们讲下载到<code>gopath</code>的这个文件放到<code>gopath</code>下的 <code>google.golang.org</code>下去，而且如果解压后文件有版本号时，除去这个版本号，跟上面包名保持一致即可。<br>这样就解决好问题了。</p><hr><p>其中 go 现在采用 go mod 进行包模式的管理，所以说一般出现包管理问题，<br>使用<code>go mod tidy</code> 可以解决一些依赖包的问题。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/2020/03/24/cpp/cpp_interview/"/>
    <url>/2020/03/24/cpp/cpp_interview/</url>
    
    <content type="html"><![CDATA[<p>记录刷题的细节内容，算法与 c++特性（等之后有空再优化）</p><hr><h4 id="1-static-定义静态局部变量特点"><a href="#1-static-定义静态局部变量特点" class="headerlink" title="1.static 定义静态局部变量特点"></a>1.static 定义静态局部变量特点</h4><pre><code>全局数据区分配内存；执行首次初始化后，之后函数调用不在初始化无显示初始化后，自动初始化为0</code></pre><hr><h4 id="2-局部变量存在于堆栈中，全局变量存在于（静态区）中，动态申请数据存在于（堆）"><a href="#2-局部变量存在于堆栈中，全局变量存在于（静态区）中，动态申请数据存在于（堆）" class="headerlink" title="2.局部变量存在于堆栈中，全局变量存在于（静态区）中，动态申请数据存在于（堆）"></a>2.局部变量存在于堆栈中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</h4><hr><h4 id="3-模板"><a href="#3-模板" class="headerlink" title="3.模板"></a>3.模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">template</span>&lt;<span class="keyword">typename</span> 数据类型参数标识符&gt;(<span class="keyword">typename</span> 和 <span class="keyword">class</span> 没区别)</span><br><span class="line">&lt;返回类型&gt;&lt;函数名&gt;(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line">模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名</span><br><span class="line">声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方</span><br><span class="line">都可以使用模板形参名</span><br><span class="line">example:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(T op1, T op2)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;op1&lt;&lt;op2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;sum &lt;<span class="type">int</span>&gt;::<span class="built_in">foo</span>(<span class="number">1</span>,<span class="number">3</span>)   <span class="comment">//一个完整的例子</span></span><br></pre></td></tr></table></figure><hr><h4 id="4-c-虚函数概念（弱点）"><a href="#4-c-虚函数概念（弱点）" class="headerlink" title="4.c++虚函数概念（弱点）"></a>4.c++虚函数概念（弱点）</h4><p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数。</p><p>当子类重新定义了父类的虚函数后，<strong>当父类的指针指向子类对象的地址时</strong>，[即 B b; A a &#x3D; &b;]</p><p>父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数，而如果使用了<strong>virtual</strong>关键字，程序将根据引用或指针指向的 <strong>对 象 类 型</strong> 来选择方法，否则使用<strong>引用类型或指针类型</strong>来选择方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line"></span><br><span class="line"> A *pa;</span><br><span class="line"></span><br><span class="line"> pa = &amp;b;</span><br><span class="line"></span><br><span class="line"> A *pa2 = newA;</span><br><span class="line"></span><br><span class="line"> pa-&gt;<span class="built_in">FuncA</span>(); （ <span class="number">3</span>） pa=&amp;b动态绑定但是FuncA不是虚函数，所以FuncA called</span><br><span class="line"></span><br><span class="line"> pa-&gt;<span class="built_in">FuncB</span>(); （ <span class="number">4</span>） FuncB是虚函数所以调用B中FuncB，FuncBB called</span><br><span class="line"></span><br><span class="line"> pa2-&gt;<span class="built_in">FuncA</span>(); （ <span class="number">5</span>） pa2是A类指针，不涉及虚函数，</span><br><span class="line"> 调用的都是A中函数，所以输出 FuncA called FuncB called</span><br></pre></td></tr></table></figure><hr><h4 id="5-vector-的函数-erase"><a href="#5-vector-的函数-erase" class="headerlink" title="5.vector 的函数 erase()"></a>5.vector 的函数 erase()</h4><p>一次只删除一个元素，返回一个迭代器指针，指向下一个元素。</p><hr><h4 id="6-默认只读模式打开文件"><a href="#6-默认只读模式打开文件" class="headerlink" title="6.默认只读模式打开文件"></a>6.默认只读模式打开文件</h4><p>ios (iostream) : app 和 ios : app ｜ ios : out，是一个意思，只能输出不能输入</p><hr><h4 id="7-数组的定义区别理解"><a href="#7-数组的定义区别理解" class="headerlink" title="7.数组的定义区别理解"></a>7.数组的定义区别理解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *s[<span class="number">8</span>];</span><br><span class="line">   定义一个指针数组，该数组中每个元素是一个指针，</span><br><span class="line">   每个指针指向哪里就需要程序中后续再定义了。</span><br><span class="line"><span class="built_in">int</span> (*s)[<span class="number">8</span>];</span><br><span class="line">   定义一个数组指针，该指针指向含<span class="number">8</span>个元素的一维数组（数组中每个元素是<span class="type">int</span>型）。</span><br><span class="line"></span><br><span class="line">区分<span class="type">int</span> *p[n]; 和<span class="built_in">int</span> (*p)[n];</span><br><span class="line">就要看运算符的优先级了。</span><br><span class="line"><span class="type">int</span> *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，</span><br><span class="line">再由<span class="type">int</span>*说明这是一个整型指针数组。</span><br><span class="line"><span class="built_in">int</span> (*p)[n]; 中( )优先级高，</span><br><span class="line">首先说明p是一个指针，指向一个整型的一维数组。</span><br></pre></td></tr></table></figure><hr><h4 id="8-函数模板"><a href="#8-函数模板" class="headerlink" title="8.函数模板"></a>8.函数模板</h4><p>函数模板必须由编译器根据程序员的调用类型实例化为可执行的函数。</p><p>类模板的成员函数都是函数模板</p><p>没使用过的成员函数（即函数模板）不会被实例化</p><hr><h4 id="9-双目运算符的判断机制"><a href="#9-双目运算符的判断机制" class="headerlink" title="9.双目运算符的判断机制"></a>9.双目运算符的判断机制</h4><p>&amp;&amp;和||的判断机制，A&amp;&amp;B，若 A 为假，直接返回 false，B 不执行，若 A 为 true，继续执行 B；A||B，若 A 为 true，直接返回 true，B 不执行</p><hr><h4 id="10-c-中的-switch"><a href="#10-c-中的-switch" class="headerlink" title="10. c++中的 switch"></a>10. c++中的 switch</h4><blockquote><p>1.switch 后面的“表达式”，可以是 int、char 和枚举型中的一种，不能是 float 型变量</p><p>2.case 后面必须是“常量表达式”，表达式中不能包含变量</p><p>3.switch 后的表达式加了分号 ；非法</p></blockquote><hr><h4 id="11-unsigned"><a href="#11-unsigned" class="headerlink" title="11.unsigned"></a>11.unsigned</h4><p>unsigned 为无符号整数，取值范围位 0-255，永远不可能小于零，最好不要做控制条件。</p><hr><h4 id="12-派生类继承编译"><a href="#12-派生类继承编译" class="headerlink" title="12.派生类继承编译"></a>12.派生类继承编译</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">派生类继承（<span class="keyword">public</span>, <span class="keyword">private</span>）基类成员后，</span><br><span class="line">继承的基类成员在派生类中的相应权限的改变。</span><br><span class="line"> <span class="keyword">public</span>  继承,基类的各类（<span class="keyword">public</span>, <span class="keyword">protected</span>, <span class="keyword">private</span>）成员</span><br><span class="line"> 在派生类中权限与原来在基类时保持一致;</span><br><span class="line"> <span class="keyword">private</span> 继承,基类的各类成员在派生类中权限均变为<span class="keyword">private</span>.</span><br><span class="line">    故C类中的print调用A::<span class="built_in">print</span>()，</span><br><span class="line">    因为A::<span class="built_in">print</span>()此时在C类中为<span class="keyword">private</span>等级,</span><br><span class="line">    所以不能被C类任何成员所访问，故不能通过编译</span><br></pre></td></tr></table></figure><hr><h4 id="13-引用"><a href="#13-引用" class="headerlink" title="13.引用"></a>13.引用</h4><p>引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如<code>int &amp;refVal = val;</code></p><ul><li>1、引用必须初始化</li><li>2、引用与其初始值是<strong>绑定 bind</strong>在一起的，而不是拷贝区域</li><li>3、值传递以拷贝实参，传递给形参。</li></ul><hr><h4 id="14-C-STL-Standard-Template-Library-string-库中的风格比-C-风格的字符串更加安全、高效"><a href="#14-C-STL-Standard-Template-Library-string-库中的风格比-C-风格的字符串更加安全、高效" class="headerlink" title="14.C++ STL (Standard Template Library) string 库中的风格比 C 风格的字符串更加安全、高效"></a>14.C++ STL (Standard Template Library) string 库中的风格比 C 风格的字符串更加安全、高效</h4><hr><h4 id="15-while-与-for"><a href="#15-while-与-for" class="headerlink" title="15.while 与 for"></a>15.while 与 for</h4><ul><li><strong>while：</strong> 为不确定迭代的次数时使用，例如读取数据</li><li>​ <strong>for：</strong> 确定范围时使用，也可以省略初始值、条件、已经表达式</li></ul><hr><h4 id="16-异常问题"><a href="#16-异常问题" class="headerlink" title="16.异常问题"></a>16.异常问题</h4><p>throw、try、异常块；</p><p><strong>throw：</strong> 异常表达式表示其遇到无法处理的问题，引发 raise 的异常</p><p>​ <strong>try：</strong> try 和一个多个 catch 字段配合结束，一般的 try 抛出的某个异常会被某个 catch 捕获处理，故 catch 称为异常处理代码。</p><hr><h4 id="17、class-与-struct-区别"><a href="#17、class-与-struct-区别" class="headerlink" title="17、class 与 struct 区别"></a>17、class 与 struct 区别</h4><p>在于访问权限</p><p><code>class</code> 第一个访问说明符之前的成员为<code>private</code></p><p><code>struct</code>第一个访问说明符之前的成员为<code>public</code></p><hr><h4 id="18-使用非成员版本的swap是一个好习惯"><a href="#18-使用非成员版本的swap是一个好习惯" class="headerlink" title="18.使用非成员版本的swap是一个好习惯"></a>18.使用非成员版本的<code>swap</code>是一个好习惯</h4><p><code>swap(c1,c2)==c1.swap(c2)</code>，但是使用最好使用前者。</p><h4 id="19-泛型算法"><a href="#19-泛型算法" class="headerlink" title="19.泛型算法"></a>19.泛型算法</h4><p>头文件<code>#include&lt;algorithm&gt; ||#include&lt;numeric&gt;</code>标准库中提供了超过 100 个算法，所以说阅读源代码非常重要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> (ilst.<span class="built_in">begin</span>(), ilst.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(ivec))</span><br><span class="line">   copy函数</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-关联容器（hash、map、set）"><a href="#20-关联容器（hash、map、set）" class="headerlink" title="20.关联容器（hash、map、set）"></a>20.关联容器（hash、map、set）</h4><ul><li><code>map</code>：<code>map&lt;string, int&gt; word_count = &#123;&#123;"a", 1&#125;, &#123;"b", 2&#125;&#125;;</code></li><li><code>set</code>：<code>set&lt;string&gt; exclude = &#123;&quot;the&quot;, &quot;a&quot;&#125;;</code></li><li>unordered_map（hash 组织 map）</li><li>unordered_set（hash 组织 set）</li></ul><hr><h4 id="21-字符指针"><a href="#21-字符指针" class="headerlink" title="21.字符指针"></a>21.字符指针</h4><p><code>char *str[3] = &#123;&quot;stra&quot;,&quot;strb&quot;,&quot;strc&quot;&#125;</code>;是一个指针数组； <code>char *p = str[0]</code>；实际上 p 指向第一个字符串，所以字符串加 1，则指向字符串的下一个字母，而并非是下一个字符串</p><hr><h4 id="22-static-与-非-static-，全局变量与局部变量"><a href="#22-static-与-非-static-，全局变量与局部变量" class="headerlink" title="22.static 与 非 static ，全局变量与局部变量"></a>22.static 与 非 static ，全局变量与局部变量</h4><p>无论是 static 还是非 static 的全局变量，如果不加限制随意访问的话易出现同步问题。</p><p>无论是 static 还是非 static 的局部变量，每个线程都是私有的，其他线程不会对其进行干扰。</p><hr><h4 id="23-C-C-中-main-函数为入口函数，为必须存在函数"><a href="#23-C-C-中-main-函数为入口函数，为必须存在函数" class="headerlink" title="23.C&#x2F;C++中 main 函数为入口函数，为必须存在函数"></a>23.C&#x2F;C++中 main 函数为入口函数，为必须存在函数</h4><hr><h4 id="24-throw、catch、try"><a href="#24-throw、catch、try" class="headerlink" title="24.throw、catch、try"></a>24.throw、catch、try</h4><ul><li><p>throw 是抛出异常关键字，try 是尝试执行可能有异常代码的关键字，catch 是捕获异常的关键字</p></li><li><p>可能抛出异常的代码块都应该放在 try 代码块中</p></li><li><p>catch 捕获相应的异常，可以有多级 catch 代码块来捕获不同级别的异常</p></li><li><p>被捕获的异常可以再次抛出</p></li></ul><hr><h4 id="25-线程"><a href="#25-线程" class="headerlink" title="25.线程"></a>25.线程</h4><blockquote><p>线程使用了<code>wait</code>方法，会强行打断当前操作，进入阻塞（暂停）状态，然后需要<code>notify</code>方法或<code>notifyAll</code>方法才能进入就绪状态。</p></blockquote><hr><h4 id="26-枚举变量"><a href="#26-枚举变量" class="headerlink" title="26.枚举变量"></a>26.枚举变量</h4><p><strong>枚举变量是全局变量的情况下，枚举值的缺省值是 0，不是枚举的第一个值。其他情况，其值是不定的，而且不限定于所列出的枚举值。</strong></p><p><strong>全局变量时初始化为 0，局部变量时初始化为随机值。</strong></p><hr><h4 id="26-unsigned"><a href="#26-unsigned" class="headerlink" title="26.unsigned"></a>26.unsigned</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">移动的<span class="number">1</span>代表的是一个单位量</span><br><span class="line">    <span class="type">unsigned</span></span><br><span class="line">p1<span class="number">+5</span>=p1<span class="number">+5</span>*<span class="number">1</span>=p1<span class="number">+5</span>*<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)</span><br><span class="line">=p1<span class="number">+5</span>*<span class="number">1</span>=<span class="number">0x801000</span>+ox5=<span class="number">0x801005</span></span><br><span class="line">p2<span class="number">+5</span>=p2<span class="number">+5</span>*<span class="number">1</span>=p2<span class="number">+5</span>*<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)</span><br><span class="line">=p1<span class="number">+5</span>*<span class="number">4</span>=<span class="number">0x810000</span><span class="number">+20</span>=<span class="number">0x810000</span><span class="number">+0x14</span>=<span class="number">0x810014</span></span><br></pre></td></tr></table></figure><hr><h4 id="27-数组、指针、字符串的长度计算"><a href="#27-数组、指针、字符串的长度计算" class="headerlink" title="27.数组、指针、字符串的长度计算"></a>27.数组、指针、字符串的长度计算</h4><p>对字符串进行<code>sizeof</code>操作的时候，会把字符串的结束符<code>\0</code>计算进去的</p><p>进行<code>strlen</code>操作求字符串的长度的时候，不计算<code>\0</code>的。</p><p>数组作为函数参数传递的时候，已经退化为指针了，<code>Func</code>函数的参数<code>str_arg</code>只是表示一个指针，那个<code>str_arg[]</code>括号中的数值不起任何作用。</p><hr><h4 id="28-强制类型转换后指针的类型"><a href="#28-强制类型转换后指针的类型" class="headerlink" title="28.强制类型转换后指针的类型"></a>28.强制类型转换后指针的类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;glad to test something&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = str;</span><br><span class="line">p++;</span><br><span class="line"><span class="type">int</span> *p1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span> *&gt;(p);</span><br><span class="line">p1++;</span><br><span class="line">p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result is %s\n&quot;</span>, p);</span><br></pre></td></tr></table></figure><p>p 的类型为<code>char *，p++</code>后<code>p</code>指向<code>str</code>数组的第 2 个元素即字母“l”的位置。</p><p>p1 的类型为<code>int *，p1++</code>后<code>p1</code>指向的位置增加 4 个字节，</p><p>指向<code>str</code>数组中的第 6 个元素即字母<code>t</code>的位置。</p><p>因此最后 p 的内容为<code>to test something</code>。</p><hr><h4 id="29-类"><a href="#29-类" class="headerlink" title="29.类"></a>29.类</h4><ul><li>在类中，如果为空类，则类占用 1 个字节</li><li>一旦类中有其他的占用空间成员，则这 1 个字节就不在计算之内，</li><li>一个类只有一<code>int</code>则占用 4 字节而不是 5 字节。</li><li>如果只有成员函数，则还是只占用 1 个字节，因为类函数不占用空间</li><li>但是由于虚函数存在一个虚函数表，需要 4 个字节，数据成员对象如果为指针则为 4 字节，注意有字节对齐，如果为 13 字节，则进位到 16 字节空间</li></ul><h4 id="29-类-1"><a href="#29-类-1" class="headerlink" title="29.类"></a>29.类</h4><ul><li>在类中，如果为空类，则类占用 1 个字节</li><li>一旦类中有其他的占用空间成员，则这 1 个字节就不在计算之内，</li><li>一个类只有一<code>int</code>则占用 4 字节而不是 5 字节。</li><li>如果只有成员函数，则还是只占用 1 个字节，因为类函数不占用空间</li><li>但是由于虚函数存在一个虚函数表，需要 4 个字节，数据成员对象如果为指针则为 4 字节，注意有字节对齐，如果为 13 字节，则进位到 16 字节空间</li></ul><hr><h4 id="30-buffer"><a href="#30-buffer" class="headerlink" title="30.buffer"></a>30.buffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数<span class="function"><span class="type">char</span> *<span class="title">myString</span><span class="params">()</span>中没有使用<span class="keyword">new</span>或者malloc分配内存，</span></span><br><span class="line"><span class="function">所有buffer数组的内存区域在栈区</span></span><br><span class="line"><span class="function">随着<span class="type">char</span> *<span class="title">myString</span><span class="params">()</span>的结束，栈区内存释放，字符数组也就不存在了，</span></span><br><span class="line"><span class="function">所以会产生野指针，输出结果未知</span></span><br></pre></td></tr></table></figure><hr><h4 id="31-动态分配在堆区，其他的均不在堆区"><a href="#31-动态分配在堆区，其他的均不在堆区" class="headerlink" title="31.动态分配在堆区，其他的均不在堆区"></a>31.动态分配在堆区，其他的均不在堆区</h4><hr><h4 id="32-操作系统中用户态切换到内核态的-3-种方式"><a href="#32-操作系统中用户态切换到内核态的-3-种方式" class="headerlink" title="32.操作系统中用户态切换到内核态的 3 种方式"></a>32.操作系统中用户态切换到内核态的 3 种方式</h4><p>a. 系统调用</p><p>b. 异常</p><p>c. 外围设备的中断</p><hr><h4 id="33-函数嵌套"><a href="#33-函数嵌套" class="headerlink" title="33.函数嵌套"></a>33.函数嵌套</h4><p>若有如下函数定义，这种嵌套定义根本算不出结果，所以函数嵌套定义肯定不行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>=&#123;<span class="keyword">return</span> a+<span class="built_in">f1</span>(a);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> b)</span></span>=&#123;<span class="keyword">return</span> b+<span class="built_in">f</span>(b);&#125;</span><br><span class="line">无法算出结果故定义嵌套不使用</span><br></pre></td></tr></table></figure><hr><h4 id="34-静态变量初始化"><a href="#34-静态变量初始化" class="headerlink" title="34.静态变量初始化"></a>34.静态变量初始化</h4><p>在 C++中，类的静态成员（static member）必须在类内声明，在类外初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="type">static</span> <span class="type">int</span> count ; <span class="comment">// 类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count = <span class="number">0</span> ; <span class="comment">// 类外初始化，不必再加static关键字</span></span><br></pre></td></tr></table></figure><p>为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><p>能在类中初始化的成员只有一种，那就是静态常量成员。</p><p>这样不行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>: <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  静态成员不能在类内初始化</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>: <span class="type">const</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">   常量成员也不能在类内初始化</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>: <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">   静态常量成员可以在类内初始化</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>priority_queue|multiset</title>
    <link href="/2020/01/04/cpp/queue/"/>
    <url>/2020/01/04/cpp/queue/</url>
    
    <content type="html"><![CDATA[<p>c++中STL中，除了bitset、priority_queue(堆，也叫优先队列)以及AVL(平衡树相关)，其他的都可以进行短时间的手撕代码进行实现，本次博客主要是阐述一些讲一下堆与平衡树的基本用法，以及其中区别所在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">priority_queue堆/优先队列</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">    </span><br><span class="line">priority_queue&lt;T&gt;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; 大根堆</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; 大根堆</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; 小根堆</span><br><span class="line">priority_queue &lt;<span class="keyword">struct</span> T&gt;</span><br><span class="line">    </span><br><span class="line">基本函数：</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(x)：加入一个元素，可以是数 <span class="keyword">or</span> 结构体</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()：弹出堆顶</span><br><span class="line"></span><br><span class="line"><span class="built_in">top</span>()：堆顶的元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()：堆的大小</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()：是否为空（空即为 <span class="number">1</span>）</span><br><span class="line"></span><br><span class="line">关于结构体的比较：</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (type left, type right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.x &lt; right.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">结构体的赋值可以为&#123;a,b,...&#125;或名称&#123;a,b,...&#125;</span><br><span class="line"></span><br><span class="line">multiset vs set</span><br><span class="line">    multiset 可以有重复元素，故一般情况下，（除解决重复元素的集合类问题）都用 multiset</span><br><span class="line">multiset 也进行自实现排序。</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line"></span><br><span class="line">multiset&lt;T&gt;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; 从小到大</span><br><span class="line">multiset&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt; &gt; less&lt;<span class="type">int</span>&gt;表示数字大的优先级大</span><br><span class="line">multiset&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt; &gt; greater&lt;<span class="type">int</span>&gt;表示数字小的优先级大</span><br><span class="line">multiset&lt;<span class="keyword">struct</span> T&gt;</span><br><span class="line">    </span><br><span class="line">迭代器：</span><br><span class="line"></span><br><span class="line">multiset&lt;定义和对应的 set 一致&gt; ::iterator，其作用是遍历 set/特别指向某一个元素</span><br><span class="line"></span><br><span class="line">基本函数：</span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(x)：加入一个元素，可以是数/结构体</span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(x)：当x为数或结构体，即为删掉所有的x；当x 为迭代器，那么只会删掉迭代器对应的元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">begin</span>()：返回关键值最小的元素指针，指针x对应的值为 *x，如果是结构体则为（*x）.<span class="function">a</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">end</span><span class="params">()</span>：返回关键值最大的元素指针的后一位（最大的是<span class="title">end</span><span class="params">()</span>--）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span>, <span class="title">empty</span><span class="params">()</span>：同优先队列</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">(x)</span>：第一个大于等于 x 的元素指针</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">(x)</span>：第一个大于 x 的元素指针</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">multiset&lt;T&gt; st</span></span><br><span class="line"><span class="function">st.<span class="title">insert</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;*st.<span class="built_in">lower_bound</span>(<span class="number">3</span>)&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;*st.<span class="built_in">upper_bound</span>(<span class="number">3</span>)&lt;&lt;endl;    <span class="comment">//&gt;= &gt;</span></span><br><span class="line">cout&lt;&lt;*--st.<span class="built_in">lower_bound</span>(<span class="number">3</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*--st.<span class="built_in">upper_bound</span>(<span class="number">3</span>)&lt;&lt;endl; <span class="comment">//&lt; &lt;=</span></span><br><span class="line"><span class="comment">//3 4</span></span><br><span class="line"><span class="comment">//2 3</span></span><br><span class="line">遍历：</span><br><span class="line">可以通过迭代器的移动来遍历（头为 <span class="built_in">begin</span>()，尾为--<span class="built_in">end</span>()，最大能走到 <span class="built_in">end</span>()）</span><br><span class="line"></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> a = st.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (a != st.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *a &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++a;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3区别</span></span><br><span class="line"><span class="comment">//multiset可以遍历、前驱、后继、删除；</span></span><br><span class="line"><span class="comment">//而priority_queue的比较机制和set/sort相反</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(a, b, c) for (a = b; a &lt;= c; a++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(a, b, c) for (a = b; a &gt;= c; a--)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (type left, type right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.x &lt; right.x;<span class="comment">//此处不能重载大于号，在数学上来说重载小于号的作用更好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiset&lt;type&gt; a;</span><br><span class="line">priority_queue&lt;type&gt; b;</span><br><span class="line">type c[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">insert</span>(&#123;<span class="number">3</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    a.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    a.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    b.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    b.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    b.<span class="built_in">push</span>(&#123;<span class="number">3</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    c[<span class="number">0</span>] = &#123;<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    c[<span class="number">1</span>] = &#123;<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    c[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(c, c + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; (*a.<span class="built_in">begin</span>()).x &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; b.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c[<span class="number">0</span>].x &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//1 3 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，priority_queue得到的结果和multiset&#x2F;sort 刚好相反.</p><p>实际上multiset与sort的最终的状态满足 a1 &lt; a2 &lt; a3 &lt; … &lt; an（ &lt; 可重载）</p><p>而priority_queue应该是当一个元素x满足 f(a[x]) &lt; x 时交换，实质上维护的是大根堆</p><p>优先队列 ⇔ 排序后为先大后小</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>priority_queue</tag>
      
      <tag>multiset</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
